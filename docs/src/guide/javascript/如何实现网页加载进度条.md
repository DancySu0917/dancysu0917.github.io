# 如何实现网页加载进度条？（了解）

## 标准答案

网页加载进度条可以通过以下几种方式实现：

1. **基于 JavaScript 的进度条**：通过监听页面加载事件或资源加载状态来计算进度
2. **CSS 动画实现**：使用纯 CSS 实现进度条动画效果
3. **第三方库**：如 NProgress.js、PACE.js 等专门的进度条库
4. **浏览器原生 API**：利用 fetch、XMLHttpRequest 的进度事件
5. **路由级别的进度条**：在单页应用中配合路由切换显示进度

## 深入分析

网页加载进度条是提升用户体验的重要组件，它让用户了解页面加载状态，减少等待焦虑。实现加载进度条需要考虑以下几个方面：

### 1. 加载阶段的识别

- **页面初始化阶段**：HTML 文档加载
- **资源加载阶段**：CSS、JavaScript、图片等资源加载
- **内容渲染阶段**：DOM 构建和页面渲染
- **异步数据加载阶段**：API 请求、动态内容加载

### 2. 进度计算方式

- **基于资源数量**：统计总资源数和已加载资源数
- **基于字节数**：计算已加载字节数与总字节数的比率
- **模拟进度**：在不确定加载时间时使用模拟进度条

### 3. 用户体验考虑

- **视觉反馈**：进度条应提供连续的视觉反馈
- **响应速度**：进度条更新不应影响页面性能
- **取消机制**：提供用户取消加载的选项（可选）

## 代码实现

### 1. 简单的 JavaScript 进度条

```javascript
class LoadingProgressBar {
  constructor(options = {}) {
    this.options = {
      container: options.container || document.body,
      height: options.height || '2px',
      color: options.color || '#29d',
      zIndex: options.zIndex || 9999,
      ...options
    };
    
    this.currentProgress = 0;
    this.isAnimating = false;
    this.init();
  }

  init() {
    // 创建进度条元素
    this.progressBar = document.createElement('div');
    this.progressBar.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: ${this.options.height};
      background: ${this.options.color};
      z-index: ${this.options.zIndex};
      transition: width 0.2s ease;
      box-shadow: 0 0 10px rgba(41, 133, 221, 0.5);
    `;
    
    this.options.container.appendChild(this.progressBar);
  }

  // 设置进度
  setProgress(percentage) {
    this.currentProgress = Math.min(100, Math.max(0, percentage));
    this.progressBar.style.width = this.currentProgress + '%';
    
    if (this.currentProgress >= 100) {
      this.complete();
    }
  }

  // 模拟加载进度
  simulateLoading() {
    if (this.isAnimating) return;
    
    this.isAnimating = true;
    let progress = 0;
    
    const simulate = () => {
      if (progress < 90) {
        // 模拟不均匀的进度增长（模拟真实加载情况）
        progress += Math.random() * 15;
        this.setProgress(Math.min(90, progress));
        setTimeout(simulate, 100 + Math.random() * 200);
      }
    };
    
    simulate();
  }

  // 完成加载
  complete() {
    this.setProgress(100);
    setTimeout(() => {
      this.hide();
    }, 300);
  }

  // 隐藏进度条
  hide() {
    this.progressBar.style.opacity = '0';
    setTimeout(() => {
      this.progressBar.style.display = 'none';
      this.currentProgress = 0;
      this.isAnimating = false;
    }, 300);
  }

  // 重置进度条
  reset() {
    this.currentProgress = 0;
    this.progressBar.style.width = '0%';
    this.progressBar.style.opacity = '1';
    this.progressBar.style.display = 'block';
  }

  // 开始加载
  start() {
    this.reset();
    this.simulateLoading();
  }
}

// 使用示例
const progressBar = new LoadingProgressBar({
  color: '#4CAF50',
  height: '3px'
});

// 模拟页面加载
window.addEventListener('load', () => {
  progressBar.start();
});
```

### 2. 基于资源加载的进度条

```javascript
class ResourceLoadingProgressBar extends LoadingProgressBar {
  constructor(options = {}) {
    super(options);
    this.resources = [];
    this.loadedResources = 0;
    this.totalResources = 0;
  }

  // 监听资源加载
  monitorResources() {
    // 监听图片加载
    this.monitorImages();
    
    // 监听脚本加载
    this.monitorScripts();
    
    // 监听样式表加载
    this.monitorStylesheets();
  }

  // 监听图片加载
  monitorImages() {
    const images = document.querySelectorAll('img');
    this.totalResources += images.length;
    
    images.forEach(img => {
      if (img.complete) {
        this.resourceLoaded();
      } else {
        img.addEventListener('load', () => this.resourceLoaded());
        img.addEventListener('error', () => this.resourceLoaded());
      }
    });
  }

  // 监听脚本加载
  monitorScripts() {
    const scripts = document.querySelectorAll('script[src]');
    this.totalResources += scripts.length;
    
    scripts.forEach(script => {
      if (script.readyState === 'complete' || script.readyState === 'loaded') {
        this.resourceLoaded();
      } else {
        script.addEventListener('load', () => this.resourceLoaded());
        script.addEventListener('error', () => this.resourceLoaded());
      }
    });
  }

  // 监听样式表加载
  monitorStylesheets() {
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    this.totalResources += links.length;
    
    links.forEach(link => {
      if (link.readyState === 'complete' || link.sheet) {
        this.resourceLoaded();
      } else {
        link.addEventListener('load', () => this.resourceLoaded());
        link.addEventListener('error', () => this.resourceLoaded());
      }
    });
  }

  // 资源加载完成
  resourceLoaded() {
    this.loadedResources++;
    const progress = (this.loadedResources / this.totalResources) * 100;
    this.setProgress(progress);
  }

  // 开始监控资源加载
  startMonitoring() {
    this.reset();
    this.monitorResources();
  }
}

// 使用示例
const resourceProgressBar = new ResourceLoadingProgressBar({
  color: '#FF5722',
  height: '4px'
});

// 页面加载完成后开始监控资源
window.addEventListener('DOMContentLoaded', () => {
  resourceProgressBar.startMonitoring();
});
```

### 3. 基于 Fetch 请求的进度条

```javascript
class FetchProgressBar extends LoadingProgressBar {
  constructor(options = {}) {
    super(options);
    this.activeRequests = 0;
    this.setupInterceptors();
  }

  // 设置请求拦截器
  setupInterceptors() {
    // 保存原始的 fetch 方法
    const originalFetch = window.fetch;
    
    // 重写 fetch 方法
    window.fetch = (input, init) => {
      this.activeRequests++;
      this.updateProgress();
      
      // 返回原始 fetch 的 Promise
      return originalFetch(input, init)
        .then(response => {
          this.activeRequests--;
          this.updateProgress();
          return response;
        })
        .catch(error => {
          this.activeRequests--;
          this.updateProgress();
          throw error;
        });
    };
  }

  // 更新进度
  updateProgress() {
    if (this.activeRequests > 0) {
      // 使用模拟进度，因为无法准确知道请求完成百分比
      this.simulateLoading();
    } else {
      this.complete();
    }
  }

  // 模拟加载进度（重写父类方法）
  simulateLoading() {
    if (this.isAnimating) return;
    
    this.isAnimating = true;
    let progress = this.currentProgress;
    
    const simulate = () => {
      if (progress < 95 && this.activeRequests > 0) {
        progress += Math.random() * 8;
        this.setProgress(Math.min(95, progress));
        setTimeout(simulate, 150 + Math.random() * 100);
      } else if (this.activeRequests === 0) {
        this.setProgress(100);
      }
    };
    
    simulate();
  }
}

// 使用示例
const fetchProgressBar = new FetchProgressBar({
  color: '#9C27B0',
  height: '3px'
});
```

### 4. React 中的进度条组件

```jsx
import React, { useState, useEffect } from 'react';

const ProgressBar = ({ progress, color = '#29d', height = '2px', show = true }) => {
  if (!show) return null;
  
  return (
    <div 
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: height,
        backgroundColor: '#f0f0f0',
        zIndex: 9999,
      }}
    >
      <div
        style={{
          width: `${progress}%`,
          height: '100%',
          backgroundColor: color,
          transition: 'width 0.2s ease',
          boxShadow: '0 0 10px rgba(41, 133, 221, 0.5)',
        }}
      />
    </div>
  );
};

// 使用 React Hook 的进度条管理器
const useLoadingProgress = () => {
  const [progress, setProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const startLoading = () => {
    setIsLoading(true);
    setProgress(0);
    
    // 模拟加载进度
    let currentProgress = 0;
    const simulate = () => {
      if (currentProgress < 90 && isLoading) {
        currentProgress += Math.random() * 15;
        setProgress(Math.min(90, currentProgress));
        setTimeout(simulate, 100 + Math.random() * 200);
      }
    };
    
    simulate();
  };

  const completeLoading = () => {
    setProgress(100);
    setTimeout(() => {
      setIsLoading(false);
    }, 300);
  };

  return { progress, isLoading, startLoading, completeLoading };
};

// 完整的 React 组件示例
const AppWithProgressBar = () => {
  const { progress, isLoading, startLoading, completeLoading } = useLoadingProgress();

  // 模拟页面加载
  useEffect(() => {
    startLoading();
    
    // 模拟数据加载完成
    const timer = setTimeout(() => {
      completeLoading();
    }, 2000);
    
    return () => clearTimeout(timer);
  }, []);

  return (
    <div>
      <ProgressBar progress={progress} show={isLoading} />
      <div>页面内容...</div>
    </div>
  );
};
```

### 5. 使用第三方库 NProgress.js

```html
<!DOCTYPE html>
<html>
<head>
  <title>NProgress Example</title>
  <link rel="stylesheet" href="https://unpkg.com/nprogress@0.2.0/nprogress.css">
</head>
<body>
  <script src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
  
  <script>
    // 配置 NProgress
    NProgress.configure({ 
      showSpinner: false, // 隐藏右上角的加载小图标
      easing: 'ease',     // 动画方式
      speed: 500,         // 递增进度条的速度
      minimum: 0.1        // 初始化时的最小百分比
    });

    // 页面加载开始
    NProgress.start();

    // 模拟页面加载完成
    setTimeout(() => {
      NProgress.done();
    }, 2000);

    // 监听路由变化（在单页应用中）
    function simulateRouteChange() {
      NProgress.start();
      setTimeout(() => {
        NProgress.done();
      }, 1000);
    }
  </script>
</body>
</html>
```

## 实际应用场景

### 1. 单页应用路由加载

在 React Router 或 Vue Router 中，当路由切换时显示进度条，提升用户体验。

### 2. API 请求加载

在发送 API 请求时显示进度条，让用户知道请求正在进行中。

### 3. 文件上传/下载

在文件上传或下载过程中显示精确的进度条。

### 4. 大型资源加载

在加载大型图片、视频或其他资源时显示进度。

## 注意事项

1. **性能影响**：进度条的更新不应影响页面性能，避免过于频繁的 DOM 操作
2. **用户体验**：进度条应该提供真实的进度反馈，避免误导用户
3. **兼容性**：考虑不同浏览器的兼容性，特别是旧版浏览器
4. **可访问性**：为屏幕阅读器用户提供适当的进度信息
5. **视觉设计**：进度条的颜色和样式应与整体设计风格保持一致
6. **错误处理**：当加载失败时，应有相应的错误处理机制

## 总结

网页加载进度条是提升用户体验的重要组件。实现方式多种多样，从简单的 JavaScript 实现到使用第三方库。选择合适的实现方式需要考虑应用的具体需求、性能要求和用户体验目标。无论采用哪种方式，都应该确保进度条能够准确反映加载状态，为用户提供良好的反馈。
