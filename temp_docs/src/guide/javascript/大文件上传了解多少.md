# 大文件上传了解多少？（了解）

**题目**: 大文件上传了解多少？（了解）

**答案**:

大文件上传是前端开发中经常遇到的场景，由于文件体积大，直接上传容易导致超时、内存溢出等问题。以下是大文件上传的常见解决方案：

## 1. 文件切片上传（分块上传）

将大文件切分成多个小块，分别上传，最后在服务端合并：

```javascript
// 文件切片函数
function sliceFile(file, chunkSize = 2 * 1024 * 1024) { // 默认2MB每片
  const chunks = [];
  let start = 0;
  
  while (start < file.size) {
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    chunks.push({
      blob: chunk,
      index: start / chunkSize,
      start: start,
      end: end
    });
    start = end;
  }
  
  return chunks;
}

// 上传切片
async function uploadChunks(file, chunkSize = 2 * 1024 * 1024) {
  const chunks = sliceFile(file, chunkSize);
  const uploadId = generateUploadId(); // 生成上传ID
  const uploadPromises = [];
  
  for (let i = 0; i < chunks.length; i++) {
    const formData = new FormData();
    formData.append('chunk', chunks[i].blob);
    formData.append('uploadId', uploadId);
    formData.append('chunkIndex', i);
    formData.append('totalChunks', chunks.length);
    formData.append('fileName', file.name);
    formData.append('fileSize', file.size);
    
    // 并发上传所有切片
    const uploadPromise = fetch('/upload-chunk', {
      method: 'POST',
      body: formData
    });
    uploadPromises.push(uploadPromise);
  }
  
  // 等待所有切片上传完成
  await Promise.all(uploadPromises);
  
  // 发送合并请求
  await fetch('/merge-chunks', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      uploadId: uploadId,
      fileName: file.name,
      totalChunks: chunks.length
    })
  });
}
```

## 2. 断点续传

在切片上传的基础上，记录已上传的切片，避免重复上传：

```javascript
class ResumableUpload {
  constructor(file, options = {}) {
    this.file = file;
    this.chunkSize = options.chunkSize || 2 * 1024 * 1024;
    this.uploadId = options.uploadId || this.generateUploadId();
    this.uploadedChunks = new Set(); // 已上传的切片索引
    this.chunks = this.sliceFile();
  }
  
  sliceFile() {
    const chunks = [];
    let start = 0;
    
    while (start < this.file.size) {
      const end = Math.min(start + this.chunkSize, this.file.size);
      const chunk = this.file.slice(start, end);
      chunks.push({
        blob: chunk,
        index: start / this.chunkSize,
        start: start,
        end: end
      });
      start = end;
    }
    
    return chunks;
  }
  
  async checkUploadedChunks() {
    try {
      const response = await fetch(`/check-chunks?uploadId=${this.uploadId}`);
      const result = await response.json();
      this.uploadedChunks = new Set(result.uploadedChunks);
    } catch (error) {
      console.error('检查已上传切片失败:', error);
    }
  }
  
  async upload() {
    await this.checkUploadedChunks();
    
    const uploadPromises = [];
    
    for (let i = 0; i < this.chunks.length; i++) {
      // 跳过已上传的切片
      if (this.uploadedChunks.has(i)) {
        continue;
      }
      
      const formData = new FormData();
      formData.append('chunk', this.chunks[i].blob);
      formData.append('uploadId', this.uploadId);
      formData.append('chunkIndex', i);
      formData.append('totalChunks', this.chunks.length);
      formData.append('fileName', this.file.name);
      
      const uploadPromise = this.uploadChunk(formData, i);
      uploadPromises.push(uploadPromise);
    }
    
    await Promise.all(uploadPromises);
    
    // 合并文件
    await this.mergeChunks();
  }
  
  async uploadChunk(formData, index) {
    try {
      const response = await fetch('/upload-chunk', {
        method: 'POST',
        body: formData
      });
      
      if (response.ok) {
        this.uploadedChunks.add(index);
        this.onProgress && this.onProgress(this.getUploadProgress());
      }
    } catch (error) {
      // 上传失败，可以重试
      throw error;
    }
  }
  
  async mergeChunks() {
    await fetch('/merge-chunks', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        uploadId: this.uploadId,
        fileName: this.file.name,
        totalChunks: this.chunks.length
      })
    });
  }
  
  getUploadProgress() {
    return (this.uploadedChunks.size / this.chunks.length) * 100;
  }
  
  generateUploadId() {
    return `${this.file.name}-${this.file.size}-${Date.now()}`;
  }
}

// 使用示例
const fileInput = document.getElementById('fileInput');
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  const uploader = new ResumableUpload(file);
  
  uploader.onProgress = (progress) => {
    console.log(`上传进度: ${progress.toFixed(2)}%`);
  };
  
  try {
    await uploader.upload();
    console.log('文件上传完成');
  } catch (error) {
    console.error('上传失败:', error);
  }
});
```

## 3. 上传进度监控

实时显示上传进度：

```javascript
function uploadWithProgress(file, onProgress) {
  return new Promise((resolve, reject) => {
    const formData = new FormData();
    formData.append('file', file);
    
    const xhr = new XMLHttpRequest();
    
    // 上传进度
    xhr.upload.onprogress = (event) => {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        onProgress && onProgress(percentComplete);
      }
    };
    
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`上传失败: ${xhr.status}`));
      }
    };
    
    xhr.onerror = () => {
      reject(new Error('网络错误'));
    };
    
    xhr.open('POST', '/upload');
    xhr.send(formData);
  });
}
```

## 4. 服务端配合

服务端需要支持分块接收和合并：

```javascript
// Node.js 示例
const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');

const app = express();
const upload = multer({ dest: 'uploads/' });

// 存储临时切片的目录
const chunkDir = './chunks';

// 上传切片
app.post('/upload-chunk', upload.single('chunk'), async (req, res) => {
  const { uploadId, chunkIndex, fileName } = req.body;
  const chunkPath = path.join(chunkDir, `${uploadId}_${chunkIndex}`);
  
  // 保存切片
  fs.renameSync(req.file.path, chunkPath);
  
  res.json({ success: true });
});

// 合并切片
app.post('/merge-chunks', async (req, res) => {
  const { uploadId, fileName, totalChunks } = req.body;
  const targetPath = path.join('./uploads', fileName);
  const writeStream = fs.createWriteStream(targetPath);
  
  try {
    for (let i = 0; i < totalChunks; i++) {
      const chunkPath = path.join(chunkDir, `${uploadId}_${i}`);
      const chunkData = fs.readFileSync(chunkPath);
      writeStream.write(chunkData);
      
      // 删除临时切片
      fs.unlinkSync(chunkPath);
    }
    
    writeStream.end();
    
    res.json({ success: true, message: '文件合并完成' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 检查已上传的切片
app.get('/check-chunks', async (req, res) => {
  const { uploadId } = req.query;
  const uploadedChunks = [];
  
  for (let i = 0; ; i++) {
    const chunkPath = path.join(chunkDir, `${uploadId}_${i}`);
    if (fs.existsSync(chunkPath)) {
      uploadedChunks.push(i);
    } else {
      break;
    }
  }
  
  res.json({ uploadedChunks });
});
```

## 5. 前端优化

- 使用 Web Workers 处理文件切片，避免阻塞主线程
- 实现上传暂停/恢复功能
- 文件秒传（通过文件哈希判断是否已存在）

```javascript
// 使用 Web Worker 处理文件切片
function createSliceWorker() {
  const workerCode = `
    self.onmessage = function(e) {
      const { file, chunkSize } = e.data;
      const chunks = [];
      let start = 0;
      
      while (start < file.size) {
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);
        chunks.push({
          blob: chunk,
          index: start / chunkSize,
          start: start,
          end: end
        });
        start = end;
      }
      
      self.postMessage(chunks);
    };
  `;
  
  const blob = new Blob([workerCode], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

// 使用 Worker
function sliceFileWithWorker(file, chunkSize) {
  return new Promise((resolve) => {
    const worker = createSliceWorker();
    
    worker.postMessage({ file, chunkSize });
    worker.onmessage = (e) => {
      resolve(e.data);
      worker.terminate();
    };
  });
}
```

## 总结

大文件上传的核心是分而治之的思想，将大文件切分成小块上传，可以有效解决：
- 上传超时问题
- 服务器内存压力
- 网络中断后需要重新上传的问题
- 用户体验（可显示进度、暂停/恢复）

在实际项目中，可以使用现成的库如 `simple-uploader.js` 或 `tus` 来实现大文件上传功能。
