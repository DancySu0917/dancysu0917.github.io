# 如何区分数组和对象？（必会）

**题目**: 如何区分数组和对象？（必会）

**答案**:

在 JavaScript 中，数组和普通对象在使用 `typeof` 操作符时都会返回 "object"，因此需要使用其他方法来区分它们。以下是几种常用的方法：

### 1. Array.isArray() 方法（推荐）

ES5 引入的 `Array.isArray()` 是最可靠和推荐的方法：

```javascript
console.log(Array.isArray([]));           // true
console.log(Array.isArray([1, 2, 3]));   // true
console.log(Array.isArray({}));           // false
console.log(Array.isArray({0: 'a', 1: 'b', length: 2})); // false
console.log(Array.isArray("array"));      // false
console.log(Array.isArray(null));         // false
console.log(Array.isArray(undefined));    // false

// 自定义函数实现
function isArray(value) {
    return Array.isArray(value);
}
```

### 2. Object.prototype.toString.call() 方法

这是最准确的方法，利用了每个对象的内部 [[Class]] 属性：

```javascript
function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
}

console.log(isArray([]));           // true
console.log(isArray([1, 2, 3]));   // true
console.log(isArray({}));           // false
console.log(isArray({0: 'a', 1: 'b', length: 2})); // false

// 这种方法还可以区分其他类型
function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType([]));           // "Array"
console.log(getType({}));           // "Object"
console.log(getType(new Date()));   // "Date"
console.log(getType(/regex/));      // "RegExp"
```

### 3. instanceof 操作符

通过检查对象的原型链来判断：

```javascript
console.log([] instanceof Array);           // true
console.log([1, 2, 3] instanceof Array);   // true
console.log({} instanceof Array);           // false
console.log({0: 'a', 1: 'b', length: 2} instanceof Array); // false

// 注意：instanceof 在跨框架时可能失效
// 如果数组来自不同的全局环境，instanceof 可能返回 false
```

### 4. constructor 属性检查

检查对象的 constructor 属性：

```javascript
console.log([].constructor === Array);           // true
console.log([1, 2, 3].constructor === Array);   // true
console.log({}.constructor === Array);           // false

// 注意：constructor 可能被修改，不够可靠
let arr = [];
arr.constructor = String;
console.log(arr.constructor === Array);          // false (被修改后不准确)
```

### 5. 特定数组方法检查

检查对象是否具有数组特有的方法：

```javascript
function isArrayLike(value) {
    // 检查是否有数组特有方法
    return typeof value.push === 'function' && 
           typeof value.pop === 'function' &&
           typeof value.slice === 'function' &&
           typeof value.splice === 'function';
}

// 更精确的检查
function isArray(value) {
    return Array.isArray ? Array.isArray(value) : 
           Object.prototype.toString.call(value) === '[object Array]';
}
```

### 6. 检查特定属性

利用数组和对象的一些固有差异：

```javascript
function isArray(value) {
    // 检查是否为对象且有 length 属性且 length 是数字
    if (typeof value === 'object' && typeof value.length === 'number') {
        // 进一步检查是否为数组
        return value.length === 0 || 
               (value.length > 0 && (value.length - 1) in value);
    }
    return false;
}

// 但这种方法并不完全可靠，因为类数组对象也有这些特征
```

### 7. 综合判断函数

```javascript
function identifyType(value) {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    
    // 检查基本类型
    if (typeof value !== 'object') {
        return typeof value;
    }
    
    // 区分数组和对象
    if (Array.isArray(value)) {
        return 'array';
    } else {
        return 'object';
    }
}

// 测试
console.log(identifyType([]));           // "array"
console.log(identifyType([1, 2, 3]));   // "array"
console.log(identifyType({}));           // "object"
console.log(identifyType({a: 1, b: 2})); // "object"
console.log(identifyType("string"));     // "string"
console.log(identifyType(123));          // "number"
```

### 8. 实际应用示例

```javascript
// 数据处理函数，根据类型进行不同处理
function processData(data) {
    if (Array.isArray(data)) {
        console.log('处理数组数据:', data);
        return data.map(item => item * 2);
    } else if (typeof data === 'object' && data !== null) {
        console.log('处理对象数据:', data);
        return Object.keys(data).reduce((result, key) => {
            result[key] = data[key] + '_processed';
            return result;
        }, {});
    } else {
        console.log('处理基本类型数据:', data);
        return data;
    }
}

// 测试
console.log(processData([1, 2, 3]));           // [2, 4, 6]
console.log(processData({a: 1, b: 2}));        // {a: "1_processed", b: "2_processed"}

// 类数组对象的处理
function handleArrayLike(obj) {
    if (Array.isArray(obj)) {
        return obj.filter(item => item > 0);
    } else {
        // 如果是类数组对象，转换为真正的数组再处理
        return Array.prototype.slice.call(obj).filter(item => item > 0);
    }
}
```

### 9. 各方法对比

| 方法 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| Array.isArray() | 最可靠、标准方法 | 需要 ES5+ 支持 | ⭐⭐⭐⭐⭐ |
| toString.call() | 兼容性好、准确 | 代码稍长 | ⭐⭐⭐⭐⭐ |
| instanceof | 直观易懂 | 跨框架失效 | ⭐⭐ |
| constructor | 简单直接 | 可被修改，不可靠 | ⭐ |

### 10. 最佳实践

```javascript
// 推荐的数组检测函数
function isArray(value) {
    // 优先使用原生方法
    if (Array.isArray) {
        return Array.isArray(value);
    }
    // 降级使用 toString 方法
    return Object.prototype.toString.call(value) === '[object Array]';
}

// 使用示例
const data = [[1, 2], {a: 1}, [3, 4, 5], "string"];

data.forEach(item => {
    if (isArray(item)) {
        console.log('数组:', item);
    } else {
        console.log('非数组:', item);
    }
});
```

在实际开发中，优先推荐使用 `Array.isArray()` 方法，因为它是最标准、最可靠的方法。如果需要兼容旧环境，可以使用 `Object.prototype.toString.call()` 方法作为备选方案。
