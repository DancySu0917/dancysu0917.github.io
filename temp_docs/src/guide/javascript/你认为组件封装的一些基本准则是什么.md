# 你认为组件封装的一些基本准则是什么（了解）

**题目**: 你认为组件封装的一些基本准则是什么（了解）

## 标准答案

组件封装的基本准则包括：
1. 单一职责原则：一个组件只负责一个功能点
2. 开放封闭原则：对扩展开放，对修改封闭
3. 接口清晰：Props定义明确，API简洁易用
4. 状态管理：合理管理组件内部状态和外部状态
5. 可复用性：设计通用组件，避免过度定制
6. 可维护性：代码结构清晰，易于理解和修改
7. 可测试性：便于进行单元测试和集成测试

## 深入理解

组件封装是前端开发中的核心技能，良好的组件封装能够提高开发效率、降低维护成本、提升代码质量。组件封装的核心目标是实现高内聚、低耦合的代码结构。

单一职责原则确保每个组件只关注一个特定功能，这样组件更容易理解、测试和复用。开放封闭原则意味着组件应该允许在不修改源码的情况下进行功能扩展，通常通过插槽、高阶组件等方式实现。

接口设计是组件封装的关键，清晰的Props定义和事件系统能够让组件更易用。同时，组件应该合理区分内部状态和外部状态，避免状态管理混乱。

## 代码示例

```javascript
// 1. 单一职责原则示例 - 按钮组件
// Bad: 职责过多的组件
const BadButton = ({ type, onClick, loading, disabled, size, theme, icon, text, validate, onValidate }) => {
  // 这个组件既要处理按钮逻辑，又要处理验证逻辑
  if (validate && !onValidate()) return null;
  
  return (
    <button 
      className={`${type}-${size} ${theme} ${loading ? 'loading' : ''}`} 
      onClick={onClick}
      disabled={disabled || loading}
    >
      {icon && <Icon type={icon} />}
      {text}
    </button>
  );
};

// Good: 单一职责的按钮组件
const Button = ({ 
  type = 'default', 
  onClick, 
  loading = false, 
  disabled = false, 
  size = 'medium', 
  icon, 
  children,
  className = '',
  ...rest 
}) => {
  const btnClass = `btn btn-${type} btn-${size} ${loading ? 'btn-loading' : ''} ${className}`;
  
  return (
    <button 
      className={btnClass}
      onClick={onClick}
      disabled={disabled || loading}
      {...rest}
    >
      {loading && <span className="loading-spinner" />}
      {icon && <span className="btn-icon">{icon}</span>}
      <span className="btn-text">{children}</span>
    </button>
  );
};

// 验证功能单独封装
const ValidationWrapper = ({ validate, onValidate, children }) => {
  const [isValid, setIsValid] = useState(true);
  
  useEffect(() => {
    setIsValid(onValidate());
  }, [validate]);
  
  return isValid ? children : null;
};

// 2. 开放封闭原则示例 - 列表组件
const List = ({ 
  items = [], 
  renderItem, 
  itemKey = 'id',
  className = '',
  emptyText = '暂无数据',
  loading = false,
  onLoadMore,
  hasMore = false
}) => {
  if (loading && items.length === 0) {
    return <div className="list-loading">加载中...</div>;
  }
  
  if (items.length === 0) {
    return <div className="list-empty">{emptyText}</div>;
  }
  
  return (
    <div className={`list ${className}`}>
      <ul className="list-items">
        {items.map((item, index) => (
          <li key={item[itemKey] || index} className="list-item">
            {renderItem ? renderItem(item, index) : item}
          </li>
        ))}
      </ul>
      
      {hasMore && (
        <div className="list-load-more">
          <button onClick={onLoadMore}>加载更多</button>
        </div>
      )}
    </div>
  );
};

// 使用示例：扩展列表组件功能
const UserList = ({ users, onUserClick }) => (
  <List
    items={users}
    renderItem={(user, index) => (
      <div className="user-item" onClick={() => onUserClick(user)}>
        <img src={user.avatar} alt={user.name} />
        <div className="user-info">
          <h4>{user.name}</h4>
          <p>{user.email}</p>
        </div>
      </div>
    )}
    itemKey="id"
    emptyText="暂无用户数据"
  />
);

// 3. 插槽模式示例 - 模态框组件
const Modal = ({ 
  visible = false, 
  onClose, 
  title, 
  footer, 
  children,
  maskClosable = true,
  width = 520
}) => {
  if (!visible) return null;
  
  const handleMaskClick = (e) => {
    if (maskClosable && e.target === e.currentTarget) {
      onClose();
    }
  };
  
  return (
    <div className="modal-mask" onClick={handleMaskClick}>
      <div className="modal-wrapper" style={{ width }}>
        <div className="modal-header">
          <h3 className="modal-title">{title}</h3>
          <button className="modal-close" onClick={onClose}>×</button>
        </div>
        <div className="modal-body">
          {children}
        </div>
        {footer && (
          <div className="modal-footer">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
};

// 4. 高阶组件示例 - 添加加载状态
const withLoading = (WrappedComponent) => {
  return ({ loading, ...props }) => {
    if (loading) {
      return <div className="component-loading">加载中...</div>;
    }
    
    return <WrappedComponent {...props} />;
  };
};

const EnhancedButton = withLoading(Button);

// 5. React Hooks 封装可复用逻辑
// 自定义 Hook: 表单验证
const useFormValidation = (initialValues, validationRules) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const validate = useCallback(() => {
    const newErrors = {};
    
    Object.keys(validationRules).forEach(field => {
      const rule = validationRules[field];
      const value = values[field];
      
      if (rule.required && (!value || value.trim() === '')) {
        newErrors[field] = rule.requiredMessage || `${field} 是必填项`;
      } else if (rule.pattern && !rule.pattern.test(value)) {
        newErrors[field] = rule.patternMessage || `${field} 格式不正确`;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [values, validationRules]);
  
  const handleChange = useCallback((field, value) => {
    setValues(prev => ({
      ...prev,
      [field]: value
    }));
    
    // 实时清除错误
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  }, [errors]);
  
  const handleSubmit = useCallback(async (onSubmit) => {
    if (validate()) {
      setIsSubmitting(true);
      try {
        await onSubmit(values);
      } finally {
        setIsSubmitting(false);
      }
    }
  }, [validate, values]);
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit
  };
};

// 使用表单验证 Hook 的组件
const UserForm = ({ onSubmit }) => {
  const validationConfig = {
    username: {
      required: true,
      requiredMessage: '用户名不能为空',
      pattern: /^[a-zA-Z0-9_]{3,16}$/,
      patternMessage: '用户名必须是3-16位字母、数字或下划线'
    },
    email: {
      required: true,
      requiredMessage: '邮箱不能为空',
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      patternMessage: '邮箱格式不正确'
    }
  };
  
  const { values, errors, handleChange, handleSubmit } = useFormValidation(
    { username: '', email: '' },
    validationConfig
  );
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit(onSubmit);
    }}>
      <div className="form-field">
        <input
          type="text"
          placeholder="用户名"
          value={values.username}
          onChange={(e) => handleChange('username', e.target.value)}
        />
        {errors.username && <span className="error">{errors.username}</span>}
      </div>
      
      <div className="form-field">
        <input
          type="email"
          placeholder="邮箱"
          value={values.email}
          onChange={(e) => handleChange('email', e.target.value)}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <button type="submit">提交</button>
    </form>
  );
};
```

## 实践场景

1. **UI组件库开发**：在开发组件库时，遵循这些准则能够确保组件的通用性和可维护性，如Ant Design、Element UI等。

2. **业务组件封装**：在项目中封装业务组件时，通过合理的职责划分和接口设计，可以提高代码复用率和开发效率。

3. **可访问性支持**：良好的组件封装应该考虑可访问性，为组件添加适当的ARIA属性和键盘导航支持。

4. **国际化支持**：组件应该设计为支持多语言，通过Props传入国际化文本或使用上下文提供翻译函数。

5. **性能优化**：通过合理的状态管理和渲染优化，确保组件在大数据量或频繁更新场景下的性能表现。

在实际开发中，组件封装是一个持续优化的过程，需要根据具体业务场景和用户反馈不断调整和改进组件设计。
