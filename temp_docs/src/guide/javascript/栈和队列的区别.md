# 栈和队列的区别？（了解）

**题目**: 栈和队列的区别？（了解）

## 标准答案

栈（Stack）和队列（Queue）是两种基本的数据结构，主要区别在于数据的存取方式：

- **栈**：后进先出（LIFO - Last In First Out），只能在栈顶进行插入和删除操作
- **队列**：先进先出（FIFO - First In First Out），在队尾插入元素，在队头删除元素

## 深入理解

### 1. 栈（Stack）

栈是一种后进先出（LIFO）的数据结构，只允许在一端（栈顶）进行插入和删除操作。

#### 栈的基本操作：
- **push()**: 将元素压入栈顶
- **pop()**: 弹出栈顶元素
- **peek()/top()**: 查看栈顶元素但不删除
- **isEmpty()**: 检查栈是否为空

```javascript
// 栈的实现
class Stack {
    constructor() {
        this.items = [];
    }
    
    // 入栈
    push(element) {
        this.items.push(element);
    }
    
    // 出栈
    pop() {
        if (this.isEmpty()) {
            throw new Error('栈为空');
        }
        return this.items.pop();
    }
    
    // 查看栈顶元素
    peek() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[this.items.length - 1];
    }
    
    // 检查栈是否为空
    isEmpty() {
        return this.items.length === 0;
    }
    
    // 获取栈的大小
    size() {
        return this.items.length;
    }
    
    // 清空栈
    clear() {
        this.items = [];
    }
    
    // 打印栈内容
    print() {
        console.log(this.items.toString());
    }
}

// 栈的使用示例
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.peek()); // 3
console.log(stack.pop());  // 3
console.log(stack.size()); // 2
```

#### 栈在JavaScript中的应用：
```javascript
// 1. 函数调用栈
function functionA() {
    console.log('函数A执行');
    functionB();
}

function functionB() {
    console.log('函数B执行');
    functionC();
}

function functionC() {
    console.log('函数C执行');
    // 当前调用栈：functionC -> functionB -> functionA -> main
}

functionA();

// 2. 括号匹配验证
function isValidParentheses(s) {
    const stack = new Stack();
    const map = {
        ')': '(',
        '}': '{',
        ']': '['
    };
    
    for (let char of s) {
        if (['(', '{', '['].includes(char)) {
            stack.push(char);
        } else if ([')', '}', ']'].includes(char)) {
            if (stack.isEmpty() || stack.pop() !== map[char]) {
                return false;
            }
        }
    }
    
    return stack.isEmpty();
}

console.log(isValidParentheses('()[]{}')); // true
console.log(isValidParentheses('([{}])')); // true
console.log(isValidParentheses('([)]'));   // false

// 3. 表达式求值
function evaluateExpression(expression) {
    const values = new Stack();  // 存储数值
    const ops = new Stack();     // 存储操作符
    
    for (let i = 0; i < expression.length; i++) {
        const char = expression[i];
        
        if (char === ' ') continue;
        
        if (!isNaN(parseInt(char))) {
            let num = 0;
            while (i < expression.length && !isNaN(parseInt(expression[i]))) {
                num = num * 10 + parseInt(expression[i]);
                i++;
            }
            i--; // 回退一位
            values.push(num);
        } else if (char === '(') {
            ops.push(char);
        } else if (char === ')') {
            while (ops.peek() !== '(') {
                const val2 = values.pop();
                const val1 = values.pop();
                const op = ops.pop();
                values.push(applyOp(val1, val2, op));
            }
            ops.pop(); // 移除 '('
        } else if (['+', '-', '*', '/'].includes(char)) {
            while (!ops.isEmpty() && hasPrecedence(char, ops.peek())) {
                const val2 = values.pop();
                const val1 = values.pop();
                const op = ops.pop();
                values.push(applyOp(val1, val2, op));
            }
            ops.push(char);
        }
    }
    
    while (!ops.isEmpty()) {
        const val2 = values.pop();
        const val1 = values.pop();
        const op = ops.pop();
        values.push(applyOp(val1, val2, op));
    }
    
    return values.pop();
}

function applyOp(a, b, op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return Math.floor(a / b);
    }
}

function hasPrecedence(op1, op2) {
    if (op2 === '(' || op2 === ')') return false;
    if ((op1 === '*' || op1 === '/') && (op2 === '+' || op2 === '-')) return false;
    return true;
}
```

### 2. 队列（Queue）

队列是一种先进先出（FIFO）的数据结构，在队尾插入元素，在队头删除元素。

#### 队列的基本操作：
- **enqueue()**: 在队尾添加元素
- **dequeue()**: 从队头移除元素
- **front()**: 查看队头元素但不删除
- **isEmpty()**: 检查队列是否为空
- **size()**: 获取队列大小

```javascript
// 队列的实现
class Queue {
    constructor() {
        this.items = [];
    }
    
    // 入队
    enqueue(element) {
        this.items.push(element);
    }
    
    // 出队
    dequeue() {
        if (this.isEmpty()) {
            throw new Error('队列为空');
        }
        return this.items.shift();
    }
    
    // 查看队头元素
    front() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0];
    }
    
    // 检查队列是否为空
    isEmpty() {
        return this.items.length === 0;
    }
    
    // 获取队列大小
    size() {
        return this.items.length;
    }
    
    // 清空队列
    clear() {
        this.items = [];
    }
    
    // 打印队列内容
    print() {
        console.log(this.items.toString());
    }
}

// 队列的使用示例
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
console.log(queue.front());  // 1
console.log(queue.dequeue()); // 1
console.log(queue.size());   // 2
```

#### 队列在JavaScript中的应用：
```javascript
// 1. 任务队列实现
class TaskQueue {
    constructor() {
        this.queue = new Queue();
        this.isProcessing = false;
    }
    
    addTask(task) {
        this.queue.enqueue(task);
        if (!this.isProcessing) {
            this.processTasks();
        }
    }
    
    async processTasks() {
        this.isProcessing = true;
        
        while (!this.queue.isEmpty()) {
            const task = this.queue.dequeue();
            try {
                await task();
            } catch (error) {
                console.error('任务执行错误:', error);
            }
        }
        
        this.isProcessing = false;
    }
}

// 2. 广度优先搜索（BFS）
function bfs(graph, startNode) {
    const queue = new Queue();
    const visited = new Set();
    const result = [];
    
    queue.enqueue(startNode);
    visited.add(startNode);
    
    while (!queue.isEmpty()) {
        const currentNode = queue.dequeue();
        result.push(currentNode);
        
        // 遍历当前节点的邻居
        const neighbors = graph[currentNode] || [];
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.enqueue(neighbor);
            }
        }
    }
    
    return result;
}

// 示例图结构
const graph = {
    A: ['B', 'C'],
    B: ['D', 'E'],
    C: ['F'],
    D: [],
    E: ['F'],
    F: []
};

console.log(bfs(graph, 'A')); // ['A', 'B', 'C', 'D', 'E', 'F']

// 3. 滑动窗口最大值
function maxSlidingWindow(nums, k) {
    if (nums.length === 0) return [];
    
    const deque = []; // 双端队列，存储索引
    const result = [];
    
    for (let i = 0; i < nums.length; i++) {
        // 移除超出窗口的元素索引
        while (deque.length > 0 && deque[0] <= i - k) {
            deque.shift();
        }
        
        // 移除所有小于当前元素的索引
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        deque.push(i);
        
        // 当窗口大小达到k时，记录最大值
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
}

console.log(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3)); // [3, 3, 5, 5, 6, 7]
```

### 3. 栈和队列的对比

| 特性 | 栈（Stack） | 队列（Queue） |
|------|-------------|---------------|
| 存取方式 | 后进先出（LIFO） | 先进先出（FIFO） |
| 操作端 | 只在栈顶操作 | 在两端操作（队头出队，队尾入队） |
| 主要操作 | push, pop, peek | enqueue, dequeue, front |
| 应用场景 | 函数调用、表达式求值、括号匹配 | 任务调度、广度优先搜索、缓冲区 |
| 时间复杂度 | 所有操作O(1) | enqueue: O(1), dequeue: O(n) - 使用数组实现 |

### 4. 实际应用场景

#### 栈的应用场景：
```javascript
// 1. 浏览器历史记录（前进后退功能）
class BrowserHistory {
    constructor() {
        this.historyStack = new Stack();
        this.forwardStack = new Stack();
    }
    
    visit(url) {
        this.historyStack.push(url);
        this.forwardStack.clear(); // 清空前进栈
        console.log(`访问: ${url}`);
    }
    
    back() {
        if (this.historyStack.size() > 1) {
            const current = this.historyStack.pop();
            this.forwardStack.push(current);
            const previous = this.historyStack.peek();
            console.log(`后退到: ${previous}`);
            return previous;
        }
        console.log('无法后退');
        return null;
    }
    
    forward() {
        if (!this.forwardStack.isEmpty()) {
            const url = this.forwardStack.pop();
            this.historyStack.push(url);
            console.log(`前进到: ${url}`);
            return url;
        }
        console.log('无法前进');
        return null;
    }
}

// 2. 撤销/重做功能
class TextEditor {
    constructor() {
        this.content = '';
        this.undoStack = new Stack();
        this.redoStack = new Stack();
    }
    
    insert(text) {
        this.undoStack.push(this.content);
        this.content += text;
        this.redoStack.clear(); // 清空重做栈
        console.log(`插入: ${text}, 当前内容: ${this.content}`);
    }
    
    undo() {
        if (!this.undoStack.isEmpty()) {
            this.redoStack.push(this.content);
            this.content = this.undoStack.pop();
            console.log(`撤销后内容: ${this.content}`);
            return this.content;
        }
        console.log('无法撤销');
        return this.content;
    }
    
    redo() {
        if (!this.redoStack.isEmpty()) {
            this.undoStack.push(this.content);
            this.content = this.redoStack.pop();
            console.log(`重做后内容: ${this.content}`);
            return this.content;
        }
        console.log('无法重做');
        return this.content;
    }
}
```

#### 队列的应用场景：
```javascript
// 1. 打印任务队列
class PrintQueue {
    constructor() {
        this.queue = new Queue();
    }
    
    addDocument(document) {
        this.queue.enqueue(document);
        console.log(`文档已添加到打印队列: ${document}`);
    }
    
    printNext() {
        if (!this.queue.isEmpty()) {
            const document = this.queue.dequeue();
            console.log(`正在打印: ${document}`);
            return document;
        }
        console.log('打印队列为空');
        return null;
    }
    
    getQueueSize() {
        return this.queue.size();
    }
}

// 2. 消息队列
class MessageQueue {
    constructor() {
        this.queue = new Queue();
    }
    
    sendMessage(message) {
        this.queue.enqueue(message);
        console.log(`消息已发送: ${message}`);
    }
    
    consumeMessage() {
        if (!this.queue.isEmpty()) {
            const message = this.queue.dequeue();
            console.log(`消息已消费: ${message}`);
            return message;
        }
        console.log('消息队列为空');
        return null;
    }
    
    getPendingMessages() {
        return this.queue.size();
    }
}
```

## 总结

栈和队列是两种重要的数据结构，各有特点和应用场景：

1. **栈**：后进先出，适用于需要回溯操作的场景，如函数调用、表达式求值、撤销功能等
2. **队列**：先进先出，适用于需要按顺序处理的场景，如任务调度、广度优先搜索、消息处理等
3. 两种数据结构的时间复杂度都是O(1)，但在JavaScript中使用数组实现队列时，dequeue操作为O(n)
4. 在实际开发中，要根据具体需求选择合适的数据结构，有时也需要结合使用
