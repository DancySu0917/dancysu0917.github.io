# 实现一个深拷贝？其它具体方法？（高薪常问）

**题目**: 实现一个深拷贝？其它具体方法？（高薪常问）

## 标准答案

深拷贝是创建一个新对象，其属性和嵌套对象都是全新的副本，与原对象完全独立。实现深拷贝需要处理循环引用、各种数据类型、函数、Symbol、日期、正则表达式等特殊情况。常用方法包括递归遍历、JSON序列化（有局限性）、使用WeakMap处理循环引用等。

## 详细解析

### 1. 深拷贝 vs 浅拷贝
- **浅拷贝**: 只复制对象的第一层属性，嵌套对象仍为引用
- **深拷贝**: 递归复制对象的所有层级，创建完全独立的副本

### 2. 深拷贝实现难点
- **循环引用**: 对象属性引用自身或形成引用环
- **特殊对象类型**: Date、RegExp、Array、Map、Set等
- **函数处理**: 函数通常不需要深拷贝
- **Symbol键**: 需要处理Symbol作为对象键的情况
- **不可枚举属性**: 需要复制所有属性

### 3. 常见实现方法
- **JSON方法**: JSON.parse(JSON.stringify(obj)) - 有局限性
- **递归遍历**: 手动实现递归拷贝
- **现代API**: structuredClone() - 现代浏览器支持

### 4. 性能考虑
- **时间复杂度**: O(n)，需要遍历所有属性
- **空间复杂度**: O(n)，需要创建新对象
- **循环引用处理**: 使用WeakMap避免无限递归

## 代码实现

### 1. 基础深拷贝实现

```javascript
// 基础深拷贝实现
function deepClone(obj) {
    // 处理 null 和 undefined
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 处理日期对象
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    // 处理正则表达式
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    // 处理数组
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }
    
    // 处理普通对象
    const clonedObj = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            clonedObj[key] = deepClone(obj[key]);
        }
    }
    
    return clonedObj;
}

// 测试基础深拷贝
const original = {
    name: 'John',
    age: 30,
    hobbies: ['reading', 'swimming'],
    address: {
        city: 'New York',
        zip: '10001'
    },
    date: new Date(),
    regex: /test/gi
};

const cloned = deepClone(original);
console.log('原对象:', original);
console.log('克隆对象:', cloned);
console.log('是否为同一对象:', original === cloned); // false
console.log('嵌套对象是否独立:', original.address === cloned.address); // false
```

### 2. 支持循环引用的深拷贝

```javascript
// 支持循环引用的深拷贝实现
function deepCloneWithCircular(obj, hash = new WeakMap()) {
    // 处理 null 和 undefined
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 检查循环引用
    if (hash.has(obj)) {
        return hash.get(obj);
    }
    
    // 处理日期对象
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    // 处理正则表达式
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    // 处理数组
    if (Array.isArray(obj)) {
        const clonedArray = [];
        hash.set(obj, clonedArray);
        for (let i = 0; i < obj.length; i++) {
            clonedArray[i] = deepCloneWithCircular(obj[i], hash);
        }
        return clonedArray;
    }
    
    // 处理 Set
    if (obj instanceof Set) {
        const clonedSet = new Set();
        hash.set(obj, clonedSet);
        for (const item of obj) {
            clonedSet.add(deepCloneWithCircular(item, hash));
        }
        return clonedSet;
    }
    
    // 处理 Map
    if (obj instanceof Map) {
        const clonedMap = new Map();
        hash.set(obj, clonedMap);
        for (const [key, value] of obj) {
            const clonedKey = deepCloneWithCircular(key, hash);
            const clonedValue = deepCloneWithCircular(value, hash);
            clonedMap.set(clonedKey, clonedValue);
        }
        return clonedMap;
    }
    
    // 处理普通对象
    const clonedObj = {};
    hash.set(obj, clonedObj);
    
    // 复制所有自有属性（包括Symbol键）
    const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
    for (const key of keys) {
        clonedObj[key] = deepCloneWithCircular(obj[key], hash);
    }
    
    return clonedObj;
}

// 测试循环引用
const circularObj = {
    name: 'Circular',
    value: 100
};
circularObj.self = circularObj; // 创建循环引用

const clonedCircular = deepCloneWithCircular(circularObj);
console.log('原对象:', circularObj);
console.log('克隆对象:', clonedCircular);
console.log('循环引用是否正确:', clonedCircular.self === clonedCircular); // true
console.log('是否为同一对象:', circularObj === clonedCircular); // false
```

### 3. 完整的深拷贝实现（处理所有情况）

```javascript
// 完整的深拷贝实现
function completeDeepClone(obj, hash = new WeakMap()) {
    // 基础类型直接返回
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 检查循环引用
    if (hash.has(obj)) {
        return hash.get(obj);
    }
    
    // 获取对象构造函数
    const constructor = obj.constructor;
    
    // 处理特殊对象类型
    if (constructor === Date) {
        return new Date(obj);
    }
    
    if (constructor === RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    if (constructor === Set) {
        const clonedSet = new Set();
        hash.set(obj, clonedSet);
        obj.forEach(value => clonedSet.add(completeDeepClone(value, hash)));
        return clonedSet;
    }
    
    if (constructor === Map) {
        const clonedMap = new Map();
        hash.set(obj, clonedMap);
        obj.forEach((value, key) => {
            clonedMap.set(completeDeepClone(key, hash), completeDeepClone(value, hash));
        });
        return clonedMap;
    }
    
    if (constructor === Array) {
        const clonedArray = new Array(obj.length);
        hash.set(obj, clonedArray);
        for (let i = 0; i < obj.length; i++) {
            clonedArray[i] = completeDeepClone(obj[i], hash);
        }
        return clonedArray;
    }
    
    // 处理普通对象和自定义构造函数
    const clonedObj = Object.create(Object.getPrototypeOf(obj));
    hash.set(obj, clonedObj);
    
    // 复制所有可枚举属性
    for (const key of Reflect.ownKeys(obj)) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.value !== undefined) {
            descriptor.value = completeDeepClone(descriptor.value, hash);
        }
        Object.defineProperty(clonedObj, key, descriptor);
    }
    
    return clonedObj;
}

// 测试完整实现
const complexObj = {
    name: 'Complex',
    date: new Date(),
    regex: /test/gi,
    array: [1, 2, { nested: 'value' }],
    set: new Set([1, 2, 3]),
    map: new Map([['key1', 'value1'], ['key2', { nested: true }]]),
    func: function() { return 'hello'; }
};

// 创建循环引用
complexObj.self = complexObj;
complexObj.array.push(complexObj);

const clonedComplex = completeDeepClone(complexObj);
console.log('复杂对象深拷贝完成');
console.log('是否为同一对象:', complexObj === clonedComplex); // false
console.log('循环引用处理:', clonedComplex.self === clonedComplex); // true
console.log('数组循环引用:', clonedComplex.array.includes(clonedComplex)); // true
```

### 4. 使用现代API的深拷贝

```javascript
// 使用现代浏览器的 structuredClone API
function modernDeepClone(obj) {
    // 检查浏览器是否支持 structuredClone
    if (typeof structuredClone !== 'undefined') {
        try {
            return structuredClone(obj);
        } catch (error) {
            console.warn('structuredClone failed, falling back to manual implementation:', error);
            // 如果 structuredClone 失败，回退到手动实现
            return completeDeepClone(obj);
        }
    } else {
        // 如果不支持，使用手动实现
        return completeDeepClone(obj);
    }
}

// 性能测试函数
function performanceTest() {
    const largeObj = {
        data: Array.from({ length: 10000 }, (_, i) => ({
            id: i,
            name: `Item ${i}`,
            nested: { value: Math.random(), deep: { level: i % 3 } }
        }))
    };
    
    // 测试手动实现性能
    console.time('Manual Deep Clone');
    const cloned1 = completeDeepClone(largeObj);
    console.timeEnd('Manual Deep Clone');
    
    // 测试现代API性能（如果支持）
    if (typeof structuredClone !== 'undefined') {
        console.time('Structured Clone');
        const cloned2 = structuredClone(largeObj);
        console.timeEnd('Structured Clone');
    }
}

// performanceTest(); // 取消注释来运行性能测试
```

### 5. 深拷贝工具类

```javascript
// 深拷贝工具类
class DeepCopyUtil {
    constructor() {
        this.cache = new WeakMap();
    }
    
    // 主要深拷贝方法
    clone(obj) {
        this.cache.clear(); // 每次克隆前清空缓存
        return this._clone(obj);
    }
    
    _clone(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        
        // 检查循环引用
        if (this.cache.has(obj)) {
            return this.cache.get(obj);
        }
        
        const constructor = obj.constructor;
        
        // 特殊类型处理
        if (constructor === Date) {
            return new Date(obj);
        }
        
        if (constructor === RegExp) {
            return new RegExp(obj.source, obj.flags);
        }
        
        if (constructor === Set) {
            const clonedSet = new Set();
            this.cache.set(obj, clonedSet);
            obj.forEach(value => clonedSet.add(this._clone(value)));
            return clonedSet;
        }
        
        if (constructor === Map) {
            const clonedMap = new Map();
            this.cache.set(obj, clonedMap);
            obj.forEach((value, key) => {
                clonedMap.set(this._clone(key), this._clone(value));
            });
            return clonedMap;
        }
        
        if (constructor === Array) {
            const clonedArray = new Array(obj.length);
            this.cache.set(obj, clonedArray);
            for (let i = 0; i < obj.length; i++) {
                clonedArray[i] = this._clone(obj[i]);
            }
            return clonedArray;
        }
        
        // 普通对象处理
        const clonedObj = Object.create(Object.getPrototypeOf(obj));
        this.cache.set(obj, clonedObj);
        
        // 复制所有自有属性
        for (const key of Reflect.ownKeys(obj)) {
            const descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor.value !== undefined) {
                descriptor.value = this._clone(descriptor.value);
            }
            Object.defineProperty(clonedObj, key, descriptor);
        }
        
        return clonedObj;
    }
    
    // 安全克隆（带错误处理）
    safeClone(obj) {
        try {
            return this.clone(obj);
        } catch (error) {
            console.error('Deep clone failed:', error);
            return null;
        }
    }
    
    // 克隆并验证
    cloneWithValidation(obj) {
        const cloned = this.clone(obj);
        const isValid = this.validateClone(obj, cloned);
        return { cloned, isValid };
    }
    
    validateClone(original, cloned) {
        // 简单验证：检查是否为不同对象
        if (original === cloned) {
            return false;
        }
        
        // 检查基本结构
        if (Array.isArray(original) !== Array.isArray(cloned)) {
            return false;
        }
        
        if (original instanceof Date !== cloned instanceof Date) {
            return false;
        }
        
        if (original instanceof RegExp !== cloned instanceof RegExp) {
            return false;
        }
        
        return true;
    }
}

// 使用工具类
const util = new DeepCopyUtil();

const testObj = {
    name: 'Test',
    data: [1, 2, { nested: 'value' }],
    date: new Date(),
    regex: /test/g
};

testObj.self = testObj; // 循环引用

const result = util.cloneWithValidation(testObj);
console.log('克隆是否成功:', result.isValid);
console.log('原对象:', testObj);
console.log('克隆对象:', result.cloned);
```

### 6. 实际应用示例

```javascript
// 实际应用：状态管理中的深拷贝
class StateManager {
    constructor(initialState = {}) {
        this.state = completeDeepClone(initialState);
        this.listeners = [];
    }
    
    getState() {
        return this.state;
    }
    
    setState(newState) {
        // 使用深拷贝确保状态独立性
        this.state = completeDeepClone(newState);
        this.notifyListeners();
    }
    
    updateState(updater) {
        // 深拷贝当前状态，应用更新，然后设置新状态
        const newState = completeDeepClone(this.state);
        updater(newState);
        this.state = newState;
        this.notifyListeners();
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
    }
    
    notifyListeners() {
        this.listeners.forEach(listener => listener(this.state));
    }
}

// 使用状态管理器
const stateManager = new StateManager({
    user: { name: 'Alice', preferences: { theme: 'dark' } },
    items: [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }]
});

stateManager.subscribe((newState) => {
    console.log('State updated:', newState);
});

// 更新状态
stateManager.updateState(state => {
    state.user.preferences.language = 'en';
    state.items.push({ id: 3, name: 'Item 3' });
});

console.log('Current state:', stateManager.getState());
```

## 实际应用场景

1. **状态管理**: Redux、Vuex 等状态管理库中需要不可变数据结构。
2. **数据缓存**: 避免修改原始数据，保持数据完整性。
3. **配置对象**: 克隆默认配置并进行个性化修改。
4. **表单数据**: 克隆初始表单值以支持重置功能。
5. **数据传输**: 在不同组件或模块间传递数据副本。
6. **历史记录**: 保存对象状态的历史版本。

## 面试要点

1. **概念理解**: 明确深拷贝和浅拷贝的区别。
2. **实现方法**: 掌握多种深拷贝实现方式。
3. **边界情况**: 处理循环引用、特殊对象类型等。
4. **性能考虑**: 理解深拷贝的时间和空间复杂度。
5. **现代API**: 了解 structuredClone 等现代浏览器API。
6. **实际应用**: 能够在实际项目中正确使用深拷贝。
7. **局限性**: 了解各种实现方法的局限性。

深拷贝是前端开发中的重要概念，掌握其原理和实现方法对于编写高质量代码至关重要。
