# 如何做好前端监控方案？（了解）

**题目**: 如何做好前端监控方案？（了解）

## 标准答案

前端监控方案需要建立完整的监控体系，包括：错误监控（JavaScript错误、资源加载错误、Promise错误等）、性能监控（页面加载性能、运行时性能、API性能等）、业务监控（用户行为、转化率、功能使用情况等）、用户体验监控（FID、FCP、LCP等核心Web指标）。核心是建立数据收集、上报、分析、告警的完整链路，实现问题快速发现、定位和解决。

## 详细解析

### 1. 监控体系架构

前端监控需要建立分层的监控体系：
- **错误监控层**：捕获各种类型的错误
- **性能监控层**：监控页面性能指标
- **业务监控层**：监控业务相关指标
- **用户行为层**：监控用户操作行为

### 2. 错误监控

**JavaScript 错误监控：**
- 使用 `window.onerror` 捕获运行时错误
- 使用 `window.addEventListener('error')` 捕获资源加载错误
- 使用 `unhandledrejection` 事件捕获未处理的 Promise 错误

**错误分类：**
- 代码错误（语法错误、运行时错误）
- 资源加载错误（图片、CSS、JS 加载失败）
- 网络错误（API 请求失败）
- 业务逻辑错误

### 3. 性能监控

**核心 Web 指标：**
- FCP（First Contentful Paint）首次内容绘制
- LCP（Largest Contentful Paint）最大内容绘制
- FID（First Input Delay）首次输入延迟
- CLS（Cumulative Layout Shift）累积布局偏移
- FCP（First CPU Idle）首次 CPU 空闲

**性能指标：**
- 页面加载时间
- 首屏渲染时间
- 资源加载时间
- API 响应时间

### 4. 数据上报策略

**上报时机：**
- 页面卸载时（使用 `sendBeacon` API）
- 错误发生时立即上报
- 定期批量上报性能数据
- 用户操作行为触发上报

**上报方式：**
- XMLHttpRequest
- Fetch API
- sendBeacon API（推荐，确保页面卸载时数据也能发送）

## 代码示例

### 1. 基础错误监控

```javascript
// 错误监控类
class ErrorMonitor {
    constructor(options = {}) {
        this.options = {
            apiUrl: options.apiUrl || '/api/errors',
            enableConsole: options.enableConsole || false,
            sampleRate: options.sampleRate || 1, // 采样率 0-1
            ...options
        };
        
        this.init();
    }
    
    init() {
        // 捕获 JavaScript 运行时错误
        this.setupGlobalErrorHandler();
        
        // 捕获资源加载错误
        this.setupResourceErrorHandler();
        
        // 捕获未处理的 Promise 错误
        this.setupUnhandledRejectionHandler();
        
        // 捕获 Vue 错误（如果使用 Vue）
        this.setupVueErrorHandler();
        
        // 捕获 React 错误（如果使用 React）
        this.setupReactErrorHandler();
    }
    
    setupGlobalErrorHandler() {
        window.onerror = (message, source, lineno, colno, error) => {
            this.reportError({
                type: 'javascript',
                message,
                source,
                lineno,
                colno,
                stack: error ? error.stack : null,
                url: window.location.href,
                timestamp: Date.now()
            });
            
            // 不阻止默认的错误处理
            return false;
        };
    }
    
    setupResourceErrorHandler() {
        window.addEventListener('error', (event) => {
            // 过滤 JavaScript 错误，只处理资源加载错误
            if (event.target !== window) {
                const target = event.target;
                if (target !== window && target.localName) {
                    this.reportError({
                        type: 'resource',
                        resourceType: target.localName,
                        src: target.src || target.href,
                        url: window.location.href,
                        timestamp: Date.now()
                    });
                }
            }
        }, true);
    }
    
    setupUnhandledRejectionHandler() {
        window.addEventListener('unhandledrejection', (event) => {
            this.reportError({
                type: 'promise',
                message: event.reason ? event.reason.message || event.reason.toString() : 'Promise rejected',
                stack: event.reason && event.reason.stack ? event.reason.stack : null,
                url: window.location.href,
                timestamp: Date.now()
            });
        });
    }
    
    setupVueErrorHandler() {
        if (window.Vue) {
            Vue.config.errorHandler = (err, vm, info) => {
                this.reportError({
                    type: 'vue',
                    message: err.message,
                    stack: err.stack,
                    info,
                    component: vm ? vm.$options.name || vm.$options._componentTag : 'unknown',
                    url: window.location.href,
                    timestamp: Date.now()
                });
            };
        }
    }
    
    setupReactErrorHandler() {
        // React 错误边界需要在组件层面实现
        // 这里提供全局错误处理的思路
        if (window.addEventListener) {
            window.addEventListener('react-error', (event) => {
                this.reportError({
                    type: 'react',
                    message: event.detail.message,
                    stack: event.detail.stack,
                    component: event.detail.component,
                    url: window.location.href,
                    timestamp: Date.now()
                });
            });
        }
    }
    
    reportError(errorInfo) {
        // 采样率控制
        if (Math.random() > this.options.sampleRate) {
            return;
        }
        
        // 添加额外信息
        errorInfo.userAgent = navigator.userAgent;
        errorInfo.timestamp = Date.now();
        errorInfo.url = window.location.href;
        errorInfo.referrer = document.referrer;
        errorInfo.screenResolution = `${screen.width}x${screen.height}`;
        errorInfo.viewportSize = `${window.innerWidth}x${window.innerHeight}`;
        
        // 发送错误报告
        this.sendErrorReport(errorInfo);
        
        // 控制台输出（可选）
        if (this.options.enableConsole) {
            console.error('Error reported:', errorInfo);
        }
    }
    
    sendErrorReport(errorInfo) {
        // 使用 sendBeacon 确保即使在页面卸载时也能发送数据
        if (navigator.sendBeacon) {
            try {
                navigator.sendBeacon(
                    this.options.apiUrl,
                    JSON.stringify(errorInfo)
                );
            } catch (e) {
                // 如果 sendBeacon 失败，使用 fetch
                this.fallbackSend(errorInfo);
            }
        } else {
            this.fallbackSend(errorInfo);
        }
    }
    
    fallbackSend(errorInfo) {
        // 使用 fetch 作为备选方案
        fetch(this.options.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(errorInfo),
            keepalive: true // 确保请求在页面卸载后也能完成
        }).catch(err => {
            console.error('Failed to send error report:', err);
        });
    }
}

// 初始化错误监控
const errorMonitor = new ErrorMonitor({
    apiUrl: '/api/errors',
    sampleRate: 0.8, // 80% 采样率
    enableConsole: false
});
```

### 2. 性能监控

```javascript
// 性能监控类
class PerformanceMonitor {
    constructor(options = {}) {
        this.options = {
            apiUrl: options.apiUrl || '/api/performance',
            reportInterval: options.reportInterval || 30000, // 30秒上报一次
            enableNavigation: options.enableNavigation || true,
            enablePaint: options.enablePaint || true,
            enableResource: options.enableResource || true,
            enableLCP: options.enableLCP || true,
            enableFID: options.enableFID || true,
            enableCLS: options.enableCLS || true,
            ...options
        };
        
        this.clsValue = 0;
        this.clsEntries = [];
        this.fidValue = 0;
        this.fidEntries = [];
        
        this.init();
    }
    
    init() {
        // 监控页面加载性能
        if (this.options.enableNavigation) {
            this.monitorNavigation();
        }
        
        // 监控绘制性能
        if (this.options.enablePaint) {
            this.monitorPaint();
        }
        
        // 监控资源加载性能
        if (this.options.enableResource) {
            this.monitorResource();
        }
        
        // 监控核心 Web 指标
        if (this.options.enableLCP) {
            this.monitorLCP();
        }
        
        if (this.options.enableFID) {
            this.monitorFID();
        }
        
        if (this.options.enableCLS) {
            this.monitorCLS();
        }
        
        // 定期上报性能数据
        this.startReporting();
    }
    
    monitorNavigation() {
        // 页面加载性能监控
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
            const navigationMetrics = {
                // DNS 查询时间
                dnsTime: navigation.domainLookupEnd - navigation.domainLookupStart,
                // TCP 连接时间
                tcpTime: navigation.connectEnd - navigation.connectStart,
                // 请求响应时间
                responseTime: navigation.responseEnd - navigation.responseStart,
                // DOM 解析时间
                domParseTime: navigation.domContentLoadedEventEnd - navigation.domLoading,
                // 页面完全加载时间
                loadCompleteTime: navigation.loadEventEnd - navigation.loadEventStart,
                // 首次渲染时间
                firstPaintTime: navigation.responseStart - navigation.fetchStart,
                // 页面加载总时间
                pageLoadTime: navigation.loadEventEnd - navigation.fetchStart
            };
            
            this.navigationMetrics = navigationMetrics;
        }
    }
    
    monitorPaint() {
        // 监控绘制指标
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.name === 'first-paint') {
                    this.fpTime = entry.startTime;
                } else if (entry.name === 'first-contentful-paint') {
                    this.fcpTime = entry.startTime;
                }
            }
        });
        
        observer.observe({ entryTypes: ['paint'] });
    }
    
    monitorResource() {
        // 监控资源加载性能
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                const resourceMetrics = {
                    name: entry.name,
                    duration: entry.duration,
                    size: entry.transferSize,
                    type: entry.entryType,
                    startTime: entry.startTime
                };
                
                // 只记录耗时超过 100ms 的资源
                if (entry.duration > 100) {
                    this.reportResourceSlow(resourceMetrics);
                }
            }
        });
        
        observer.observe({ entryTypes: ['resource'] });
    }
    
    monitorLCP() {
        // 监控最大内容绘制 (LCP)
        new PerformanceObserver((list) => {
            const entries = list.getEntries();
            const lastEntry = entries[entries.length - 1];
            
            this.lcpValue = lastEntry.startTime;
            this.lcpEntry = lastEntry;
        }).observe({ entryTypes: ['largest-contentful-paint'] });
    }
    
    monitorFID() {
        // 监控首次输入延迟 (FID)
        new PerformanceObserver((list) => {
            const firstInput = list.getEntries()[0];
            if (firstInput) {
                this.fidValue = firstInput.processingStart - firstInput.startTime;
                this.fidEntries.push(firstInput);
            }
        }).observe({ entryTypes: ['first-input'] });
    }
    
    monitorCLS() {
        // 监控累积布局偏移 (CLS)
        let clsValue = 0;
        let clsEntries = [];
        
        new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (!entry.hadRecentInput) {
                    const firstSessionEntry = clsEntries[0];
                    const lastSessionEntry = clsEntries[clsEntries.length - 1];
                    
                    if (clsValue === 0) {
                        firstSessionEntry = entry;
                    }
                    
                    clsValue += entry.value;
                    clsEntries.push(entry);
                    
                    // 如果当前会话超过 1 秒，或者距离上一个布局偏移超过 5 秒，则开始新会话
                    if (entry.startTime - lastSessionEntry.startTime > 1000 ||
                        entry.startTime - lastSessionEntry.startTime > 5000) {
                        clsValue = entry.value;
                        clsEntries = [entry];
                    }
                    
                    this.clsValue = clsValue;
                    this.clsEntries = clsEntries;
                }
            }
        }).observe({ entryTypes: ['layout-shift'] });
    }
    
    getCoreWebVitals() {
        return {
            FCP: this.fcpTime || null,
            LCP: this.lcpValue || null,
            FID: this.fidValue || null,
            CLS: this.clsValue || null
        };
    }
    
    getPerformanceData() {
        const data = {
            timestamp: Date.now(),
            url: window.location.href,
            userAgent: navigator.userAgent,
            coreWebVitals: this.getCoreWebVitals(),
            navigation: this.navigationMetrics || null,
            paint: {
                FP: this.fpTime || null,
                FCP: this.fcpTime || null
            }
        };
        
        return data;
    }
    
    startReporting() {
        // 定期上报性能数据
        setInterval(() => {
            const performanceData = this.getPerformanceData();
            this.sendPerformanceReport(performanceData);
        }, this.options.reportInterval);
        
        // 页面卸载时上报最终数据
        window.addEventListener('beforeunload', () => {
            const performanceData = this.getPerformanceData();
            this.sendPerformanceReport(performanceData);
        });
    }
    
    sendPerformanceReport(performanceData) {
        if (navigator.sendBeacon) {
            try {
                navigator.sendBeacon(
                    this.options.apiUrl,
                    JSON.stringify(performanceData)
                );
            } catch (e) {
                // 备选方案
                fetch(this.options.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(performanceData)
                }).catch(err => {
                    console.error('Performance report failed:', err);
                });
            }
        }
    }
    
    reportResourceSlow(resourceMetrics) {
        // 上报慢资源
        const slowResourceData = {
            type: 'slow_resource',
            ...resourceMetrics,
            timestamp: Date.now(),
            url: window.location.href
        };
        
        fetch(this.options.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(slowResourceData)
        }).catch(err => {
            console.error('Slow resource report failed:', err);
        });
    }
}

// 初始化性能监控
const performanceMonitor = new PerformanceMonitor({
    apiUrl: '/api/performance',
    reportInterval: 30000
});
```

### 3. 用户行为监控

```javascript
// 用户行为监控类
class BehaviorMonitor {
    constructor(options = {}) {
        this.options = {
            apiUrl: options.apiUrl || '/api/behavior',
            reportBatchSize: options.reportBatchSize || 10,
            reportInterval: options.reportInterval || 5000,
            enableClick: options.enableClick || true,
            enableScroll: options.enableScroll || true,
            enableInput: options.enableInput || true,
            enablePageView: options.enablePageView || true,
            ...options
        };
        
        this.eventQueue = [];
        this.pageStartTime = Date.now();
        
        this.init();
    }
    
    init() {
        // 监控页面访问
        if (this.options.enablePageView) {
            this.monitorPageView();
        }
        
        // 监控点击事件
        if (this.options.enableClick) {
            this.monitorClicks();
        }
        
        // 监控滚动事件
        if (this.options.enableScroll) {
            this.monitorScroll();
        }
        
        // 监控输入事件
        if (this.options.enableInput) {
            this.monitorInput();
        }
        
        // 监控路由变化（适用于单页应用）
        this.monitorRouteChange();
        
        // 启动批量上报
        this.startBatchReporting();
    }
    
    monitorPageView() {
        // 页面访问事件
        const pageViewEvent = {
            type: 'page_view',
            url: window.location.href,
            referrer: document.referrer,
            title: document.title,
            timestamp: Date.now(),
            loadTime: Date.now() - this.pageStartTime
        };
        
        this.addEventToQueue(pageViewEvent);
    }
    
    monitorClicks() {
        document.addEventListener('click', (event) => {
            const clickEvent = {
                type: 'click',
                target: event.target.tagName,
                targetId: event.target.id || null,
                targetClass: event.target.className || null,
                targetText: event.target.textContent?.substring(0, 50) || null,
                x: event.clientX,
                y: event.clientY,
                url: window.location.href,
                timestamp: Date.now()
            };
            
            this.addEventToQueue(clickEvent);
        });
    }
    
    monitorScroll() {
        let scrollTimer = null;
        
        window.addEventListener('scroll', () => {
            // 防抖处理
            if (scrollTimer) {
                clearTimeout(scrollTimer);
            }
            
            scrollTimer = setTimeout(() => {
                const scrollEvent = {
                    type: 'scroll',
                    scrollTop: window.pageYOffset,
                    scrollLeft: window.pageXOffset,
                    scrollHeight: document.documentElement.scrollHeight,
                    clientHeight: document.documentElement.clientHeight,
                    url: window.location.href,
                    timestamp: Date.now()
                };
                
                this.addEventToQueue(scrollEvent);
            }, 100);
        });
    }
    
    monitorInput() {
        // 监控输入事件（可选，注意隐私）
        document.addEventListener('input', (event) => {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                const inputEvent = {
                    type: 'input',
                    target: event.target.tagName,
                    targetId: event.target.id || null,
                    targetType: event.target.type || null,
                    url: window.location.href,
                    timestamp: Date.now()
                };
                
                this.addEventToQueue(inputEvent);
            }
        });
    }
    
    monitorRouteChange() {
        // 监控单页应用路由变化
        const originalPushState = history.pushState;
        const originalReplaceState = history.replaceState;
        
        history.pushState = (...args) => {
            originalPushState.apply(history, args);
            this.handleRouteChange();
        };
        
        history.replaceState = (...args) => {
            originalReplaceState.apply(history, args);
            this.handleRouteChange();
        };
        
        window.addEventListener('popstate', () => {
            this.handleRouteChange();
        });
    }
    
    handleRouteChange() {
        const routeChangeEvent = {
            type: 'route_change',
            from: document.referrer,
            to: window.location.href,
            timestamp: Date.now()
        };
        
        this.addEventToQueue(routeChangeEvent);
    }
    
    addEventToQueue(event) {
        this.eventQueue.push(event);
        
        // 如果队列达到批量大小，立即上报
        if (this.eventQueue.length >= this.options.reportBatchSize) {
            this.flushEvents();
        }
    }
    
    flushEvents() {
        if (this.eventQueue.length === 0) return;
        
        const events = this.eventQueue.splice(0, this.eventQueue.length);
        this.sendEvents(events);
    }
    
    sendEvents(events) {
        fetch(this.options.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ events })
        }).catch(err => {
            console.error('Behavior events report failed:', err);
            // 失败时可以考虑本地缓存，后续重试
        });
    }
    
    startBatchReporting() {
        // 定期上报事件
        setInterval(() => {
            this.flushEvents();
        }, this.options.reportInterval);
        
        // 页面卸载时上报剩余事件
        window.addEventListener('beforeunload', () => {
            this.flushEvents();
        });
    }
}

// 初始化用户行为监控
const behaviorMonitor = new BehaviorMonitor({
    apiUrl: '/api/behavior',
    reportBatchSize: 5,
    reportInterval: 3000
});
```

### 4. 综合监控方案

```javascript
// 综合监控方案
class FrontendMonitor {
    constructor(options = {}) {
        this.options = {
            appId: options.appId || 'default-app',
            appVersion: options.appVersion || '1.0.0',
            environment: options.environment || 'production',
            enableError: options.enableError !== false,
            enablePerformance: options.enablePerformance !== false,
            enableBehavior: options.enableBehavior !== false,
            ...options
        };
        
        this.init();
    }
    
    init() {
        // 初始化各监控模块
        if (this.options.enableError) {
            this.errorMonitor = new ErrorMonitor({
                apiUrl: `${this.options.apiBase || '/api'}/errors`,
                sampleRate: this.options.errorSampleRate || 1
            });
        }
        
        if (this.options.enablePerformance) {
            this.performanceMonitor = new PerformanceMonitor({
                apiUrl: `${this.options.apiBase || '/api'}/performance`,
                reportInterval: this.options.performanceReportInterval || 30000
            });
        }
        
        if (this.options.enableBehavior) {
            this.behaviorMonitor = new BehaviorMonitor({
                apiUrl: `${this.options.apiBase || '/api'}/behavior`,
                reportInterval: this.options.behaviorReportInterval || 5000
            });
        }
        
        // 发送初始化事件
        this.sendInitEvent();
    }
    
    sendInitEvent() {
        const initEvent = {
            type: 'app_init',
            appId: this.options.appId,
            appVersion: this.options.appVersion,
            environment: this.options.environment,
            userAgent: navigator.userAgent,
            timestamp: Date.now(),
            url: window.location.href
        };
        
        fetch(`${this.options.apiBase || '/api'}/events`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(initEvent)
        }).catch(err => {
            console.error('Init event failed:', err);
        });
    }
    
    // 手动上报自定义事件
    trackEvent(eventName, properties = {}) {
        const customEvent = {
            type: 'custom',
            name: eventName,
            properties,
            appId: this.options.appId,
            url: window.location.href,
            timestamp: Date.now()
        };
        
        fetch(`${this.options.apiBase || '/api'}/events`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(customEvent)
        }).catch(err => {
            console.error('Custom event failed:', err);
        });
    }
    
    // 性能标记
    mark(name) {
        if (performance.mark) {
            performance.mark(name);
        }
    }
    
    // 测量性能
    measure(name, startMark, endMark) {
        if (performance.measure) {
            performance.measure(name, startMark, endMark);
            
            // 获取测量结果并上报
            const measure = performance.getEntriesByName(name)[0];
            if (measure) {
                this.trackEvent('performance_measure', {
                    name: measure.name,
                    duration: measure.duration
                });
            }
        }
    }
}

// 使用示例
const monitor = new FrontendMonitor({
    appId: 'my-web-app',
    appVersion: '1.2.0',
    environment: 'production',
    apiBase: 'https://monitoring-api.example.com'
});

// 在关键业务流程中手动埋点
monitor.trackEvent('user_login', { userId: '12345' });
monitor.trackEvent('purchase_completed', { amount: 99.99, productId: 'P001' });

// 性能测量示例
monitor.mark('api_start');
fetch('/api/data')
    .then(response => response.json())
    .then(data => {
        monitor.mark('api_end');
        monitor.measure('api_duration', 'api_start', 'api_end');
    });
```

## 实际应用场景

### 1. 电商网站
监控用户购买流程中的性能和错误，及时发现影响转化率的问题。

### 2. SaaS 应用
监控核心功能的使用情况和性能表现，优化用户体验。

### 3. 新闻门户
监控页面加载速度和内容渲染情况，确保用户能快速获取信息。

### 4. 在线教育平台
监控视频播放性能和用户学习行为，优化教学体验。

## 注意事项

1. **性能影响**：监控代码本身不应显著影响页面性能
2. **隐私保护**：遵守隐私法规，不收集敏感用户信息
3. **数据采样**：对大规模应用使用采样策略，避免数据过载
4. **上报频率**：合理设置上报频率，平衡实时性和性能
5. **错误处理**：监控系统自身也需要错误处理和容错机制
6. **数据存储**：考虑监控数据的存储成本和生命周期管理

一个完善的前端监控方案是保障应用稳定性和用户体验的重要手段，需要根据具体业务场景进行定制化设计。
