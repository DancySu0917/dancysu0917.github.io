# 如何实现一个真正防抖的防抖函数，考虑取消功能和立即执行选项？（高薪常问）

**题目**: 如何实现一个真正防抖的防抖函数，考虑取消功能和立即执行选项？（高薪常问）

**答案**:

防抖（debounce）是一种重要的函数优化技术，用于限制函数在特定时间间隔内的执行次数。在前端开发中，我们经常在搜索框输入、窗口调整大小、滚动事件等场景中使用防抖。

## 核心概念

防抖的基本原理是：当函数被频繁调用时，只有当最后一次调用后经过指定时间间隔没有再次调用，函数才会执行。

## 完整实现

```javascript
function debounce(func, wait, options = {}) {
  let timeoutId = null;
  let lastCallTime = 0;
  let lastInvokeTime = 0;
  
  // 从选项中获取配置
  const { leading = false, trailing = true, maxWait = undefined } = options;
  
  // 清除定时器的辅助函数
  const clearTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  
  // 立即执行函数
  const invokeFunc = (...args) => {
    lastInvokeTime = Date.now();
    return func.apply(this, args);
  };
  
  // 执行函数的逻辑
  const trailingEdge = (...args) => {
    clearTimer();
    if (trailing && lastCallTime !== 0) {
      return invokeFunc.apply(this, args);
    }
    return undefined;
  };
  
  // 防抖后的函数
  const debounced = function(...args) {
    const currentTime = Date.now();
    lastCallTime = currentTime;
    
    // 是否应该立即执行（leading edge）
    const shouldInvokeImmediate = leading && timeoutId === null;
    
    // 如果设置了最大等待时间
    if (maxWait !== undefined) {
      // 计算剩余等待时间
      const timeSinceLastInvoke = currentTime - lastInvokeTime;
      const timeSinceLastCall = currentTime - lastCallTime;
      const isMaxWaitElapsed = timeSinceLastInvoke >= maxWait;
      
      if (isMaxWaitElapsed) {
        // 如果超过最大等待时间，立即执行
        clearTimer();
        lastInvokeTime = currentTime;
        return invokeFunc.apply(this, args);
      } else if (timeSinceLastCall >= wait && !shouldInvokeImmediate) {
        // 如果超过等待时间且不是立即执行模式，设置定时器
        timeoutId = setTimeout(() => trailingEdge.apply(this, args), wait);
      } else if (!shouldInvokeImmediate) {
        // 否则，重新设置定时器
        timeoutId = setTimeout(() => trailingEdge.apply(this, args), wait);
      }
    } else {
      // 没有设置最大等待时间的普通情况
      if (timeoutId === null) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          if (trailing) {
            invokeFunc.apply(this, args);
          }
        }, wait);
      }
    }
    
    // 如果是立即执行模式
    if (shouldInvokeImmediate) {
      lastInvokeTime = currentTime;
      return invokeFunc.apply(this, args);
    }
    
    return undefined;
  };
  
  // 取消函数 - 清除定时器并重置状态
  debounced.cancel = function() {
    clearTimer();
    lastCallTime = 0;
    lastInvokeTime = 0;
  };
  
  // 立即执行函数 - 立即执行并取消当前定时器
  debounced.flush = function(...args) {
    clearTimer();
    lastInvokeTime = Date.now();
    return invokeFunc.apply(this, args);
  };
  
  // 检查是否有等待执行的调用
  debounced.pending = function() {
    return timeoutId !== null;
  };
  
  return debounced;
}

// 使用示例
const searchInput = document.getElementById('search-input');
let searchCount = 0;

const debouncedSearch = debounce((query) => {
  console.log(`执行搜索: ${query}, 搜索次数: ${++searchCount}`);
  // 实际的搜索逻辑
}, 500, {
  leading: false,  // 不在开始时立即执行
  trailing: true,  // 在结束时执行
  maxWait: 1000    // 最大等待时间，防止长时间不执行
});

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

// 使用取消功能
const cancelBtn = document.getElementById('cancel-btn');
cancelBtn.addEventListener('click', () => {
  debouncedSearch.cancel();
  console.log('搜索已取消');
});
```

## 简化版本（常用场景）

对于大多数情况，我们可以使用一个简化版本：

```javascript
function simpleDebounce(func, wait, immediate = false) {
  let timeoutId;
  
  return function executedFunction(...args) {
    const later = () => {
      timeoutId = null;
      if (!immediate) func.apply(this, args);
    };
    
    const callNow = immediate && !timeoutId;
    
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, wait);
    
    if (callNow) func.apply(this, args);
  };
}

// 使用示例
const debouncedHandler = simpleDebounce((value) => {
  console.log('搜索:', value);
}, 300, false); // false 表示非立即执行
```

## 高级版本（支持更多特性）

```javascript
class DebounceManager {
  constructor() {
    this.functions = new Map();
  }
  
  // 创建防抖函数
  create(func, wait, options = {}) {
    const { leading = false, trailing = true, maxWait = undefined } = options;
    let timeoutId = null;
    let lastCallTime = 0;
    let lastInvokeTime = 0;
    
    const debounced = (...args) => {
      const currentTime = Date.now();
      lastCallTime = currentTime;
      
      const shouldInvokeImmediate = leading && timeoutId === null;
      
      const invoke = () => {
        lastInvokeTime = currentTime;
        return func.apply(this, args);
      };
      
      const delayedInvoke = () => {
        timeoutId = null;
        if (trailing) {
          invoke();
        }
      };
      
      clearTimeout(timeoutId);
      
      if (shouldInvokeImmediate) {
        invoke();
      } else {
        timeoutId = setTimeout(delayedInvoke, wait);
      }
    };
    
    // 添加方法
    debounced.cancel = () => {
      clearTimeout(timeoutId);
      timeoutId = null;
    };
    
    debounced.pending = () => !!timeoutId;
    
    return debounced;
  }
  
  // 批量管理
  add(key, func, wait, options) {
    const debounced = this.create(func, wait, options);
    this.functions.set(key, debounced);
    return debounced;
  }
  
  // 取消特定函数
  cancel(key) {
    const func = this.functions.get(key);
    if (func && func.cancel) {
      func.cancel();
    }
  }
  
  // 清空所有
  clear() {
    for (const [key, func] of this.functions) {
      if (func.cancel) {
        func.cancel();
      }
    }
    this.functions.clear();
  }
}
```

## 关键特性说明

1. **leading**: 是否在开始时立即执行
2. **trailing**: 是否在结束时执行
3. **maxWait**: 最大等待时间，防止函数长时间不执行
4. **cancel()**: 取消防抖函数
5. **flush()**: 立即执行防抖函数
6. **pending()**: 检查是否有等待执行的调用

## 应用场景

1. **搜索框输入**: 避免频繁的API调用
2. **窗口调整大小**: 优化resize事件处理
3. **滚动事件**: 减少scroll事件的处理频率
4. **按钮点击**: 防止重复提交

## 与节流的区别

- 防抖：只在停止触发后执行一次
- 节流：固定时间间隔内最多执行一次

通过实现一个功能完整的防抖函数，我们能够处理各种复杂的使用场景，包括取消功能和立即执行选项，这在实际开发中非常有用。