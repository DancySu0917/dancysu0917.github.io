# 平衡二叉树？二叉树搜索时间复杂度？（了解）

**题目**: 平衡二叉树？二叉树搜索时间复杂度？（了解）

## 平衡二叉树

平衡二叉树是一种特殊的二叉搜索树，它通过一定的机制确保树的高度保持在对数级别，从而保证各种操作的效率。

### 定义
平衡二叉树是指对于任意节点，其左右子树的高度差不超过1的二叉搜索树。常见的平衡二叉树包括：
- AVL树
- 红黑树
- B树和B+树
- Splay树
- Treap

### AVL树
AVL树是最先被提出的自平衡二叉搜索树，它的特点包括：
1. 左右子树的高度差不超过1
2. 每个节点都包含平衡因子（左子树高度-右子树高度），平衡因子只能是-1、0或1
3. 插入和删除操作后需要通过旋转操作来维持平衡

### 平衡操作
当插入或删除节点导致不平衡时，需要通过旋转操作来重新平衡：
1. **左旋（LL旋转）**：右右情况，需要左旋
2. **右旋（RR旋转）**：左左情况，需要右旋
3. **左右旋转（LR旋转）**：左右情况，先左旋后右旋
4. **右左旋转（RL旋转）**：右左情况，先右旋后左旋

### 平衡二叉树的实现示例

```javascript
class AVLNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.height = 1;
  }
}

class AVLTree {
  constructor() {
    this.root = null;
  }
  
  getHeight(node) {
    if (!node) return 0;
    return node.height;
  }
  
  getBalanceFactor(node) {
    if (!node) return 0;
    return this.getHeight(node.left) - this.getHeight(node.right);
  }
  
  updateHeight(node) {
    if (node) {
      node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;
    }
  }
  
  rotateRight(y) {
    const x = y.left;
    const T2 = x.right;
    
    // 执行旋转
    x.right = y;
    y.left = T2;
    
    // 更新高度
    this.updateHeight(y);
    this.updateHeight(x);
    
    // 返回新的根节点
    return x;
  }
  
  rotateLeft(x) {
    const y = x.right;
    const T2 = y.left;
    
    // 执行旋转
    y.left = x;
    x.right = T2;
    
    // 更新高度
    this.updateHeight(x);
    this.updateHeight(y);
    
    // 返回新的根节点
    return y;
  }
  
  insert(node, value) {
    // 1. 执行标准BST插入
    if (!node) {
      return new AVLNode(value);
    }
    
    if (value < node.value) {
      node.left = this.insert(node.left, value);
    } else if (value > node.value) {
      node.right = this.insert(node.right, value);
    } else {
      return node; // 重复值，不插入
    }
    
    // 2. 更新当前节点的高度
    this.updateHeight(node);
    
    // 3. 获取平衡因子
    const balance = this.getBalanceFactor(node);
    
    // 4. 如果节点不平衡，进行旋转
    // Left Left Case
    if (balance > 1 && value < node.left.value) {
      return this.rotateRight(node);
    }
    
    // Right Right Case
    if (balance < -1 && value > node.right.value) {
      return this.rotateLeft(node);
    }
    
    // Left Right Case
    if (balance > 1 && value > node.left.value) {
      node.left = this.rotateLeft(node.left);
      return this.rotateRight(node);
    }
    
    // Right Left Case
    if (balance < -1 && value < node.right.value) {
      node.right = this.rotateRight(node.right);
      return this.rotateLeft(node);
    }
    
    return node;
  }
  
  // 插入公共方法
  insertValue(value) {
    this.root = this.insert(this.root, value);
  }
  
  search(node, value) {
    if (!node || node.value === value) {
      return node;
    }
    
    if (value < node.value) {
      return this.search(node.left, value);
    }
    
    return this.search(node.right, value);
  }
  
  searchValue(value) {
    return this.search(this.root, value);
  }
}
```

## 二叉树搜索时间复杂度

### 普通二叉搜索树
- **最好情况**: O(log n) - 树接近平衡
- **最坏情况**: O(n) - 树退化为链表（完全不平衡）
- **平均情况**: O(log n) - 随机插入的情况下

### 平衡二叉搜索树
- **所有情况**: O(log n) - 由于保持平衡，树的高度始终为 O(log n)

### 搜索操作时间复杂度分析
1. **查找操作**: 从根节点开始，每次比较后可以排除一半的节点
   - 平衡树: O(log n)
   - 不平衡树: O(n)（最坏情况）
   
2. **插入操作**: 需要查找插入位置，然后插入
   - 平衡树: O(log n)
   - 不平衡树: O(n)（最坏情况）
   
3. **删除操作**: 需要查找节点，然后删除并可能重新平衡
   - 平衡树: O(log n)
   - 不平衡树: O(n)（最坏情况）

### 不同类型二叉树的时间复杂度对比

| 操作 | 普通BST | 平衡BST | 红黑树 | AVL树 |
|------|---------|---------|--------|-------|
| 查找 | O(n) | O(log n) | O(log n) | O(log n) |
| 插入 | O(n) | O(log n) | O(log n) | O(log n) |
| 删除 | O(n) | O(log n) | O(log n) | O(log n) |

### 实际应用场景
1. **AVL树**: 适用于查找操作远多于插入删除操作的场景，因为AVL树更严格平衡
2. **红黑树**: 适用于插入删除操作较多的场景，平衡性稍差但旋转次数较少
3. **数据库索引**: 通常使用B+树，是平衡树的变种
4. **语言标准库**: Java的TreeMap、C++的std::map等使用红黑树

平衡二叉树通过保持树的平衡性，确保了高效的搜索、插入和删除操作，是数据结构中非常重要的概念。
