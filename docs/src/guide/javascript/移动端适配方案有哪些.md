# 移动端适配方案有哪些？（了解）

**题目**: 移动端适配方案有哪些？（了解）

**答案**:

移动端适配是前端开发中的重要课题，由于移动设备屏幕尺寸和分辨率差异巨大，我们需要采用合适的适配方案来确保页面在不同设备上都能良好显示。以下是主要的移动端适配方案：

## 1. 响应式设计（Responsive Design）

### 媒体查询（Media Queries）
```css
/* 基于断点的响应式设计 */
.container {
  width: 100%;
  padding: 10px;
}

/* 小屏幕设备 */
@media (max-width: 768px) {
  .container {
    padding: 5px;
  }
  
  .nav {
    flex-direction: column;
  }
}

/* 中等屏幕设备 */
@media (min-width: 769px) and (max-width: 1024px) {
  .container {
    max-width: 750px;
    margin: 0 auto;
  }
}

/* 大屏幕设备 */
@media (min-width: 1025px) {
  .container {
    max-width: 1200px;
    margin: 0 auto;
  }
}
```

## 2. 视口单位适配（Viewport Units）

### 使用vw、vh、vmin、vmax
```css
/* 基于视口宽度的适配 */
.title {
  font-size: 4vw; /* 字体大小为视口宽度的4% */
  padding: 2vh;   /* 内边距为视口高度的2% */
}

/* 使用clamp()函数进行更精确的控制 */
.responsive-text {
  font-size: clamp(14px, 2.5vw, 24px); /* 最小14px，理想2.5vw，最大24px */
}

/* 全屏高度布局 */
.full-screen {
  height: 100vh;
  width: 100vw;
}
```

## 3. REM适配方案

### 基于根元素字体大小的适配
```javascript
// 动态设置根元素字体大小
function setRootFontSize() {
  const deviceWidth = document.documentElement.clientWidth;
  const designWidth = 375; // 设计稿宽度
  const rootFontSize = (deviceWidth / designWidth) * 16; // 16px是基准字体大小
  
  document.documentElement.style.fontSize = rootFontSize + 'px';
}

// 页面加载和窗口大小改变时重新计算
window.addEventListener('resize', setRootFontSize);
window.addEventListener('orientationchange', setRootFontSize);
document.addEventListener('DOMContentLoaded', setRootFontSize);

// 使用rem单位的CSS
.container {
  width: 23.4375rem; /* 375px / 16px = 23.4375rem */
  padding: 1rem;      /* 16px */
  font-size: 0.875rem; /* 14px */
}
```

## 4. Flexible方案（淘宝推荐）

### Flexible.js核心实现
```javascript
// flexible.js简化版实现
(function(win, lib) {
  const doc = win.document;
  const docEl = doc.documentElement;
  
  // 设备像素比
  const devicePixelRatio = win.devicePixelRatio;
  
  // 设置data-dpr属性
  docEl.setAttribute('data-dpr', devicePixelRatio);
  
  // 创建meta标签设置viewport
  let metaEl = doc.createElement('meta');
  metaEl.name = 'viewport';
  metaEl.content = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';
  if (docEl.firstElementChild) {
    docEl.firstElementChild.appendChild(metaEl);
  } else {
    const wrap = doc.createElement('div');
    wrap.appendChild(metaEl);
    doc.write(wrap.innerHTML);
  }
  
  // 设置根字体大小
  function refreshRem() {
    const width = docEl.getBoundingClientRect().width;
    const rem = width / 10; // 将屏幕宽度分成10份
    docEl.style.fontSize = rem + 'px';
  }
  
  win.addEventListener('resize', refreshRem);
  refreshRem();
})(window);
```

## 5. 视口缩放适配

### 通过设置viewport进行缩放适配
```html
<!-- 针对特定设计稿尺寸的viewport设置 -->
<script>
  // 假设设计稿宽度为750px
  const dpr = window.devicePixelRatio;
  const scale = 1 / dpr;
  const width = window.screen.width;
  
  document.write(`
    <meta name="viewport" content="
      width=${width * dpr},
      initial-scale=${scale},
      maximum-scale=${scale},
      minimum-scale=${scale},
      user-scalable=no
    " />
  `);
</script>
```

## 6. 组件级适配方案

### 使用CSS Grid和Flexbox
```css
/* 弹性布局 */
.flex-container {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.flex-item {
  flex: 1 1 300px; /* 最小宽度300px，可伸缩 */
  margin: 10px;
}

/* 网格布局 */
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
}

/* 自适应卡片 */
.card {
  width: 100%;
  max-width: 400px;
  margin: 0 auto;
  box-sizing: border-box;
}
```

## 7. JavaScript辅助适配

### 动态适配工具类
```javascript
class MobileAdapter {
  constructor(options = {}) {
    this.designWidth = options.designWidth || 375;
    this.maxWidth = options.maxWidth || 540;
    this.minWidth = options.minWidth || 320;
    this.rootFontSize = options.rootFontSize || 16;
    
    this.init();
  }
  
  init() {
    this.setRootFontSize();
    this.bindEvents();
  }
  
  setRootFontSize() {
    const deviceWidth = Math.min(
      window.screen.width, 
      window.screen.height,
      this.maxWidth
    );
    
    // 限制最小宽度
    const width = Math.max(deviceWidth, this.minWidth);
    
    // 计算根字体大小
    const rootFontSize = (width / this.designWidth) * this.rootFontSize;
    
    document.documentElement.style.fontSize = rootFontSize + 'px';
  }
  
  bindEvents() {
    window.addEventListener('resize', () => {
      this.setRootFontSize();
    });
    
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        this.setRootFontSize();
      }, 100);
    });
  }
  
  // 获取适配后的尺寸
  getAdaptedSize(size) {
    return size / this.rootFontSize + 'rem';
  }
}

// 使用示例
const adapter = new MobileAdapter({
  designWidth: 375,
  rootFontSize: 16
});
```

## 8. 工程化适配方案

### PostCSS插件自动转换
```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-pxtorem')({
      rootValue: 37.5, // 设计稿宽度/10
      propList: ['*'],
      selectorBlackList: ['.no-rem'],
      minPixelValue: 2
    })
  ]
};

// CSS中直接使用px，自动转换为rem
.container {
  width: 375px;    /* 自动转换为10rem */
  height: 200px;   /* 自动转换为5.333rem */
  font-size: 16px; /* 自动转换为0.427rem */
}
```

## 9. 物理像素与逻辑像素适配

### 1px边框解决方案
```css
/* 使用transform: scale()实现0.5px边框 */
.border-1px {
  position: relative;
}

.border-1px::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px;
  background: #ddd;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}

/* 多方向边框 */
.border-all {
  position: relative;
}

.border-all::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 200%;
  height: 200%;
  border: 1px solid #ddd;
  transform: scale(0.5);
  transform-origin: 0 0;
  pointer-events: none;
}
```

## 10. 方案选择建议

### 不同场景的适配方案选择：

1. **简单项目**：使用REM + 媒体查询
2. **复杂响应式项目**：Flexbox/Grid + 媒体查询
3. **H5活动页面**：视口单位 + 固定比例缩放
4. **移动端Web App**：Flexible方案或自定义REM方案
5. **小程序项目**：rpx单位（微信小程序）或px配合设备适配

### 适配方案对比：

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| REM | 兼容性好，计算简单 | 需要JS辅助，可能出现小数点精度问题 | 大部分移动端项目 |
| 视口单位 | 无需JS，原生支持 | 兼容性稍差，无法设置最大最小值 | 现代移动端项目 |
| 媒体查询 | 精确控制，逻辑清晰 | 代码量大，维护复杂 | 复杂响应式布局 |
| Flexible | 淘宝方案，成熟稳定 | 增加JS开销 | 高性能要求的移动端项目 |

选择合适的适配方案需要考虑项目复杂度、兼容性要求、开发效率等多个因素。