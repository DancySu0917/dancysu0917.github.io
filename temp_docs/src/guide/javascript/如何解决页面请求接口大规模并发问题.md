# 如何解决页面请求接口大规模并发问题？（了解）

**题目**: 如何解决页面请求接口大规模并发问题？（了解）

## 标准答案

解决页面请求接口大规模并发问题的主要策略包括：1) 请求合并与批量处理，将多个小请求合并为一个大请求；2) 请求节流与防抖，限制请求频率；3) 请求缓存机制，避免重复请求；4) 请求队列管理，控制并发数量；5) 服务端限流与熔断，保护后端服务；6) CDN与静态资源优化，减少主服务压力；7) 数据分页与懒加载，减少单次请求数据量。这些策略可以有效控制并发请求数量，提升系统稳定性和用户体验。

## 深入分析

### 并发问题的根源

大规模并发请求问题通常出现在以下场景：
1. 页面初始化时需要请求多个接口
2. 用户频繁操作触发重复请求
3. 实时数据更新需求（如聊天、股票数据）
4. 多组件同时请求数据
5. 网络不稳定导致的重复请求

### 并发控制的重要性

不加控制的并发请求会带来以下问题：
- 浏览器连接数限制（通常为6-8个）
- 服务端压力过大，可能导致服务崩溃
- 网络拥塞，请求响应时间变长
- 用户体验下降，页面响应缓慢
- 资源浪费，重复请求相同数据

### 解决策略分类

1. **客户端控制**：在前端层面控制请求的发起和管理
2. **服务端控制**：通过服务端限流、熔断等机制保护服务
3. **架构层面**：通过CDN、负载均衡、缓存等架构优化

## 代码实现

```javascript
// 并发请求控制工具集

// 1. 请求队列管理器
class RequestQueueManager {
  constructor(maxConcurrency = 6) {
    this.maxConcurrency = maxConcurrency;
    this.running = 0;
    this.queue = [];
  }

  async add(requestFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        requestFn,
        resolve,
        reject
      });
      this.process();
    });
  }

  async process() {
    if (this.running >= this.maxConcurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { requestFn, resolve, reject } = this.queue.shift();

    try {
      const result = await requestFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process(); // 处理队列中的下一个请求
    }
  }
}

// 2. 请求合并器
class RequestMerger {
  constructor() {
    this.pendingRequests = new Map();
    this.batchQueue = new Map();
    this.batchTimeout = 100; // 批处理延迟时间
  }

  async request(url, options = {}) {
    // 如果是相同请求，返回同一个Promise
    const key = this.generateKey(url, options);
    
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    // 检查是否可以批量处理
    if (options.batchable !== false) {
      return this.addToBatch(key, url, options);
    } else {
      const promise = this.makeRequest(url, options);
      this.pendingRequests.set(key, promise);
      
      // 清理缓存
      promise.finally(() => {
        this.pendingRequests.delete(key);
      });
      
      return promise;
    }
  }

  addToBatch(key, url, options) {
    return new Promise((resolve, reject) => {
      if (!this.batchQueue.has(url)) {
        this.batchQueue.set(url, []);
      }
      
      this.batchQueue.get(url).push({ key, options, resolve, reject });
      
      // 设置延迟执行
      setTimeout(() => {
        this.executeBatch(url);
      }, this.batchTimeout);
    });
  }

  async executeBatch(url) {
    const requests = this.batchQueue.get(url);
    if (!requests || requests.length === 0) return;

    this.batchQueue.delete(url);

    try {
      // 如果只有一个请求，直接执行
      if (requests.length === 1) {
        const [request] = requests;
        const promise = this.makeRequest(url, request.options);
        this.pendingRequests.set(request.key, promise);
        
        promise.then(result => {
          request.resolve(result);
        }).catch(error => {
          request.reject(error);
        }).finally(() => {
          this.pendingRequests.delete(request.key);
        });
      } else {
        // 批量执行多个请求（实际应用中可能需要后端支持）
        const promises = requests.map(req => 
          this.makeRequest(url, req.options)
        );
        
        const results = await Promise.allSettled(promises);
        
        results.forEach((result, index) => {
          const request = requests[index];
          if (result.status === 'fulfilled') {
            request.resolve(result.value);
          } else {
            request.reject(result.reason);
          }
        });
      }
    } catch (error) {
      requests.forEach(request => {
        request.reject(error);
      });
    }
  }

  generateKey(url, options) {
    return `${url}_${JSON.stringify(options)}`;
  }

  async makeRequest(url, options) {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status} ${response.statusText}`);
    }
    return response.json();
  }
}

// 3. 请求缓存管理器
class RequestCacheManager {
  constructor() {
    this.cache = new Map();
    this.timers = new Map();
  }

  async request(url, options = {}, cacheTime = 5 * 60 * 1000) { // 默认缓存5分钟
    const cacheKey = this.generateKey(url, options);
    
    // 检查缓存
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    // 发起请求
    const promise = this.makeRequest(url, options);
    
    // 存储到缓存
    this.cache.set(cacheKey, promise);
    
    // 设置过期时间
    if (this.timers.has(cacheKey)) {
      clearTimeout(this.timers.get(cacheKey));
    }
    
    this.timers.set(cacheKey, setTimeout(() => {
      this.cache.delete(cacheKey);
      this.timers.delete(cacheKey);
    }, cacheTime));
    
    return promise;
  }

  generateKey(url, options) {
    return `${url}_${JSON.stringify(options)}`;
  }

  async makeRequest(url, options) {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status} ${response.statusText}`);
    }
    return response.json();
  }

  clearCache() {
    this.cache.clear();
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
  }
}

// 4. 请求节流与防抖管理器
class RequestThrottleManager {
  constructor() {
    this.timers = new Map();
  }

  // 节流：在一定时间间隔内只执行一次
  throttle(key, fn, delay = 300) {
    if (this.timers.has(key)) {
      return Promise.reject(new Error('Request throttled'));
    }

    const execute = async () => {
      try {
        return await fn();
      } finally {
        this.timers.delete(key);
      }
    };

    this.timers.set(key, setTimeout(() => {
      this.timers.delete(key);
    }, delay));

    return execute();
  }

  // 防抖：只执行最后一次请求
  debounce(key, fn, delay = 300) {
    // 清除之前的定时器
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }

    return new Promise((resolve, reject) => {
      const timer = setTimeout(async () => {
        try {
          const result = await fn();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.timers.delete(key);
        }
      }, delay);

      this.timers.set(key, timer);
    });
  }
}

// 5. 综合请求管理器
class AdvancedRequestManager {
  constructor(options = {}) {
    this.maxConcurrency = options.maxConcurrency || 6;
    this.cacheTime = options.cacheTime || 5 * 60 * 1000; // 5分钟
    this.throttleDelay = options.throttleDelay || 300; // 300ms
    
    this.queueManager = new RequestQueueManager(this.maxConcurrency);
    this.requestMerger = new RequestMerger();
    this.cacheManager = new RequestCacheManager();
    this.throttleManager = new RequestThrottleManager();
  }

  async request(url, options = {}) {
    // 检查是否需要缓存
    if (options.cache !== false) {
      return this.cacheManager.request(url, options, this.cacheTime);
    }

    // 检查是否需要节流
    if (options.throttle) {
      const key = this.generateKey(url, options);
      return this.throttleManager.throttle(key, () => this.makeRequest(url, options), this.throttleDelay);
    }

    // 检查是否需要防抖
    if (options.debounce) {
      const key = this.generateKey(url, options);
      return this.throttleManager.debounce(key, () => this.makeRequest(url, options), this.throttleDelay);
    }

    // 检查是否需要队列控制
    if (options.queue !== false) {
      return this.queueManager.add(() => this.makeRequest(url, options));
    }

    // 直接请求
    return this.makeRequest(url, options);
  }

  async makeRequest(url, options) {
    // 可以在这里添加请求拦截、错误重试等逻辑
    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error(`Request failed: ${response.status} ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      // 错误处理逻辑
      console.error('Request error:', error);
      throw error;
    }
  }

  generateKey(url, options) {
    return `${url}_${JSON.stringify(options)}`;
  }

  // 批量请求
  async batchRequest(requests) {
    const promises = requests.map(req => this.request(req.url, req.options));
    return Promise.allSettled(promises);
  }

  // 并发控制的批量请求
  async limitedBatchRequest(requests, limit = 5) {
    const results = [];
    for (let i = 0; i < requests.length; i += limit) {
      const batch = requests.slice(i, i + limit);
      const batchPromises = batch.map(req => this.request(req.url, req.options));
      const batchResults = await Promise.allSettled(batchPromises);
      results.push(...batchResults);
    }
    return results;
  }
}

// 6. 使用示例
const requestManager = new AdvancedRequestManager({
  maxConcurrency: 4,
  cacheTime: 10 * 60 * 1000, // 10分钟
  throttleDelay: 500
});

// 普通请求
requestManager.request('/api/users')
  .then(data => console.log('Users:', data))
  .catch(error => console.error('Error:', error));

// 带缓存的请求
requestManager.request('/api/config', { cache: true })
  .then(data => console.log('Config:', data));

// 节流请求（搜索输入框场景）
const search = async (query) => {
  return requestManager.request('/api/search', { 
    method: 'POST', 
    body: JSON.stringify({ query }),
    headers: { 'Content-Type': 'application/json' },
    throttle: true 
  });
};

// 防抖请求（滚动加载场景）
const loadMore = async (page) => {
  return requestManager.request('/api/items', { 
    method: 'GET', 
    params: { page },
    debounce: true 
  });
};

// 批量请求
const batchRequests = [
  { url: '/api/users', options: {} },
  { url: '/api/orders', options: {} },
  { url: '/api/products', options: {} }
];

requestManager.batchRequest(batchRequests)
  .then(results => {
    console.log('Batch results:', results);
  });

// 7. React Hook 实现
function useRequestManager(options = {}) {
  const [requestManager] = React.useState(() => new AdvancedRequestManager(options));
  
  const request = React.useCallback((url, options = {}) => {
    return requestManager.request(url, options);
  }, [requestManager]);
  
  const batchRequest = React.useCallback((requests) => {
    return requestManager.batchRequest(requests);
  }, [requestManager]);
  
  return { request, batchRequest };
}

// 8. 错误重试机制
class RetryableRequestManager extends AdvancedRequestManager {
  async requestWithRetry(url, options = {}, maxRetries = 3, retryDelay = 1000) {
    let lastError;
    
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await this.request(url, options);
      } catch (error) {
        lastError = error;
        
        if (i < maxRetries) {
          // 指数退避策略
          const delay = retryDelay * Math.pow(2, i);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }
}

// 使用重试机制
const retryableManager = new RetryableRequestManager();
retryableManager.requestWithRetry('/api/data', {}, 3, 1000)
  .then(data => console.log('Data:', data))
  .catch(error => console.error('Final error after retries:', error));
```

## 实际应用场景

1. **电商网站商品列表**: 在用户滚动浏览商品列表时，使用并发控制避免同时发起大量请求，影响页面性能。

2. **搜索功能优化**: 在用户输入搜索关键词时，使用防抖机制避免每次输入都发起请求，减少服务端压力。

3. **实时数据更新**: 在股票、聊天等需要实时更新数据的场景中，使用批量请求合并多个更新请求。

4. **表单验证**: 在表单多个字段需要异步验证时，使用并发控制避免同时发起多个验证请求。

5. **多组件数据请求**: 在页面初始化时，多个组件需要请求不同接口，使用队列管理控制并发数量。

6. **API网关集成**: 在微服务架构中，前端需要调用多个后端服务，使用请求合并减少网络开销。
