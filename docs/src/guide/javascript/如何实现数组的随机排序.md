# 如何实现数组的随机排序？（必会）

**题目**: 如何实现数组的随机排序？（必会）

**答案**:

数组随机排序是前端开发中常见的需求，主要有以下几种实现方法：

## 1. Fisher-Yates 洗牌算法（推荐）

这是最经典、最公平的数组随机排序算法，时间复杂度为 O(n)：

```javascript
function shuffle(arr) {
    const result = [...arr]; // 创建副本，避免修改原数组
    for (let i = result.length - 1; i > 0; i--) {
        // 生成 0 到 i 之间的随机索引
        const j = Math.floor(Math.random() * (i + 1));
        // 交换元素
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

// 使用示例
const arr = [1, 2, 3, 4, 5];
console.log(shuffle(arr)); // 输出随机排序后的数组
```

## 2. 使用 sort() 方法配合随机比较函数

这种方法利用数组的 sort() 方法，通过随机返回值实现随机排序：

```javascript
function shuffle(arr) {
    return [...arr].sort(() => Math.random() - 0.5);
}

// 使用示例
const arr = [1, 2, 3, 4, 5];
console.log(shuffle(arr)); // 输出随机排序后的数组
```

**注意**：这种方法虽然简单，但不能保证完全随机分布，不推荐在对随机性要求严格的场景使用。

## 3. 递归随机选择

从数组中随机选择元素并添加到新数组中：

```javascript
function shuffle(arr) {
    const result = [];
    const copy = [...arr];
    
    while (copy.length > 0) {
        const randomIndex = Math.floor(Math.random() * copy.length);
        result.push(copy.splice(randomIndex, 1)[0]);
    }
    
    return result;
}

// 使用示例
const arr = [1, 2, 3, 4, 5];
console.log(shuffle(arr)); // 输出随机排序后的数组
```

## 4. 使用 reduce 方法

通过 reduce 方法实现随机插入：

```javascript
function shuffle(arr) {
    return [...arr].reduce((acc, item) => {
        const randomIndex = Math.floor(Math.random() * (acc.length + 1));
        acc.splice(randomIndex, 0, item);
        return acc;
    }, []);
}

// 使用示例
const arr = [1, 2, 3, 4, 5];
console.log(shuffle(arr)); // 输出随机排序后的数组
```

## 各方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 随机性 | 推荐度 |
|------|------------|------------|--------|--------|
| Fisher-Yates | O(n) | O(n) | 完美 | ⭐⭐⭐⭐⭐ |
| sort 随机 | O(n log n) | O(n) | 不完美 | ⭐⭐ |
| 递归随机选择 | O(n²) | O(n) | 完美 | ⭐⭐⭐ |
| reduce 随机 | O(n²) | O(n) | 完美 | ⭐⭐⭐ |

## 实际应用场景

1. **游戏开发**：洗牌、随机关卡生成
2. **问卷调查**：随机排列选项，避免顺序偏差
3. **推荐系统**：随机展示推荐内容
4. **测试数据**：生成随机测试数据

## 注意事项

1. **修改原数组**：如果不想修改原数组，记得先创建副本
2. **随机性质量**：Fisher-Yates 算法能保证每个排列的概率相等
3. **性能考虑**：对于大数组，Fisher-Yates 是最优选择
4. **浏览器兼容性**：所有方法都兼容现代浏览器

在实际开发中，推荐使用 Fisher-Yates 洗牌算法，它既保证了良好的随机性，又有优秀的性能表现。
