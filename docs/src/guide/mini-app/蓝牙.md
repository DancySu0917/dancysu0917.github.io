# 蓝牙（BLE）接入

微信小程序支持使用低功耗蓝牙（BLE）与设备交互，常见流程为：

**初始化适配器 → 扫描设备 → 建立连接 → 获取服务/特征 → 读/写/订阅通知 → 断开与清理**。

::: code-group

```html [wxml]
<view class="section">
    <button bindtap="initBLE">初始化蓝牙</button>
    <button bindtap="startScan" disabled="{{!bleReady || scanning}}">开始扫描</button>
    <button bindtap="stopScan" disabled="{{!scanning}}">停止扫描</button>
</view>

<view class="section">
    <text>设备列表：</text>
    <block wx:for="{{devices}}" wx:key="deviceId">
        <button data-id="{{item.deviceId}}" bindtap="connect">{{item.name || '未命名'}}（{{item.deviceId}}）</button>
    </block>
</view>

<view class="section" wx:if="{{connected}}">
    <text>已连接：{{connectedDevice.name}}（{{connectedDevice.deviceId}}）</text>
    <button bindtap="getServices">获取服务</button>
    <button bindtap="getChars" disabled="{{!currentService}}">获取特征</button>
    <button bindtap="enableNotify" disabled="{{!notifyChar}}">开启通知</button>
    <button bindtap="readChar" disabled="{{!readChar}}">读取一次</button>
    <button bindtap="writeChar" disabled="{{!writeChar}}">写入示例</button>
    <button bindtap="disconnect">断开连接</button>
</view>

<view class="log">
    <text>日志：</text>
    <scroll-view scroll-y style="height:240rpx">
        <block wx:for="{{logs}}" wx:key="idx">
            <text>{{item}}</text>
        </block>
    </scroll-view>
</view>
```

```js [js]
Page({
    data: {
        bleReady: false,
        scanning: false,
        devices: [],
        connected: false,
        connectedDevice: {},
        currentService: null,
        services: [],
        chars: [],
        notifyChar: null,
        readChar: null,
        writeChar: null,
        logs: []
    },

    log(msg) {
        const time = new Date().toLocaleTimeString()
        this.setData({ logs: [`[${time}] ${msg}`, ...this.data.logs].slice(0, 200) })
        console.log(msg)
    },

    // 1) 初始化适配器
    async initBLE() {
        try {
            await wx.openBluetoothAdapter()
            this.setData({ bleReady: true })
            this.log('蓝牙适配器已初始化')
            // 监听适配器状态
            wx.onBluetoothAdapterStateChange(res => {
                this.log(`适配器状态: available=${res.available}, discovering=${res.discovering}`)
            })
            // 监听扫描发现
            wx.onBluetoothDeviceFound(({ devices }) => {
                const list = [...this.data.devices]
                devices.forEach(d => {
                    if (!d.deviceId) return
                    const idx = list.findIndex(x => x.deviceId === d.deviceId)
                    if (idx >= 0) list[idx] = { ...list[idx], ...d }
                    else list.push(d)
                })
                this.setData({ devices: list })
            })
            // 监听连接状态变化
            wx.onBLEConnectionStateChange(res => {
                this.log(`连接状态变化: ${res.connected} -> ${res.deviceId}`)
                if (!res.connected && this.data.connected) {
                    this.setData({ connected: false, connectedDevice: {}, currentService: null, services: [], chars: [], notifyChar: null, readChar: null, writeChar: null })
                }
            })
        } catch (e) {
            this.log(`初始化失败：${e.errMsg || e}`)
            if (e.errCode === 10001) this.log('蓝牙未开启，请提示用户打开系统蓝牙')
        }
    },

    // 2) 扫描设备
    async startScan() {
        if (!this.data.bleReady) return this.log('请先初始化蓝牙')
        try {
            this.setData({ devices: [], scanning: true })
            await wx.startBluetoothDevicesDiscovery({
                allowDuplicatesKey: false,   // 不要回调重复设备
                powerLevel: 'high',          // 更高的扫描功率（兼容看机型）
                interval: 0                  // 尽快上报
                // services: ['自定义过滤的Service UUID'] // 如需仅发现特定服务的设备
            })
            this.log('开始扫描')
        } catch (e) {
            this.setData({ scanning: false })
            this.log(`开始扫描失败：${e.errMsg || e}`)
        }
    },

    // 3) 停止扫描
    async stopScan() {
        try {
            await wx.stopBluetoothDevicesDiscovery()
            this.setData({ scanning: false })
            this.log('已停止扫描')
        } catch (e) {
            this.log(`停止扫描失败：${e.errMsg || e}`)
        }
    },

    // 4) 连接设备
    async connect(e) {
        const deviceId = e.currentTarget.dataset.id
        try {
            await this.stopScan()
            await wx.createBLEConnection({ deviceId, timeout: 10000 })
            // 读取设备名称(从已缓存列表找)
            const dev = this.data.devices.find(d => d.deviceId === deviceId) || { deviceId, name: '' }
            this.setData({ connected: true, connectedDevice: dev })
            this.log(`已连接：${dev.name || '未命名'} (${deviceId})`)
        } catch (e2) {
            this.log(`连接失败：${e2.errMsg || e2}`)
            if (e2.errCode === 10003) this.log('连接超时/失败，建议靠近设备或重试')
        }
    },

    // 5) 获取服务
    async getServices() {
        const { deviceId } = this.data.connectedDevice
        try {
            const res = await wx.getBLEDeviceServices({ deviceId })
            const services = (res.services || []).filter(s => s.isPrimary)
            this.setData({ services, currentService: services[0] || null })
            this.log(`发现 ${services.length} 个主服务`)
        } catch (e) {
            this.log(`获取服务失败：${e.errMsg || e}`)
        }
    },

    // 6) 获取特征
    async getChars() {
        const { deviceId } = this.data.connectedDevice
        const serviceId = this.data.currentService?.uuid
        if (!serviceId) return this.log('请先选择服务')
        try {
            const res = await wx.getBLEDeviceCharacteristics({ deviceId, serviceId })
            const chars = res.characteristics || []
            // 简单推断：可写、可读、可通知的特征
            const writeChar = chars.find(c => (c.properties.write || c.properties.writeNoResponse))
            const readChar = chars.find(c => c.properties.read)
            const notifyChar = chars.find(c => c.properties.notify || c.properties.indicate)
            this.setData({ chars, writeChar, readChar, notifyChar })
            this.log(`发现特征 ${chars.length} 个`)
            if (notifyChar) this.log(`可通知特征：${notifyChar.uuid}`)
            if (readChar) this.log(`可读特征：${readChar.uuid}`)
            if (writeChar) this.log(`可写特征：${writeChar.uuid}`)
        } catch (e) {
            this.log(`获取特征失败：${e.errMsg || e}`)
        }
    },

    // 7) 订阅通知（监听设备主动上报）
    async enableNotify() {
        const { deviceId } = this.data.connectedDevice
        const serviceId = this.data.currentService?.uuid
        const characteristicId = this.data.notifyChar?.uuid
        if (!characteristicId) return this.log('没有可通知的特征')
        try {
            await wx.notifyBLECharacteristicValueChange({
                deviceId, serviceId, characteristicId, state: true
            })
            this.log('已开启通知')
            wx.onBLECharacteristicValueChange(({ characteristicId, value }) => {
                const hex = ab2hex(value)
                this.log(`Notify: ${characteristicId} -> ${hex}`)
            })
        } catch (e) {
            this.log(`开启通知失败：${e.errMsg || e}`)
        }
    },

    // 8) 读取一次
    async readChar() {
        const { deviceId } = this.data.connectedDevice
        const serviceId = this.data.currentService?.uuid
        const characteristicId = this.data.readChar?.uuid
        if (!characteristicId) return this.log('没有可读的特征')
        try {
            await wx.readBLECharacteristicValue({ deviceId, serviceId, characteristicId })
            // 读取结果将通过 onBLECharacteristicValueChange 返回（部分机型/协议栈实现如此）
        } catch (e) {
            this.log(`读取失败：${e.errMsg || e}`)
        }
    },

    // 9) 写入示例
    async writeChar() {
        const { deviceId } = this.data.connectedDevice
        const serviceId = this.data.currentService?.uuid
        const characteristicId = this.data.writeChar?.uuid
        if (!characteristicId) return this.log('没有可写的特征')
        try {
            const buffer = hex2ab('A1B2C3') // 示例写入数据（按你的协议替换）
            await wx.writeBLECharacteristicValue({
                deviceId, serviceId, characteristicId, value: buffer
            })
            this.log('写入成功')
        } catch (e) {
            this.log(`写入失败：${e.errMsg || e}`)
        }
    },

    // 10) 断开与清理
    async disconnect() {
        try {
            if (this.data.connectedDevice.deviceId) {
                await wx.closeBLEConnection({ deviceId: this.data.connectedDevice.deviceId })
            }
            await wx.stopBluetoothDevicesDiscovery().catch(() => { })
            await wx.closeBluetoothAdapter().catch(() => { })
            this.setData({
                bleReady: false, scanning: false, devices: [],
                connected: false, connectedDevice: {},
                currentService: null, services: [], chars: [],
                notifyChar: null, readChar: null, writeChar: null
            })
            this.log('已断开并释放资源')
        } catch (e) {
            this.log(`清理失败：${e.errMsg || e}`)
        }
    }
})

// ------- 小工具：ArrayBuffer <-> Hex --------
function ab2hex(buffer) {
    const hexArr = Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2))
    return hexArr.join('').toUpperCase()
}
function hex2ab(hexStr) {
    const typedArray = new Uint8Array(hexStr.match(/[\da-f]{2}/gi).map(h => parseInt(h, 16)))
    return typedArray.buffer
}
```

:::
