# 实现一个支持异步任务并发控制的调度器，要求支持设置最大并发数、任务支持优先级、可取消未执行任务、统计？（了解）

**题目**: 实现一个支持异步任务并发控制的调度器，要求支持设置最大并发数、任务支持优先级、可取消未执行任务、统计？（了解）

## 答案

实现一个支持异步任务并发控制的调度器需要考虑以下几个核心功能：

1. 任务队列管理（优先级排序）
2. 并发数控制
3. 任务取消机制
4. 统计信息收集

以下是一个完整的实现：

```javascript
class TaskScheduler {
  constructor(maxConcurrency = 1) {
    this.maxConcurrency = maxConcurrency; // 最大并发数
    this.runningTasks = 0;                // 当前运行任务数
    this.taskQueue = [];                  // 任务队列
    this.stats = {                        // 统计信息
      totalTasks: 0,
      completedTasks: 0,
      failedTasks: 0,
      cancelledTasks: 0
    };
  }

  // 添加任务
  add(task, priority = 0, id = null) {
    const taskId = id || `task_${Date.now()}_${Math.random()}`;
    const taskItem = {
      id: taskId,
      task,
      priority,
      createdAt: Date.now(),
      startTime: null,
      endTime: null
    };

    this.taskQueue.push(taskItem);
    this.stats.totalTasks++;
    
    // 按优先级排序（数字越大优先级越高）
    this.taskQueue.sort((a, b) => b.priority - a.priority);
    
    // 尝试执行任务
    this.executeNext();
    
    return taskId;
  }

  // 执行下一个任务
  executeNext() {
    if (this.runningTasks >= this.maxConcurrency || this.taskQueue.length === 0) {
      return;
    }

    const taskItem = this.taskQueue.shift();
    this.runningTasks++;
    taskItem.startTime = Date.now();

    // 执行任务
    Promise.resolve(taskItem.task())
      .then(result => {
        this.stats.completedTasks++;
        taskItem.endTime = Date.now();
        taskItem.result = result;
        console.log(`Task ${taskItem.id} completed`);
      })
      .catch(error => {
        this.stats.failedTasks++;
        taskItem.endTime = Date.now();
        taskItem.error = error;
        console.error(`Task ${taskItem.id} failed:`, error);
      })
      .finally(() => {
        this.runningTasks--;
        this.executeNext(); // 执行下一个任务
      });
  }

  // 取消未执行的任务
  cancel(taskId) {
    // 从队列中移除任务
    const queueIndex = this.taskQueue.findIndex(task => task.id === taskId);
    if (queueIndex !== -1) {
      this.taskQueue.splice(queueIndex, 1);
      this.stats.cancelledTasks++;
      console.log(`Task ${taskId} cancelled`);
      return true;
    }
    
    // 注意：正在运行的任务无法取消，因为Promise无法取消
    console.warn(`Task ${taskId} not found in queue`);
    return false;
  }

  // 获取统计信息
  getStats() {
    return {
      ...this.stats,
      runningTasks: this.runningTasks,
      queuedTasks: this.taskQueue.length,
      maxConcurrency: this.maxConcurrency
    };
  }

  // 清空队列
  clearQueue() {
    const cancelledCount = this.taskQueue.length;
    this.taskQueue = [];
    this.stats.cancelledTasks += cancelledCount;
    console.log(`Cleared ${cancelledCount} tasks from queue`);
  }

  // 等待所有任务完成
  async waitForAll() {
    return new Promise((resolve) => {
      const checkCompletion = () => {
        if (this.runningTasks === 0 && this.taskQueue.length === 0) {
          resolve();
        } else {
          setTimeout(checkCompletion, 10);
        }
      };
      checkCompletion();
    });
  }
}

// 使用示例
const scheduler = new TaskScheduler(3); // 最大并发数为3

// 模拟异步任务
function createAsyncTask(name, duration) {
  return () => new Promise(resolve => {
    console.log(`Task ${name} started`);
    setTimeout(() => {
      console.log(`Task ${name} completed`);
      resolve(`Result of ${name}`);
    }, duration);
  });
}

// 添加任务（带优先级）
scheduler.add(createAsyncTask('Low Priority', 2000), 1, 'low1');
scheduler.add(createAsyncTask('High Priority', 1000), 10, 'high1');
scheduler.add(createAsyncTask('Medium Priority', 1500), 5, 'med1');
scheduler.add(createAsyncTask('Another High', 1200), 10, 'high2');

// 取消一个未执行的任务
scheduler.cancel('low1');

// 查看统计信息
console.log('Initial stats:', scheduler.getStats());

// 等待所有任务完成
scheduler.waitForAll().then(() => {
  console.log('All tasks completed');
  console.log('Final stats:', scheduler.getStats());
});
```

### 高级版本（支持任务取消）

如果需要支持取消正在运行的任务，可以使用 AbortController：

```javascript
class AdvancedTaskScheduler {
  constructor(maxConcurrency = 1) {
    this.maxConcurrency = maxConcurrency;
    this.runningTasks = 0;
    this.taskQueue = [];
    this.taskControllers = new Map(); // 存储任务控制器
    this.stats = {
      totalTasks: 0,
      completedTasks: 0,
      failedTasks: 0,
      cancelledTasks: 0
    };
  }

  add(task, priority = 0, id = null) {
    const taskId = id || `task_${Date.now()}_${Math.random()}`;
    const controller = new AbortController();
    
    const taskItem = {
      id: taskId,
      task,
      priority,
      controller,
      createdAt: Date.now(),
      startTime: null,
      endTime: null
    };

    this.taskQueue.push(taskItem);
    this.taskControllers.set(taskId, controller);
    this.stats.totalTasks++;
    
    this.taskQueue.sort((a, b) => b.priority - a.priority);
    this.executeNext();
    
    return taskId;
  }

  executeNext() {
    if (this.runningTasks >= this.maxConcurrency || this.taskQueue.length === 0) {
      return;
    }

    const taskItem = this.taskQueue.shift();
    this.runningTasks++;
    taskItem.startTime = Date.now();

    // 执行任务，传递 abort 信号
    taskItem.task(taskItem.controller.signal)
      .then(result => {
        if (taskItem.controller.signal.aborted) {
          // 任务被取消了
          this.stats.cancelledTasks++;
          console.log(`Task ${taskItem.id} was cancelled during execution`);
        } else {
          this.stats.completedTasks++;
          taskItem.result = result;
          console.log(`Task ${taskItem.id} completed`);
        }
      })
      .catch(error => {
        if (taskItem.controller.signal.aborted) {
          this.stats.cancelledTasks++;
          console.log(`Task ${taskItem.id} was cancelled during execution`);
        } else {
          this.stats.failedTasks++;
          taskItem.error = error;
          console.error(`Task ${taskItem.id} failed:`, error);
        }
      })
      .finally(() => {
        this.runningTasks--;
        this.taskControllers.delete(taskItem.id);
        this.executeNext();
      });
  }

  cancel(taskId) {
    // 从队列中移除
    const queueIndex = this.taskQueue.findIndex(task => task.id === taskId);
    if (queueIndex !== -1) {
      this.taskQueue.splice(queueIndex, 1);
      this.taskControllers.delete(taskId);
      this.stats.cancelledTasks++;
      console.log(`Task ${taskId} cancelled from queue`);
      return true;
    }
    
    // 尝试取消正在运行的任务
    const controller = this.taskControllers.get(taskId);
    if (controller) {
      controller.abort();
      console.log(`Task ${taskId} cancelled during execution`);
      return true;
    }
    
    console.warn(`Task ${taskId} not found`);
    return false;
  }

  getStats() {
    return {
      ...this.stats,
      runningTasks: this.runningTasks,
      queuedTasks: this.taskQueue.length,
      maxConcurrency: this.maxConcurrency
    };
  }

  async waitForAll() {
    return new Promise((resolve) => {
      const checkCompletion = () => {
        if (this.runningTasks === 0 && this.taskQueue.length === 0) {
          resolve();
        } else {
          setTimeout(checkCompletion, 10);
        }
      };
      checkCompletion();
    });
  }
}
```

这个调度器实现了所有要求的功能：
- 支持设置最大并发数
- 支持任务优先级
- 可取消未执行任务（高级版本还支持取消执行中任务）
- 提供详细的统计信息
