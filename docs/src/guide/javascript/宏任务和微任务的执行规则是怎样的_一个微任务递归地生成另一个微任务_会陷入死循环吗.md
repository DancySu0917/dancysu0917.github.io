# 宏任务和微任务的执行规则是怎样的？一个微任务递归地生成另一个微任务，会陷入死循环吗？（高薪常问）
### 标准答案

JavaScript事件循环中，宏任务（Macro Task）和微任务（Micro Task）的执行规则是：1) 执行当前宏任务；2) 执行所有可执行的微任务；3) 执行下一个宏任务；4) 重复此过程。常见的宏任务包括setTimeout、setInterval、I/O等，微任务包括Promise.then、MutationObserver等。如果一个微任务递归地生成另一个微任务，理论上会造成死循环，但现代浏览器有保护机制防止这种情况。

### 深入理解

JavaScript是单线程语言，事件循环机制协调了同步代码、异步回调、宏任务和微任务的执行顺序。

**1. 宏任务和微任务的分类：**
```javascript
// 宏任务 (Macro Task)
console.log('1. 同步代码开始');

setTimeout(() => {
    console.log('2. setTimeout (宏任务)');
}, 0);

// 微任务 (Micro Task)
Promise.resolve().then(() => {
    console.log('3. Promise.then (微任务)');
});

console.log('4. 同步代码结束');

// 输出顺序: 1 -> 4 -> 3 -> 2
```

**2. 事件循环执行规则：**
```javascript
// 演示事件循环的执行顺序
console.log('start');

setTimeout(() => {
    console.log('setTimeout 1');
    Promise.resolve().then(() => {
        console.log('Promise 3');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
});

setTimeout(() => {
    console.log('setTimeout 2');
    Promise.resolve().then(() => {
        console.log('Promise 4');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 2');
});

console.log('end');

// 输出顺序:
// start
// end
// Promise 1
// Promise 2
// setTimeout 1
// Promise 3
// setTimeout 2
// Promise 4
```

**3. 微任务递归生成问题：**
```javascript
// 微任务递归生成可能导致的问题
function createRecursiveMicrotasks() {
    console.log('开始执行同步代码');
    
    // 第一个Promise.then产生微任务
    Promise.resolve().then(() => {
        console.log('微任务 1');
        // 这个微任务又产生新的微任务
        Promise.resolve().then(() => {
            console.log('微任务 2');
            // 这个微任务又产生新的微任务
            Promise.resolve().then(() => {
                console.log('微任务 3');
                // 无限递归生成微任务...
                Promise.resolve().then(() => {
                    console.log('微任务 4');
                    // 继续递归...
                });
            });
        });
    });
    
    console.log('同步代码结束');
}

createRecursiveMicrotasks();

// 输出:
// 开始执行同步代码
// 同步代码结束
// 微任务 1
// 微任务 2
// 微任务 3
// 微任务 4
// ... (持续执行，直到栈溢出或浏览器限制)
```

**4. 浏览器保护机制：**
```javascript
// 现代浏览器会限制微任务队列的执行次数，防止无限循环
let count = 0;

function potentiallyInfiniteMicrotask() {
    count++;
    console.log(`微任务执行第 ${count} 次`);
    
    // 检查执行次数，避免无限递归
    if (count < 1000) { // 设置一个合理的限制
        Promise.resolve().then(potentiallyInfiniteMicrotask);
    } else {
        console.log('达到执行次数限制，停止递归');
    }
}

Promise.resolve().then(potentiallyInfiniteMicrotask);
```

**5. 宏任务和微任务的详细分类：**
```javascript
// 宏任务示例
console.log('=== 宏任务示例 ===');
setTimeout(() => console.log('setTimeout'), 0);
setImmediate(() => console.log('setImmediate')); // Node.js环境
requestAnimationFrame(() => console.log('requestAnimationFrame')); // 浏览器环境
setInterval(() => console.log('setInterval'), 1000);

// 微任务示例
console.log('=== 微任务示例 ===');
Promise.resolve().then(() => console.log('Promise 1'));
Promise.resolve().then(() => console.log('Promise 2'));
queueMicrotask(() => console.log('queueMicrotask'));
Object.observe = Object.observe || function() {}; // 旧的观察方法
if (typeof MutationObserver !== 'undefined') {
    const observer = new MutationObserver(() => console.log('MutationObserver'));
    const textNode = document.createTextNode('1');
    observer.observe(textNode, { characterData: true });
    textNode.data = '2'; // 触发MutationObserver
}
```

**6. 实际应用场景：**
```javascript
// 使用微任务实现nextTick功能
function nextTick(callback) {
    Promise.resolve().then(callback);
}

// 使用宏任务实现延迟执行
function later(callback) {
    setTimeout(callback, 0);
}

// 比较执行优先级
console.log('同步代码');

nextTick(() => {
    console.log('nextTick (微任务)');
});

later(() => {
    console.log('later (宏任务)');
});

Promise.resolve().then(() => {
    console.log('Promise (微任务)');
});

console.log('同步代码结束');

// 输出:
// 同步代码
// 同步代码结束
// nextTick (微任务)
// Promise (微任务)
// later (宏任务)
```

**7. 防止微任务死循环的策略：**
```javascript
// 策略1: 设置计数器限制
class SafeMicrotaskQueue {
    constructor(maxIterations = 1000) {
        this.count = 0;
        this.maxIterations = maxIterations;
    }
    
    add(task) {
        if (this.count >= this.maxIterations) {
            console.warn('达到微任务执行次数上限');
            return;
        }
        
        this.count++;
        Promise.resolve().then(() => {
            task();
            this.count--; // 任务执行完成后减少计数
        });
    }
}

// 策略2: 使用宏任务替代部分微任务
function safeRecursiveTask() {
    let iteration = 0;
    const maxIterations = 100;
    
    function execute() {
        if (iteration >= maxIterations) return;
        
        console.log(`执行第 ${iteration} 次`);
        iteration++;
        
        // 每执行10次后使用宏任务，给其他任务执行的机会
        if (iteration % 10 === 0) {
            setTimeout(execute, 0); // 使用宏任务
        } else {
            Promise.resolve().then(execute); // 使用微任务
        }
    }
    
    execute();
}

// 策略3: 异步分批处理
function batchProcess(items, processor, batchSize = 10) {
    let index = 0;
    
    function processBatch() {
        const batch = items.slice(index, index + batchSize);
        batch.forEach(processor);
        index += batchSize;
        
        if (index < items.length) {
            // 使用宏任务继续处理下一批，避免长时间阻塞
            setTimeout(processBatch, 0);
        }
    }
    
    processBatch();
}
```

**8. 完整的事件循环示例：**
```javascript
console.log('1. 同步代码开始');

new Promise(resolve => {
    console.log('2. 同步Promise构造器');
    resolve('resolved');
}).then(value => {
    console.log('3. 微任务1:', value);
    return Promise.resolve('chained').then(value2 => {
        console.log('4. 微任务2:', value2);
        // 递归微任务
        return Promise.resolve('recursive').then(value3 => {
            console.log('5. 微任务3:', value3);
        });
    });
});

setTimeout(() => {
    console.log('6. 宏任务1');
    Promise.resolve().then(() => {
        console.log('7. 宏任务中的微任务');
    });
}, 0);

console.log('8. 同步代码结束');

// 输出:
// 1. 同步代码开始
// 2. 同步Promise构造器
// 8. 同步代码结束
// 3. 微任务1: resolved
// 4. 微任务2: chained
// 5. 微任务3: recursive
// 6. 宏任务1
// 7. 宏任务中的微任务
```

**总结：**
1. 宏任务和微任务的执行顺序是：同步代码 → 微任务队列（全部执行）→ 下一个宏任务 → 微任务队列（全部执行）→ ...
2. 微任务优先级高于宏任务
3. 如果微任务递归生成微任务，理论上会造成死循环
4. 现代浏览器有保护机制，但仍然应该避免编写可能导致无限递归的代码
5. 合理使用宏任务和微任务可以优化应用性能