# (针对性能优化) 有哪些成熟的性能指标，以及如何去检测这些指标？（了解）

**题目**: (针对性能优化) 有哪些成熟的性能指标，以及如何去检测这些指标？（了解）

**答案**:

现代前端性能优化有多个成熟且被广泛认可的性能指标，主要分为核心 Web Vitals 和其他重要指标两大类：

## 一、核心 Web Vitals（核心网页指标）

### 1. LCP (Largest Contentful Paint) - 最大内容绘制
- **定义**: 页面中最大内容元素的渲染时间，代表页面主要内容的加载速度
- **目标**: ≤ 2.5 秒
- **检测方法**:
  ```javascript
  // 使用 PerformanceObserver 检测 LCP
  let lcpValue = 0;
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries();
    const lastEntry = entries[entries.length - 1];
    lcpValue = lastEntry.startTime;
    console.log('LCP:', lcpValue);
    
    // 发送数据到分析服务
    // analytics.send('LCP', lcpValue);
  }).observe({entryTypes: ['largest-contentful-paint']});
  ```

### 2. FID (First Input Delay) - 首次输入延迟
- **定义**: 用户首次与页面交互到浏览器实际响应之间的时间差
- **目标**: ≤ 100 毫秒
- **检测方法**:
  ```javascript
  // 检测 FID
  let fidValue = 0;
  new PerformanceObserver((entryList) => {
    const firstInput = entryList.getEntries()[0];
    fidValue = firstInput.processingStart - firstInput.startTime;
    console.log('FID:', fidValue);
    
    // 发送数据到分析服务
    // analytics.send('FID', fidValue);
  }).observe({entryTypes: ['first-input']});
  ```

### 3. CLS (Cumulative Layout Shift) - 累积布局偏移
- **定义**: 页面加载过程中所有意外布局偏移的累积分数
- **目标**: ≤ 0.1
- **检测方法**:
  ```javascript
  // 检测 CLS
  let clsValue = 0;
  new PerformanceObserver((entryList) => {
    for (const entry of entryList.getEntries()) {
      // 只计算非最近用户输入的布局偏移
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    }
    console.log('CLS:', clsValue);
    
    // 发送数据到分析服务
    // analytics.send('CLS', clsValue);
  }).observe({entryTypes: ['layout-shift']});
  ```

## 二、其他重要性能指标

### 1. FCP (First Contentful Paint) - 首次内容绘制
- **定义**: 页面首次绘制任何内容（文本、图片、SVG 等）的时间
- **目标**: ≤ 1.8 秒
- **检测方法**:
  ```javascript
  // 检测 FCP
  new PerformanceObserver((entryList) => {
    const fcpEntry = entryList.getEntriesByType('paint')[0];
    if (fcpEntry) {
      console.log('FCP:', fcpEntry.startTime);
      
      // 发送数据到分析服务
      // analytics.send('FCP', fcpEntry.startTime);
    }
  }).observe({entryTypes: ['paint']});
  ```

### 2. FP (First Paint) - 首次绘制
- **定义**: 页面首次发生绘制的时间点（不包括导航）
- **检测方法**:
  ```javascript
  // 检测 FP
  new PerformanceObserver((entryList) => {
    const fpEntry = entryList.getEntriesByType('paint')[0];
    if (fpEntry && fpEntry.name === 'first-paint') {
      console.log('FP:', fpEntry.startTime);
      
      // 发送数据到分析服务
      // analytics.send('FP', fpEntry.startTime);
    }
  }).observe({entryTypes: ['paint']});
  ```

### 3. TTFB (Time to First Byte) - 首字节时间
- **定义**: 从请求开始到接收到第一个字节响应的时间
- **目标**: ≤ 100 毫秒
- **检测方法**:
  ```javascript
  // 检测 TTFB
  window.addEventListener('load', () => {
    const navigation = performance.getEntriesByType('navigation')[0];
    const ttfb = navigation.responseStart - navigation.requestStart;
    console.log('TTFB:', ttfb);
    
    // 发送数据到分析服务
    // analytics.send('TTFB', ttfb);
  });
  ```

### 4. DCL (DOMContentLoaded) - DOM 内容加载完成
- **定义**: HTML 文档完全加载和解析完成的时间
- **检测方法**:
  ```javascript
  // 检测 DCL
  document.addEventListener('DOMContentLoaded', () => {
    const dclTime = performance.now();
    console.log('DCL:', dclTime);
    
    // 或者通过 Performance API 获取
    const navigation = performance.getEntriesByType('navigation')[0];
    const dcl = navigation.domContentLoadedEventEnd - navigation.fetchStart;
    console.log('DCL (from Performance API):', dcl);
  });
  ```

## 三、检测工具和方法

### 1. 浏览器开发者工具
- **Performance 面板**: 详细的时间线分析
- **Lighthouse**: 综合性能评估
- **Network 面板**: 网络请求分析

### 2. JavaScript API
- **Performance API**: 程序化获取性能数据
- **Navigation Timing API**: 页面导航性能数据
- **Paint Timing API**: 渲染性能数据

### 3. 第三方工具
- **Google Analytics 4**: 实际用户监控 (RUM)
- **Web Vitals 扩展**: 浏览器扩展实时显示指标
- **PageSpeed Insights**: 页面性能分析
- **WebPageTest**: 详细性能分析

### 4. 完整的性能监控实现
```javascript
// 综合性能监控
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.init();
  }
  
  init() {
    // 监控 LCP
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
    }).observe({entryTypes: ['largest-contentful-paint']});
    
    // 监控 FID
    new PerformanceObserver((entryList) => {
      const firstInput = entryList.getEntries()[0];
      if (firstInput) {
        this.metrics.fid = firstInput.processingStart - firstInput.startTime;
      }
    }).observe({entryTypes: ['first-input']});
    
    // 监控 CLS
    let clsValue = 0;
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      this.metrics.cls = clsValue;
    }).observe({entryTypes: ['layout-shift']});
    
    // 监控 FCP
    new PerformanceObserver((entryList) => {
      const fcpEntry = entryList.getEntriesByType('paint')[0];
      if (fcpEntry && fcpEntry.name === 'first-contentful-paint') {
        this.metrics.fcp = fcpEntry.startTime;
      }
    }).observe({entryTypes: ['paint']});
  }
  
  getMetrics() {
    // 获取 TTFB
    const navigation = performance.getEntriesByType('navigation')[0];
    if (navigation) {
      this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
    }
    
    return this.metrics;
  }
  
  report() {
    const metrics = this.getMetrics();
    console.log('Performance Metrics:', metrics);
    
    // 发送到分析服务
    // this.sendToAnalytics(metrics);
  }
}

// 使用示例
const monitor = new PerformanceMonitor();
// 在适当时候报告性能数据
window.addEventListener('load', () => {
  setTimeout(() => {
    monitor.report();
  }, 0);
});
```

通过这些指标和检测方法，可以全面了解页面性能状况，为优化提供数据支持。
