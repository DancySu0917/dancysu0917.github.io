# 项目里使用动态表单生成评分配置，那如果表单结构是深嵌套的，并且会动态增减字段，如何设计渲染机制来保证性能？（了解）

**题目**: 项目里使用动态表单生成评分配置，那如果表单结构是深嵌套的，并且会动态增减字段，如何设计渲染机制来保证性能？（了解）

## 标准答案

处理深嵌套动态表单的渲染机制，主要考虑以下方案：

1. **虚拟化渲染**：只渲染可视区域内的表单元素
2. **按需渲染**：使用组件懒加载和条件渲染
3. **状态管理优化**：使用不可变数据结构和路径索引
4. **防抖节流**：对频繁的表单变化进行优化
5. **组件复用**：使用组件池和模板复用机制
6. **分片渲染**：将渲染任务分解为小块，避免阻塞主线程

## 深入分析

### 1. 深嵌套表单的性能挑战

深嵌套表单面临的主要性能问题包括：

- **渲染复杂度**：嵌套层级越深，渲染树越复杂
- **状态更新**：一个字段变化可能影响整个表单树
- **内存占用**：大量表单元素会占用较多内存
- **事件处理**：深层嵌套的事件冒泡可能影响性能
- **响应延迟**：复杂表单可能导致UI响应不及时

### 2. 渲染优化策略

#### 2.1 虚拟化渲染
只渲染当前可见的表单部分，隐藏部分用占位符代替，减少DOM节点数量。

#### 2.2 按需渲染
使用React的lazy/Suspense或Vue的动态组件，只在需要时渲染特定表单部分。

#### 2.3 状态管理优化
使用不可变数据结构（如Immutable.js）或ES6的不可变更新模式，精确追踪变化，避免不必要的重渲染。

#### 2.4 路径索引机制
为每个表单字段建立路径索引，快速定位和更新特定字段，避免全树遍历。

### 3. 动态增减字段的处理

动态增减字段需要考虑：

- **唯一标识**：为每个字段生成唯一ID
- **路径维护**：动态更新字段路径
- **状态同步**：确保UI和数据状态一致
- **生命周期管理**：正确处理组件的挂载和卸载

### 4. 性能监控和优化

- **渲染时间监控**：记录组件渲染时间
- **内存使用监控**：监控内存占用情况
- **性能瓶颈定位**：使用性能分析工具定位问题

## 代码实现

### 1. 基础动态表单组件

```javascript
// 动态表单渲染器
class DynamicFormRenderer {
  constructor(schema, data, onChange) {
    this.schema = schema;
    this.data = data;
    this.onChange = onChange;
    this.componentCache = new Map(); // 组件缓存
    this.fieldPathMap = new Map();   // 路径映射
  }

  // 渲染表单
  render(container) {
    this.container = container;
    this.container.innerHTML = '';
    
    // 构建路径映射
    this.buildPathMap(this.schema, []);
    
    // 渲染表单
    this.renderSchema(this.schema, this.container, []);
  }

  // 构建路径映射
  buildPathMap(schema, path) {
    if (schema.type === 'object') {
      // 处理对象类型字段
      if (schema.properties) {
        Object.keys(schema.properties).forEach(key => {
          const newPath = [...path, key];
          const fieldSchema = schema.properties[key];
          this.fieldPathMap.set(fieldSchema.id || fieldSchema.key, newPath);
          this.buildPathMap(fieldSchema, newPath);
        });
      }
    } else if (schema.type === 'array') {
      // 处理数组类型字段（动态增减）
      if (schema.items) {
        // 为数组项预留路径
        this.fieldPathMap.set(schema.id || schema.key, path);
        this.buildPathMap(schema.items, [...path, 0]); // 使用0作为占位符
      }
    } else {
      // 叶子节点
      this.fieldPathMap.set(schema.id || schema.key, path);
    }
  }

  // 渲染表单结构
  renderSchema(schema, container, path) {
    if (schema.type === 'object') {
      return this.renderObject(schema, container, path);
    } else if (schema.type === 'array') {
      return this.renderArray(schema, container, path);
    } else {
      return this.renderField(schema, container, path);
    }
  }

  // 渲染对象类型
  renderObject(schema, container, path) {
    const fieldContainer = document.createElement('div');
    fieldContainer.className = 'form-object';
    
    if (schema.title) {
      const title = document.createElement('h3');
      title.textContent = schema.title;
      fieldContainer.appendChild(title);
    }

    if (schema.properties) {
      Object.keys(schema.properties).forEach(key => {
        const fieldSchema = schema.properties[key];
        const fieldPath = [...path, key];
        const fieldElement = document.createElement('div');
        fieldElement.className = 'form-field';
        fieldContainer.appendChild(fieldElement);
        
        this.renderSchema(fieldSchema, fieldElement, fieldPath);
      });
    }

    container.appendChild(fieldContainer);
    return fieldContainer;
  }

  // 渲染数组类型（动态增减）
  renderArray(schema, container, path) {
    const arrayContainer = document.createElement('div');
    arrayContainer.className = 'form-array';
    
    if (schema.title) {
      const title = document.createElement('h3');
      title.textContent = schema.title;
      arrayContainer.appendChild(title);
    }

    // 获取当前数组数据
    const arrayData = this.getNestedValue(this.data, path) || [];
    
    // 渲染数组项
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'array-items';
    arrayContainer.appendChild(itemsContainer);

    arrayData.forEach((item, index) => {
      this.renderArrayItem(schema, itemsContainer, path, index, item);
    });

    // 添加按钮
    const addButton = document.createElement('button');
    addButton.textContent = '添加项目';
    addButton.onclick = () => {
      this.addItem(schema, path);
    };
    arrayContainer.appendChild(addButton);

    container.appendChild(arrayContainer);
    return arrayContainer;
  }

  // 渲染数组项
  renderArrayItem(schema, container, path, index, itemData) {
    const itemContainer = document.createElement('div');
    itemContainer.className = 'array-item';
    
    const itemPath = [...path, index];
    
    // 渲染数组项内容
    const contentContainer = document.createElement('div');
    contentContainer.className = 'array-item-content';
    itemContainer.appendChild(contentContainer);
    
    this.renderSchema(schema.items, contentContainer, itemPath);

    // 删除按钮
    const deleteButton = document.createElement('button');
    deleteButton.textContent = '删除';
    deleteButton.onclick = () => {
      this.removeItem(schema, path, index);
    };
    itemContainer.appendChild(deleteButton);

    container.appendChild(itemContainer);
  }

  // 渲染字段
  renderField(schema, container, path) {
    const fieldContainer = document.createElement('div');
    fieldContainer.className = 'field-container';
    
    // 字段标签
    if (schema.title) {
      const label = document.createElement('label');
      label.textContent = schema.title;
      fieldContainer.appendChild(label);
    }

    // 根据字段类型渲染不同组件
    let fieldElement;
    switch (schema.fieldType || schema.type) {
      case 'text':
      case 'string':
        fieldElement = this.renderTextField(schema, path);
        break;
      case 'number':
        fieldElement = this.renderNumberField(schema, path);
        break;
      case 'boolean':
        fieldElement = this.renderBooleanField(schema, path);
        break;
      case 'select':
        fieldElement = this.renderSelectField(schema, path);
        break;
      case 'rating':
        fieldElement = this.renderRatingField(schema, path); // 评分字段
        break;
      default:
        fieldElement = this.renderDefaultField(schema, path);
    }

    fieldContainer.appendChild(fieldElement);
    container.appendChild(fieldContainer);
    
    return fieldContainer;
  }

  // 渲染文本字段
  renderTextField(schema, path) {
    const input = document.createElement('input');
    input.type = 'text';
    input.value = this.getNestedValue(this.data, path) || '';
    
    input.addEventListener('input', (e) => {
      this.updateNestedValue(path, e.target.value);
      this.onChange && this.onChange(this.data);
    });
    
    return input;
  }

  // 渲染评分字段
  renderRatingField(schema, path) {
    const ratingContainer = document.createElement('div');
    ratingContainer.className = 'rating-field';
    
    const maxRating = schema.max || 5;
    const currentValue = this.getNestedValue(this.data, path) || 0;
    
    for (let i = 1; i <= maxRating; i++) {
      const star = document.createElement('span');
      star.textContent = '★';
      star.style.cursor = 'pointer';
      star.style.color = i <= currentValue ? '#ffd700' : '#ddd';
      star.onclick = () => {
        this.updateNestedValue(path, i);
        this.onChange && this.onChange(this.data);
        this.updateStars(ratingContainer, i, maxRating);
      };
      ratingContainer.appendChild(star);
    }
    
    return ratingContainer;
  }

  // 更新评分显示
  updateStars(container, rating, maxRating) {
    const stars = container.querySelectorAll('span');
    stars.forEach((star, index) => {
      star.style.color = index + 1 <= rating ? '#ffd700' : '#ddd';
    });
  }

  // 获取嵌套值
  getNestedValue(obj, path) {
    return path.reduce((current, key) => current && current[key], obj);
  }

  // 更新嵌套值
  updateNestedValue(path, value) {
    let current = this.data;
    
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      if (current[key] === undefined) {
        current[key] = {};
      }
      current = current[key];
    }
    
    current[path[path.length - 1]] = value;
  }

  // 添加数组项
  addItem(schema, path) {
    const arrayData = this.getNestedValue(this.data, path) || [];
    const newItem = this.getDefaultValue(schema.items);
    arrayData.push(newItem);
    this.updateNestedValue(path, arrayData);
    
    // 重新渲染数组
    this.rerenderArray(schema, path);
    this.onChange && this.onChange(this.data);
  }

  // 删除数组项
  removeItem(schema, path, index) {
    const arrayData = this.getNestedValue(this.data, path) || [];
    arrayData.splice(index, 1);
    this.updateNestedValue(path, arrayData);
    
    // 重新渲染数组
    this.rerenderArray(schema, path);
    this.onChange && this.onChange(this.data);
  }

  // 重新渲染数组
  rerenderArray(schema, path) {
    const arrayElements = this.container.querySelectorAll('.form-array');
    arrayElements.forEach(element => {
      // 找到对应的数组容器
      if (element.classList.contains('form-array')) {
        // 这里需要更精确的匹配逻辑
        element.innerHTML = '';
        this.renderArray(schema, element, path);
      }
    });
  }

  // 获取默认值
  getDefaultValue(schema) {
    switch (schema.type) {
      case 'string':
        return schema.default || '';
      case 'number':
        return schema.default || 0;
      case 'boolean':
        return schema.default || false;
      case 'object':
        const obj = {};
        if (schema.properties) {
          Object.keys(schema.properties).forEach(key => {
            obj[key] = this.getDefaultValue(schema.properties[key]);
          });
        }
        return obj;
      case 'array':
        return [];
      default:
        return null;
    }
  }

  // 渲染默认字段
  renderDefaultField(schema, path) {
    const input = document.createElement('input');
    input.type = 'text';
    input.value = this.getNestedValue(this.data, path) || '';
    
    input.addEventListener('input', (e) => {
      this.updateNestedValue(path, e.target.value);
      this.onChange && this.onChange(this.data);
    });
    
    return input;
  }
}
```

### 2. React 实现的高性能动态表单

```jsx
import React, { useState, useCallback, useMemo, memo } from 'react';

// 高性能动态表单组件
const DynamicForm = ({ schema, initialData = {}, onChange }) => {
  const [formData, setFormData] = useState(initialData);

  // 使用 useCallback 优化事件处理函数
  const handleFieldChange = useCallback((path, value) => {
    setFormData(prevData => {
      const newData = { ...prevData };
      setNestedValue(newData, path, value);
      onChange && onChange(newData);
      return newData;
    });
  }, [onChange]);

  // 设置嵌套值的辅助函数
  const setNestedValue = (obj, path, value) => {
    let current = obj;
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      if (current[key] === undefined) {
        current[key] = {};
      }
      current = current[key];
    }
    current[path[path.length - 1]] = value;
  };

  // Memoized schema renderer
  const renderSchema = useCallback((schema, path = []) => {
    if (schema.type === 'object') {
      return (
        <ObjectField
          key={path.join('.')}
          schema={schema}
          path={path}
          formData={formData}
          onChange={handleFieldChange}
        />
      );
    } else if (schema.type === 'array') {
      return (
        <ArrayField
          key={path.join('.')}
          schema={schema}
          path={path}
          formData={formData}
          onChange={handleFieldChange}
        />
      );
    } else {
      return (
        <Field
          key={path.join('.')}
          schema={schema}
          path={path}
          formData={formData}
          onChange={handleFieldChange}
        />
      );
    }
  }, [formData, handleFieldChange]);

  return (
    <div className="dynamic-form">
      {renderSchema(schema)}
    </div>
  );
};

// 对象字段组件
const ObjectField = memo(({ schema, path, formData, onChange }) => {
  if (!schema.properties) return null;

  return (
    <div className="form-object">
      {schema.title && <h3>{schema.title}</h3>}
      {Object.keys(schema.properties).map(key => {
        const fieldSchema = schema.properties[key];
        const fieldPath = [...path, key];
        return (
          <div key={key} className="form-field">
            {renderSchema(fieldSchema, fieldPath)}
          </div>
        );
      })}
    </div>
  );
});

// 数组字段组件
const ArrayField = memo(({ schema, path, formData, onChange }) => {
  const arrayData = getNestedValue(formData, path) || [];
  
  const addItem = () => {
    const newItem = getDefaultValue(schema.items);
    const newArrayData = [...arrayData, newItem];
    onChange(path, newArrayData);
  };

  const removeItem = (index) => {
    const newArrayData = arrayData.filter((_, i) => i !== index);
    onChange(path, newArrayData);
  };

  const moveItem = (fromIndex, toIndex) => {
    const newArrayData = [...arrayData];
    const item = newArrayData[fromIndex];
    newArrayData.splice(fromIndex, 1);
    newArrayData.splice(toIndex, 0, item);
    onChange(path, newArrayData);
  };

  return (
    <div className="form-array">
      {schema.title && <h3>{schema.title}</h3>}
      <div className="array-items">
        {arrayData.map((item, index) => {
          const itemPath = [...path, index];
          return (
            <div key={index} className="array-item">
              <div className="array-item-content">
                {renderSchema(schema.items, itemPath)}
              </div>
              <div className="array-item-actions">
                <button onClick={() => removeItem(index)}>删除</button>
                {index > 0 && (
                  <button onClick={() => moveItem(index, index - 1)}>上移</button>
                )}
                {index < arrayData.length - 1 && (
                  <button onClick={() => moveItem(index, index + 1)}>下移</button>
                )}
              </div>
            </div>
          );
        })}
      </div>
      <button onClick={addItem}>添加项目</button>
    </div>
  );
});

// 通用字段组件
const Field = memo(({ schema, path, formData, onChange }) => {
  const value = getNestedValue(formData, path);

  const handleChange = (newValue) => {
    onChange(path, newValue);
  };

  // 根据字段类型渲染不同的输入组件
  switch (schema.fieldType || schema.type) {
    case 'text':
    case 'string':
      return (
        <div className="field-container">
          {schema.title && <label>{schema.title}</label>}
          <input
            type="text"
            value={value || ''}
            onChange={(e) => handleChange(e.target.value)}
          />
        </div>
      );
    
    case 'number':
      return (
        <div className="field-container">
          {schema.title && <label>{schema.title}</label>}
          <input
            type="number"
            value={value || 0}
            onChange={(e) => handleChange(Number(e.target.value))}
          />
        </div>
      );
    
    case 'boolean':
      return (
        <div className="field-container">
          <label>
            <input
              type="checkbox"
              checked={!!value}
              onChange={(e) => handleChange(e.target.checked)}
            />
            {schema.title}
          </label>
        </div>
      );
    
    case 'select':
      return (
        <div className="field-container">
          {schema.title && <label>{schema.title}</label>}
          <select
            value={value || ''}
            onChange={(e) => handleChange(e.target.value)}
          >
            {schema.options?.map(option => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        </div>
      );
    
    case 'rating':
      return (
        <RatingField
          schema={schema}
          value={value}
          onChange={handleChange}
          title={schema.title}
        />
      );
    
    default:
      return (
        <div className="field-container">
          {schema.title && <label>{schema.title}</label>}
          <input
            type="text"
            value={value || ''}
            onChange={(e) => handleChange(e.target.value)}
          />
        </div>
      );
  }
});

// 评分组件
const RatingField = memo(({ schema, value = 0, onChange, title }) => {
  const maxRating = schema.max || 5;
  
  const handleClick = (rating) => {
    onChange(rating);
  };

  return (
    <div className="field-container">
      {title && <label>{title}</label>}
      <div className="rating-field">
        {Array.from({ length: maxRating }, (_, i) => {
          const rating = i + 1;
          return (
            <span
              key={rating}
              className={`star ${rating <= value ? 'filled' : ''}`}
              onClick={() => handleClick(rating)}
              style={{
                cursor: 'pointer',
                color: rating <= value ? '#ffd700' : '#ddd',
                fontSize: '20px'
              }}
            >
              ★
            </span>
          );
        })}
        <span className="rating-value">{value}/{maxRating}</span>
      </div>
    </div>
  );
});

// 辅助函数
const getNestedValue = (obj, path) => {
  return path.reduce((current, key) => current && current[key], obj);
};

const getDefaultValue = (schema) => {
  switch (schema.type) {
    case 'string':
      return schema.default || '';
    case 'number':
      return schema.default || 0;
    case 'boolean':
      return schema.default || false;
    case 'object':
      const obj = {};
      if (schema.properties) {
        Object.keys(schema.properties).forEach(key => {
          obj[key] = getDefaultValue(schema.properties[key]);
        });
      }
      return obj;
    case 'array':
      return [];
    default:
      return null;
  }
};

// 使用示例
const App = () => {
  const formSchema = {
    type: 'object',
    title: '评分配置表单',
    properties: {
      projectName: {
        type: 'string',
        title: '项目名称',
        fieldType: 'text'
      },
      sections: {
        type: 'array',
        title: '评分章节',
        items: {
          type: 'object',
          properties: {
            sectionName: {
              type: 'string',
              title: '章节名称'
            },
            weight: {
              type: 'number',
              title: '权重',
              default: 1
            },
            criteria: {
              type: 'array',
              title: '评分标准',
              items: {
                type: 'object',
                properties: {
                  criterionName: {
                    type: 'string',
                    title: '标准名称'
                  },
                  rating: {
                    type: 'number',
                    title: '评分',
                    fieldType: 'rating',
                    max: 10
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  const handleFormChange = (data) => {
    console.log('表单数据变化:', data);
  };

  return (
    <DynamicForm 
      schema={formSchema} 
      initialData={{
        projectName: '项目A',
        sections: [
          {
            sectionName: '技术实现',
            weight: 0.4,
            criteria: [
              { criterionName: '代码质量', rating: 8 },
              { criterionName: '架构设计', rating: 9 }
            ]
          }
        ]
      }}
      onChange={handleFormChange}
    />
  );
};
```

### 3. 虚拟化渲染优化

```javascript
// 虚拟化表单渲染器
class VirtualizedFormRenderer {
  constructor(schema, data, onChange, options = {}) {
    this.schema = schema;
    this.data = data;
    this.onChange = onChange;
    this.options = {
      itemHeight: options.itemHeight || 50,
      buffer: options.buffer || 5,
      containerHeight: options.containerHeight || 400,
      ...options
    };
    
    this.visibleItems = [];
    this.scrollTop = 0;
    this.itemHeights = new Map();
  }

  render(container) {
    this.container = container;
    this.container.style.height = this.options.containerHeight + 'px';
    this.container.style.overflow = 'auto';
    this.container.style.position = 'relative';
    
    // 计算所有表单项的布局
    this.calculateLayout();
    
    // 创建虚拟滚动容器
    this.createVirtualContainer();
    
    // 绑定滚动事件
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    
    // 初始渲染
    this.handleScroll();
  }

  // 计算布局
  calculateLayout() {
    this.itemLayouts = [];
    this.calculateItemLayout(this.schema, [], 0);
  }

  calculateItemLayout(schema, path, currentTop) {
    if (schema.type === 'object') {
      // 对象类型占位高度
      this.itemLayouts.push({
        path,
        schema,
        top: currentTop,
        height: 30, // 标题高度
        type: 'object-title'
      });
      
      currentTop += 30;
      
      if (schema.properties) {
        for (const key in schema.properties) {
          const fieldSchema = schema.properties[key];
          const fieldPath = [...path, key];
          const { height, newTop } = this.calculateItemLayout(fieldSchema, fieldPath, currentTop);
          currentTop = newTop;
        }
      }
    } else if (schema.type === 'array') {
      // 数组类型占位高度
      this.itemLayouts.push({
        path,
        schema,
        top: currentTop,
        height: 30,
        type: 'array-title'
      });
      
      currentTop += 30;
      
      // 预估数组项高度
      const arrayData = this.getNestedValue(this.data, path) || [];
      if (schema.items && arrayData.length > 0) {
        // 递归计算数组项布局
        for (let i = 0; i < arrayData.length; i++) {
          const itemPath = [...path, i];
          const { height, newTop } = this.calculateItemLayout(schema.items, itemPath, currentTop);
          currentTop = newTop;
          
          // 添加操作按钮高度
          this.itemLayouts.push({
            path: itemPath,
            schema: { type: 'actions' },
            top: currentTop,
            height: 30,
            type: 'array-actions'
          });
          currentTop += 30;
        }
      }
    } else {
      // 普通字段
      const height = this.getFieldHeight(schema);
      this.itemLayouts.push({
        path,
        schema,
        top: currentTop,
        height,
        type: 'field'
      });
      currentTop += height;
    }
    
    return { height: currentTop - this.itemLayouts[this.itemLayouts.length - 1].top, newTop: currentTop };
  }

  // 获取字段高度
  getFieldHeight(schema) {
    switch (schema.fieldType || schema.type) {
      case 'rating':
        return 60; // 评分组件需要更多空间
      case 'textarea':
        return 100;
      default:
        return 50;
    }
  }

  // 创建虚拟容器
  createVirtualContainer() {
    this.contentContainer = document.createElement('div');
    this.contentContainer.style.position = 'relative';
    this.contentContainer.style.height = this.getTotalHeight() + 'px';
    this.container.appendChild(this.contentContainer);
    
    this.visibleContainer = document.createElement('div');
    this.visibleContainer.style.position = 'absolute';
    this.visibleContainer.style.top = '0px';
    this.visibleContainer.style.width = '100%';
    this.contentContainer.appendChild(this.visibleContainer);
  }

  // 处理滚动
  handleScroll() {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.options.containerHeight;
    
    // 计算可视区域
    const startTop = scrollTop - this.options.buffer * this.options.itemHeight;
    const endTop = scrollTop + containerHeight + this.options.buffer * this.options.itemHeight;
    
    // 找到可视区域内的项目
    const visibleItems = this.itemLayouts.filter(item => 
      item.top + item.height >= startTop && item.top <= endTop
    );
    
    // 渲染可见项目
    this.renderVisibleItems(visibleItems, scrollTop);
  }

  // 渲染可见项目
  renderVisibleItems(visibleItems, scrollTop) {
    // 清空现有内容
    this.visibleContainer.innerHTML = '';
    
    visibleItems.forEach(item => {
      const itemElement = this.createItemElement(item);
      if (itemElement) {
        itemElement.style.position = 'absolute';
        itemElement.style.top = item.top - scrollTop + 'px';
        itemElement.style.width = '100%';
        this.visibleContainer.appendChild(itemElement);
      }
    });
  }

  // 创建项目元素
  createItemElement(item) {
    switch (item.type) {
      case 'object-title':
        const titleEl = document.createElement('h3');
        titleEl.textContent = item.schema.title || 'Object';
        titleEl.style.padding = '10px';
        titleEl.style.backgroundColor = '#f5f5f5';
        return titleEl;
        
      case 'array-title':
        const arrayTitleEl = document.createElement('div');
        arrayTitleEl.innerHTML = `
          <h3 style="display: inline;">${item.schema.title || 'Array'}</h3>
          <button onclick="console.log('Add item to ${item.path.join('.')}')" 
                  style="margin-left: 10px;">添加项目</button>
        `;
        arrayTitleEl.style.padding = '10px';
        arrayTitleEl.style.backgroundColor = '#e8e8e8';
        return arrayTitleEl;
        
      case 'field':
        return this.renderFieldElement(item);
        
      case 'array-actions':
        const actionsEl = document.createElement('div');
        actionsEl.innerHTML = `
          <button onclick="console.log('Remove item')" style="margin-right: 5px;">删除</button>
          <button onclick="console.log('Move up')" style="margin-right: 5px;">上移</button>
          <button onclick="console.log('Move down')">下移</button>
        `;
        actionsEl.style.padding = '5px';
        actionsEl.style.backgroundColor = '#f9f9f9';
        return actionsEl;
        
      default:
        return null;
    }
  }

  // 渲染字段元素
  renderFieldElement(item) {
    const fieldContainer = document.createElement('div');
    fieldContainer.style.padding = '10px';
    fieldContainer.style.borderBottom = '1px solid #eee';
    
    if (item.schema.title) {
      const label = document.createElement('label');
      label.textContent = item.schema.title;
      label.style.display = 'block';
      label.style.marginBottom = '5px';
      fieldContainer.appendChild(label);
    }
    
    let inputElement;
    switch (item.schema.fieldType || item.schema.type) {
      case 'rating':
        inputElement = this.createRatingElement(item);
        break;
      case 'boolean':
        inputElement = document.createElement('input');
        inputElement.type = 'checkbox';
        inputElement.checked = this.getNestedValue(this.data, item.path) || false;
        inputElement.onchange = (e) => {
          this.updateNestedValue(item.path, e.target.checked);
          this.onChange && this.onChange(this.data);
        };
        break;
      default:
        inputElement = document.createElement('input');
        inputElement.type = 'text';
        inputElement.value = this.getNestedValue(this.data, item.path) || '';
        inputElement.oninput = (e) => {
          this.updateNestedValue(item.path, e.target.value);
          this.onChange && this.onChange(this.data);
        };
    }
    
    fieldContainer.appendChild(inputElement);
    return fieldContainer;
  }

  // 创建评分元素
  createRatingElement(item) {
    const ratingContainer = document.createElement('div');
    ratingContainer.className = 'rating-field';
    
    const maxRating = item.schema.max || 5;
    const currentValue = this.getNestedValue(this.data, item.path) || 0;
    
    for (let i = 1; i <= maxRating; i++) {
      const star = document.createElement('span');
      star.textContent = '★';
      star.style.cursor = 'pointer';
      star.style.color = i <= currentValue ? '#ffd700' : '#ddd';
      star.style.fontSize = '20px';
      star.onclick = () => {
        this.updateNestedValue(item.path, i);
        this.onChange && this.onChange(this.data);
        this.updateStars(ratingContainer, i, maxRating);
      };
      ratingContainer.appendChild(star);
    }
    
    return ratingContainer;
  }

  // 更新评分显示
  updateStars(container, rating, maxRating) {
    const stars = container.querySelectorAll('span');
    stars.forEach((star, index) => {
      star.style.color = index + 1 <= rating ? '#ffd700' : '#ddd';
    });
  }

  // 获取总高度
  getTotalHeight() {
    if (this.itemLayouts.length === 0) return 0;
    const lastItem = this.itemLayouts[this.itemLayouts.length - 1];
    return lastItem.top + lastItem.height;
  }

  // 获取嵌套值
  getNestedValue(obj, path) {
    return path.reduce((current, key) => current && current[key], obj);
  }

  // 更新嵌套值
  updateNestedValue(path, value) {
    let current = this.data;
    
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      if (current[key] === undefined) {
        current[key] = {};
      }
      current = current[key];
    }
    
    current[path[path.length - 1]] = value;
  }
}
```

## 实际应用场景

### 1. 评分系统配置
- 用于配置复杂的评分规则和权重分配
- 支持多层级评分标准的动态调整
- 实现评分模板的快速创建和修改

### 2. 表单构建器
- 拖拽式表单设计工具
- 支持复杂嵌套结构的表单
- 动态字段的添加和删除

### 3. 配置管理系统
- 产品配置的动态表单
- 支持深层嵌套的配置项
- 实时预览和验证功能

### 4. 工作流引擎
- 复杂业务流程的表单配置
- 动态条件分支的表单渲染
- 多步骤表单的状态管理

## 性能优化建议

1. **使用虚拟滚动**：对于大量表单项，只渲染可视区域
2. **组件懒加载**：按需加载复杂的表单组件
3. **状态不可变性**：使用不可变数据结构避免不必要的重渲染
4. **路径索引**：为每个字段建立路径索引，快速定位更新
5. **防抖处理**：对频繁的表单变化进行防抖处理
6. **内存管理**：及时清理未使用的组件实例
7. **分片渲染**：将大表单分解为小块逐步渲染
8. **缓存机制**：缓存已渲染的组件以提高重复渲染性能
