# 前端在运行时如果需要动态加载某个业务子模块（如考核模块），如何实现？（了解）

**题目**: 前端在运行时如果需要动态加载某个业务子模块（如考核模块），如何实现？（了解）

**答案**:

前端动态加载业务子模块有多种实现方式，主要包括：

## 1. 动态导入（Dynamic Import）

使用 ES2020 的动态 import 语法：

```javascript
// 按需加载组件
const loadModule = async (moduleName) => {
  try {
    const module = await import(`./modules/${moduleName}.js`);
    return module;
  } catch (error) {
    console.error(`Failed to load module ${moduleName}:`, error);
  }
};

// 使用示例
const loadAssessmentModule = async () => {
  const assessmentModule = await import('./modules/assessment.js');
  return assessmentModule.default;
};

// 在 React 中动态加载组件
const AssessmentComponent = React.lazy(() => import('./AssessmentModule'));

function App() {
  return (
    <div>
      <React.Suspense fallback={<div>Loading...</div>}>
        <AssessmentComponent />
      </React.Suspense>
    </div>
  );
}
```

## 2. Webpack 代码分割

通过 Webpack 的代码分割功能实现模块懒加载：

```javascript
// 使用 import() 进行代码分割
const loadAssessmentModule = () => {
  return import(
    /* webpackChunkName: "assessment-module" */ 
    './modules/assessment'
  );
};

// 在路由级别进行分割
const AssessmentPage = () => import(
  /* webpackChunkName: "assessment-page" */
  '../pages/AssessmentPage'
);

// 在函数级别进行分割
const loadChartLibrary = async () => {
  const { Chart } = await import('chart.js');
  return Chart;
};
```

## 3. 模块联邦（Module Federation）

Webpack 5 的模块联邦功能，实现微前端架构：

```javascript
// webpack.config.js (宿主应用)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "host_app",
      remotes: {
        assessment_module: "assessment@http://localhost:3001/remoteEntry.js",
      },
    }),
  ],
};

// webpack.config.js (子模块)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "assessment",
      filename: "remoteEntry.js",
      exposes: {
        "./AssessmentModule": "./src/AssessmentModule",
      },
      shared: ["react", "react-dom"],
    }),
  ],
};

// 使用模块联邦
import { AssessmentModule } from 'assessment/AssessmentModule';
```

## 4. 微前端架构

使用微前端框架实现模块动态加载：

```javascript
// 使用 single-spa
import { registerApplication, start } from 'single-spa';

registerApplication({
  name: 'assessment',
  app: () => System.import('assessment-app'),
  activeWhen: ['/assessment']
});

// 使用 qiankun
import { loadMicroApp } from 'qiankun';

const assessmentApp = loadMicroApp(
  { name: 'assessment', entry: '//localhost:8081' },
  { props: { container: '#assessment-container' } }
);
```

## 5. 动态脚本加载

通过动态创建 script 标签加载模块：

```javascript
const loadScript = (url) => {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = url;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

// 加载第三方库或模块
const loadAssessmentModule = async () => {
  await loadScript('/assets/assessment-module.js');
  return window.AssessmentModule;
};

// 更安全的动态加载
class DynamicModuleLoader {
  constructor() {
    this.loadedModules = new Map();
  }

  async loadModule(url, moduleName) {
    if (this.loadedModules.has(moduleName)) {
      return this.loadedModules.get(moduleName);
    }

    const module = await import(url);
    this.loadedModules.set(moduleName, module);
    return module;
  }
}

const loader = new DynamicModuleLoader();
```

## 6. 路由级别的动态加载

在前端路由中实现模块懒加载：

```javascript
// React Router v6
import { lazy, Suspense } from 'react';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';

const AssessmentPage = lazy(() => import('./pages/AssessmentPage'));
const DashboardPage = lazy(() => import('./pages/DashboardPage'));

const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
  },
  {
    path: "/assessment",
    element: (
      <Suspense fallback={<div>Loading assessment module...</div>}>
        <AssessmentPage />
      </Suspense>
    ),
  },
]);

function App() {
  return <RouterProvider router={router} />;
}
```

## 7. 条件加载和权限控制

根据用户权限动态加载模块：

```javascript
class ModuleManager {
  constructor() {
    this.modules = new Map();
    this.permissions = new Set();
  }

  async loadModuleIfPermitted(moduleName, permission) {
    if (!this.permissions.has(permission)) {
      throw new Error(`User doesn't have permission to load ${moduleName}`);
    }

    if (!this.modules.has(moduleName)) {
      const module = await import(`./modules/${moduleName}`);
      this.modules.set(moduleName, module);
    }

    return this.modules.get(moduleName);
  }

  setPermissions(permissions) {
    this.permissions = new Set(permissions);
  }
}

// 使用示例
const moduleManager = new ModuleManager();
moduleManager.setPermissions(['assessment:read']);

try {
  const assessmentModule = await moduleManager.loadModuleIfPermitted('assessment', 'assessment:read');
  // 使用模块
} catch (error) {
  console.error('Cannot load module:', error.message);
}
```

## 8. 预加载策略

根据用户行为预测性地预加载模块：

```javascript
// 预加载策略
class PreloadManager {
  constructor() {
    this.preloadedModules = new Set();
  }

  preloadModule(modulePath) {
    if (!this.preloadedModules.has(modulePath)) {
      // 使用 link[rel="preload"] 预加载
      const link = document.createElement('link');
      link.rel = 'modulepreload';
      link.href = modulePath;
      document.head.appendChild(link);
      
      this.preloadedModules.add(modulePath);
    }
  }

  // 基于用户行为的预加载
  observeUserBehavior() {
    // 当用户悬停在导航项上时预加载
    document.addEventListener('mouseover', (e) => {
      if (e.target.dataset.preloadModule) {
        this.preloadModule(e.target.dataset.preloadModule);
      }
    });
  }
}
```

## 9. 缓存和版本控制

确保动态加载模块的缓存策略：

```javascript
// 带版本控制的模块加载器
class VersionedModuleLoader {
  constructor() {
    this.cache = new Map();
  }

  async loadModule(name, version = 'latest') {
    const cacheKey = `${name}@${version}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const module = await import(`./modules/${name}@${version}.js`);
    this.cache.set(cacheKey, module);
    
    return module;
  }
}
```

## 最佳实践

1. **按需加载**：只在需要时加载模块
2. **代码分割**：合理分割代码，避免过大或过小的 chunk
3. **缓存策略**：合理设置缓存头，避免重复加载
4. **错误处理**：妥善处理加载失败的情况
5. **性能监控**：监控模块加载性能
6. **权限控制**：确保只有有权限的用户能加载特定模块

这些技术可以根据项目需求和架构选择使用，实现灵活、高效的模块动态加载。
