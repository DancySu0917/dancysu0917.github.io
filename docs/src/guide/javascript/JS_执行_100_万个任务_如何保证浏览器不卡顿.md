# JS 执行 100 万个任务，如何保证浏览器不卡顿？（了解）

**题目**: JS 执行 100 万个任务，如何保证浏览器不卡顿？（了解）

**答案**:

当需要执行大量任务（如100万个）时，如果一次性执行会阻塞主线程，导致浏览器界面卡顿、无响应。以下是几种有效的解决方案：

## 1. 时间切片 (Time Slicing)

将大任务分解为小任务块，在浏览器的空闲时间执行：

```javascript
function processTasks(tasks, chunkSize = 1000) {
  let index = 0;
  
  function processChunk() {
    const chunkEnd = Math.min(index + chunkSize, tasks.length);
    
    // 执行一个小块的任务
    for (; index < chunkEnd; index++) {
      // 处理单个任务
      processTask(tasks[index]);
    }
    
    if (index < tasks.length) {
      // 如果还有任务未完成，使用setTimeout让出控制权
      setTimeout(processChunk, 0);
    } else {
      console.log('所有任务完成');
    }
  }
  
  processChunk();
}

// 示例任务处理函数
function processTask(task) {
  // 模拟任务处理
  return task * 2;
}

// 使用示例
const tasks = Array.from({length: 1000000}, (_, i) => i);
processTasks(tasks);
```

## 2. 使用 requestIdleCallback

利用浏览器空闲时间执行任务，提供更精确的控制：

```javascript
function processTasksWithIdle(tasks) {
  let index = 0;
  const results = [];
  
  function processIdle(deadline) {
    // 在浏览器空闲时间内处理任务
    while (deadline.timeRemaining() > 0 && index < tasks.length) {
      results.push(processTask(tasks[index]));
      index++;
    }
    
    if (index < tasks.length) {
      // 如果还有任务，继续在下一个空闲时间执行
      requestIdleCallback(processIdle);
    } else {
      console.log('所有任务完成，处理了', results.length, '个任务');
    }
  }
  
  requestIdleCallback(processIdle);
}

// 使用示例
const tasks = Array.from({length: 1000000}, (_, i) => i);
processTasksWithIdle(tasks);
```

## 3. 使用 requestAnimationFrame

适合与UI更新相关的任务，确保在浏览器重绘前执行：

```javascript
function processTasksWithRAF(tasks) {
  let index = 0;
  const results = [];
  
  function processFrame() {
    // 每帧处理固定数量的任务
    const end = Math.min(index + 100, tasks.length); // 每帧处理100个任务
    
    for (; index < end; index++) {
      results.push(processTask(tasks[index]));
    }
    
    if (index < tasks.length) {
      requestAnimationFrame(processFrame);
    } else {
      console.log('所有任务完成');
    }
  }
  
  requestAnimationFrame(processFrame);
}
```

## 4. Web Workers

将计算密集型任务放到后台线程执行，完全不阻塞主线程：

```javascript
// main.js
function processTasksWithWorker(tasks) {
  const worker = new Worker('task-worker.js');
  
  worker.postMessage({
    tasks: tasks,
    chunkSize: 10000 // 每次处理1万个任务
  });
  
  worker.onmessage = function(e) {
    const { results, progress, completed } = e.data;
    
    if (completed) {
      console.log('所有任务完成，结果数量：', results.length);
      worker.terminate();
    } else {
      console.log(`进度: ${progress}%`);
    }
  };
}

// task-worker.js (需要单独创建文件)
self.onmessage = function(e) {
  const { tasks, chunkSize } = e.data;
  const results = [];
  
  for (let i = 0; i < tasks.length; i += chunkSize) {
    const chunk = tasks.slice(i, i + chunkSize);
    
    // 处理当前块的任务
    for (const task of chunk) {
      results.push(task * 2); // 示例处理
    }
    
    // 发送进度更新
    const progress = Math.round((i + chunkSize) / tasks.length * 100);
    self.postMessage({
      results: results,
      progress: progress,
      completed: (i + chunkSize) >= tasks.length
    });
  }
};
```

## 5. 生成器函数配合异步处理

使用Generator函数实现任务的分步执行：

```javascript
function* taskGenerator(tasks) {
  for (const task of tasks) {
    yield processTask(task);
  }
}

async function processWithGenerator(tasks) {
  const gen = taskGenerator(tasks);
  const results = [];
  const chunkSize = 1000;
  
  while (true) {
    const chunk = [];
    
    // 获取一批任务结果
    for (let i = 0; i < chunkSize; i++) {
      const result = gen.next();
      if (result.done) {
        // 将剩余结果添加到results
        if (chunk.length > 0) {
          results.push(...chunk);
        }
        console.log('所有任务完成');
        return results;
      }
      chunk.push(result.value);
    }
    
    // 将当前块的结果添加到总结果中
    results.push(...chunk);
    
    // 让出控制权，允许浏览器处理其他事件
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
```

## 6. 使用 Promise 和 async/await 分批处理

```javascript
async function processTasksAsync(tasks, batchSize = 1000) {
  const results = [];
  
  for (let i = 0; i < tasks.length; i += batchSize) {
    const batch = tasks.slice(i, i + batchSize);
    
    // 处理当前批次
    const batchResults = batch.map(task => processTask(task));
    results.push(...batchResults);
    
    // 让出控制权，允许浏览器处理UI更新
    await new Promise(resolve => setTimeout(resolve, 0));
    
    // 可选：显示进度
    console.log(`已处理: ${Math.min(i + batchSize, tasks.length)} / ${tasks.length}`);
  }
  
  console.log('所有任务完成');
  return results;
}
```

## 7. 使用现代浏览器的 scheduler API（实验性）

```javascript
// 注意：这是一个实验性API，可能不被所有浏览器支持
if ('scheduler' in window) {
  function processTasksWithScheduler(tasks) {
    let index = 0;
    const results = [];
    
    function processTaskCallback() {
      const end = Math.min(index + 1000, tasks.length);
      
      for (; index < end; index++) {
        results.push(processTask(tasks[index]));
      }
      
      if (index < tasks.length) {
        scheduler.postTask(processTaskCallback);
      } else {
        console.log('所有任务完成');
      }
    }
    
    scheduler.postTask(processTaskCallback);
  }
}
```

## 性能监控和优化建议

### 监控执行时间
```javascript
function monitorTaskPerformance(tasks, processor) {
  const startTime = performance.now();
  
  return processor(tasks).then(() => {
    const endTime = performance.now();
    console.log(`任务处理耗时: ${endTime - startTime}ms`);
  });
}
```

### 根据设备性能动态调整
```javascript
function getOptimalChunkSize() {
  // 根据设备内存和CPU核心数调整块大小
  const hardwareConcurrency = navigator.hardwareConcurrency || 4;
  const memory = navigator.deviceMemory || 4; // GB
  
  // 根据设备性能计算合适的块大小
  return Math.min(5000 * hardwareConcurrency * memory, 50000);
}
```

## 总结

处理大量任务时，关键原则是避免长时间阻塞主线程。选择哪种方案取决于具体场景：

- **简单场景**：使用时间切片或`requestIdleCallback`
- **UI相关**：使用`requestAnimationFrame`
- **计算密集型**：使用Web Workers
- **现代应用**：考虑使用Scheduler API（实验性）

通过合理选择和组合这些技术，可以有效处理大量任务而不影响用户体验。
