# 什么是无状态组件，与有状态组件的区别？（必会）

**题目**: 什么是无状态组件，与有状态组件的区别？（必会）

## 标准答案

无状态组件（Stateless Component）也称为函数组件或纯组件，只接收 props 并返回 JSX，不管理内部状态。有状态组件（Stateful Component）能够管理内部状态，可以使用 state 和生命周期方法。在现代 React 中，函数组件通过 Hooks 可以拥有状态，因此更准确的区分是：无状态组件不使用 useState 等状态 Hook，而有状态组件使用状态管理 Hook。

## 深入理解

### 1. 无状态组件（Stateless Component）

无状态组件，也称为纯组件或函数组件，只依赖于传入的 props 进行渲染，不管理内部状态：

```jsx
// 传统无状态组件（函数组件）
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// 箭头函数形式的无状态组件
const Greeting = (props) => {
  return <div>Welcome, {props.name}!</div>;
};

// 使用解构的无状态组件
const UserCard = ({ name, email, avatar }) => {
  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
};

// 更复杂的无状态组件示例
const Button = ({ children, onClick, type = 'button', disabled = false }) => {
  return (
    <button 
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${type}`}
    >
      {children}
    </button>
  );
};
```

### 2. 有状态组件（Stateful Component）

有状态组件能够管理内部状态，React 早期主要通过类组件实现：

```jsx
// 类组件形式的有状态组件
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
  
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

// 使用类字段语法的有状态组件
class UserProfile extends React.Component {
  state = {
    user: null,
    loading: true,
    error: null
  };
  
  componentDidMount() {
    this.fetchUser();
  }
  
  fetchUser = async () => {
    try {
      const response = await fetch(`/api/users/${this.props.userId}`);
      const user = await response.json();
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  }
  
  render() {
    const { user, loading, error } = this.state;
    
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    if (!user) return <div>No user found</div>;
    
    return (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
  }
}
```

### 3. 现代 React 中的状态管理

在现代 React 中，函数组件通过 Hooks 也可以管理状态：

```jsx
// 使用 Hooks 的有状态函数组件
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// 复杂状态管理的函数组件
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>No user found</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### 4. 无状态组件的特点

**优点：**
- 简洁易读，代码量少
- 更容易测试，因为输出完全依赖于输入
- 性能更好（在早期 React 中）
- 逻辑更清晰，职责单一

**缺点：**
- 无法管理内部状态
- 无法使用生命周期方法（早期）
- 无法处理复杂的交互逻辑

```jsx
// 典型的无状态组件应用场景
const Header = ({ title, subtitle }) => (
  <header>
    <h1>{title}</h1>
    {subtitle && <p>{subtitle}</p>}
  </header>
);

const List = ({ items, renderItem }) => (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{renderItem(item)}</li>
    ))}
  </ul>
);

const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <button onClick={onClose}>Close</button>
        {children}
      </div>
    </div>
  );
};
```

### 5. 有状态组件的特点

**优点：**
- 可以管理内部状态
- 可以处理复杂的用户交互
- 可以执行副作用操作
- 更适合复杂业务逻辑

**缺点：**
- 代码更复杂
- 更难测试
- 可能导致性能问题（如果状态管理不当）
- 容易出现状态不一致问题

```jsx
// 复杂有状态组件示例
function SearchComponent() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // 防抖搜索
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (query.trim()) {
        performSearch(query);
      } else {
        setResults([]);
      }
    }, 300);
    
    return () => clearTimeout(timeoutId);
  }, [query]);
  
  const performSearch = async (searchQuery) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
      const data = await response.json();
      setResults(data.results);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      
      {loading && <div>Searching...</div>}
      {error && <div>Error: {error}</div>}
      
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 6. 状态提升（State Lifting）

在某些情况下，需要将状态从子组件提升到父组件：

```jsx
// 状态提升示例
function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  const scaleName = scale === 'c' ? 'Celsius' : 'Fahrenheit';
  
  return (
    <fieldset>
      <legend>Enter temperature in {scaleName}:</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c');
  
  const handleCelsiusChange = (temperature) => {
    setScale('c');
    setTemperature(temperature);
  };
  
  const handleFahrenheitChange = (temperature) => {
    setScale('f');
    setTemperature(temperature);
  };
  
  const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
  
  return (
    <div>
      <TemperatureInput
        scale="c"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
    </div>
  );
}
```

### 7. 现代最佳实践

在现代 React 开发中，推荐：

1. **优先使用函数组件 + Hooks**
2. **将状态管理逻辑封装到自定义 Hooks 中**
3. **合理使用状态提升**
4. **使用 Context 进行跨层级状态传递**

```jsx
// 自定义 Hook 封装状态逻辑
function useInput(initialValue = '') {
  const [value, setValue] = useState(initialValue);
  
  return {
    value,
    setValue,
    reset: () => setValue(initialValue),
    bind: {
      value,
      onChange: (e) => setValue(e.target.value)
    }
  };
}

// 使用自定义 Hook 的组件
function LoginForm() {
  const username = useInput('');
  const password = useInput('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({ username: username.value, password: password.value });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input placeholder="Username" {...username.bind} />
      <input type="password" placeholder="Password" {...password.bind} />
      <button type="submit">Login</button>
    </form>
  );
}
```

### 8. 性能优化考虑

对于无状态组件，可以使用 React.memo 进行优化：

```jsx
// 使用 React.memo 优化无状态组件
const ExpensiveComponent = React.memo(({ data }) => {
  // 只有当 data 改变时才重新渲染
  return <div>{/* expensive rendering */}</div>;
});

// 自定义比较函数
const CustomMemoComponent = React.memo(({ user }) => {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}, (prevProps, nextProps) => {
  // 只比较关键属性
  return prevProps.user.id === nextProps.user.id;
});
```

总的来说，无状态组件和有状态组件的选择取决于组件是否需要管理内部状态。现代 React 中，函数组件通过 Hooks 可以实现与类组件相同的功能，因此更推荐使用函数组件 + Hooks 的方式。
