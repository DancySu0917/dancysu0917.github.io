# 介绍下原型链（解决的是继承问题吗）？（必会）

**题目**: 介绍下原型链（解决的是继承问题吗）？（必会）

## 答案

原型链（Prototype Chain）是JavaScript实现继承的核心机制，它确实主要解决的是继承问题，但其作用不仅限于此。原型链是JavaScript中对象属性查找的机制，也是实现继承的基础。

### 1. 原型链的基本概念

在JavaScript中，每个对象都有一个内部属性[[Prototype]]（可以通过__proto__访问），它指向该对象的原型对象。原型对象本身也是一个对象，它也有自己的原型，这样就形成了一个原型链，直到原型为null为止。

```javascript
// 创建一个构造函数
function Animal(name) {
    this.name = name;
}

// 在Animal的原型上添加方法
Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

// 创建一个继承自Animal的构造函数
function Dog(name, breed) {
    Animal.call(this, name); // 调用父构造函数
    this.breed = breed;
}

// 设置原型链：Dog的原型继承自Animal的原型
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// 在Dog的原型上添加特有方法
Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

const myDog = new Dog('Buddy', 'Golden Retriever');

// 验证原型链
console.log(myDog instanceof Dog); // true
console.log(myDog instanceof Animal); // true
console.log(myDog.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

### 2. 原型链的工作原理

当访问对象的一个属性或方法时，JavaScript引擎会按以下顺序查找：

1. 首先在对象自身的属性中查找
2. 如果找不到，就在对象的原型（__proto__）中查找
3. 如果还是找不到，就在原型的原型中查找
4. 以此类推，直到找到该属性或到达原型链的顶端（null）

```javascript
function Parent() {
    this.parentProperty = 'parent value';
}

Parent.prototype.parentMethod = function() {
    return 'parent method';
};

function Child() {
    this.childProperty = 'child value';
}

// 建立原型链
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

Child.prototype.childMethod = function() {
    return 'child method';
};

const child = new Child();

// 属性查找过程演示
console.log(child.childProperty); // 'child value' - 对象自身属性
console.log(child.parentMethod);  // 'parent method' - 通过原型链从Parent.prototype找到
console.log(child.toString);      // [native code] - 通过原型链从Object.prototype找到

// 查找顺序：child自身 -> Child.prototype -> Parent.prototype -> Object.prototype -> null
```

### 3. 原型链解决的继承问题

原型链确实主要解决继承问题，具体体现在：

#### 3.1 属性和方法的继承

子类可以继承父类的属性和方法：

```javascript
function Vehicle(brand) {
    this.brand = brand;
    this.speed = 0;
}

Vehicle.prototype.accelerate = function(increment) {
    this.speed += increment;
    console.log(`Speed is now ${this.speed}`);
};

Vehicle.prototype.brake = function() {
    this.speed = 0;
    console.log('Vehicle stopped');
};

function Car(brand, model) {
    Vehicle.call(this, brand); // 继承实例属性
    this.model = model;
}

// 通过原型链继承方法
Car.prototype = Object.create(Vehicle.prototype);
Car.prototype.constructor = Car;

// Car特有方法
Car.prototype.honk = function() {
    console.log('Beep beep!');
};

const myCar = new Car('Toyota', 'Camry');

// 继承的属性
console.log(myCar.brand); // 'Toyota'
console.log(myCar.speed); // 0

// 继承的方法
myCar.accelerate(30); // 'Speed is now 30'
myCar.brake(); // 'Vehicle stopped'

// 自己的方法
myCar.honk(); // 'Beep beep!'
```

#### 3.2 多层继承

原型链支持多层继承，形成继承层次结构：

```javascript
// 基类
function LivingThing(name) {
    this.name = name;
}

LivingThing.prototype.breathe = function() {
    console.log(`${this.name} is breathing`);
};

// 中间类
function Animal(name, species) {
    LivingThing.call(this, name);
    this.species = species;
}

Animal.prototype = Object.create(LivingThing.prototype);
Animal.prototype.constructor = Animal;

Animal.prototype.move = function() {
    console.log(`${this.name} is moving`);
};

// 子类
function Dog(name, breed) {
    Animal.call(this, name, 'Canine');
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} is barking`);
};

const myDog = new Dog('Rex', 'German Shepherd');

// 多层继承的体现
myDog.breathe(); // 从LivingThing继承
myDog.move();    // 从Animal继承
myDog.bark();    // Dog自身方法

// instanceof检查
console.log(myDog instanceof Dog);        // true
console.log(myDog instanceof Animal);     // true
console.log(myDog instanceof LivingThing); // true
console.log(myDog instanceof Object);     // true
```

### 4. 原型链的其他作用

除了继承，原型链还有其他重要作用：

#### 4.1 代码复用

通过原型链，多个对象实例可以共享原型上的方法，节省内存：

```javascript
function Person(name) {
    this.name = name;
}

// 方法定义在原型上，被所有实例共享
Person.prototype.greet = function() {
    return `Hello, I'm ${this.name}`;
};

const person1 = new Person('Alice');
const person2 = new Person('Bob');

// 两个实例共享同一个greet方法
console.log(person1.greet === person2.greet); // true
console.log(person1.greet()); // "Hello, I'm Alice"
console.log(person2.greet()); // "Hello, I'm Bob"
```

#### 4.2 动态性

原型链的动态性允许在运行时修改原型，影响所有相关对象：

```javascript
function Shape() {}

const circle = new Shape();
const square = new Shape();

// 在原型上添加新方法后，所有实例都能访问
Shape.prototype.getArea = function() {
    return 'Area calculation';
};

console.log(circle.getArea()); // "Area calculation"
console.log(square.getArea()); // "Area calculation"
```

### 5. 原型链的实现方式

#### 5.1 使用Object.create()

```javascript
function Parent() {
    this.parentProp = 'parent';
}

Parent.prototype.parentMethod = function() {
    return 'parent method';
};

function Child() {
    Parent.call(this); // 继承实例属性
    this.childProp = 'child';
}

// 使用Object.create建立原型链
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child = new Child();
console.log(child.parentMethod()); // 'parent method'
```

#### 5.2 ES6 Class语法

ES6的class语法是原型链的语法糖：

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 调用父类构造函数
        this.breed = breed;
    }
    
    bark() {
        console.log(`${this.name} barks`);
    }
}

const myDog = new Dog('Buddy', 'Labrador');

// 继承的属性和方法
console.log(myDog.name); // 'Buddy'
myDog.speak(); // 'Buddy makes a sound'

// 自己的属性和方法
console.log(myDog.breed); // 'Labrador'
myDog.bark(); // 'Buddy barks'

// 原型链关系
console.log(myDog.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
```

### 6. 原型链的局限性

#### 6.1 引用类型属性的共享问题

```javascript
function Parent() {}
Parent.prototype.hobbies = ['reading', 'swimming']; // 引用类型

function Child() {}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child1 = new Child();
const child2 = new Child();

// 修改一个实例会影响其他实例
child1.hobbies.push('cooking');
console.log(child2.hobbies); // ['reading', 'swimming', 'cooking'] - 被意外修改了！

// 解决方案：在构造函数中初始化引用类型属性
function ProperParent() {
    this.hobbies = ['reading', 'swimming']; // 每个实例有自己的数组
}
```

#### 6.2 无法向构造函数传参

在原型链继承中，无法向父类构造函数传递参数（除非使用其他继承模式）。

### 7. 实际应用示例

```javascript
// 创建一个组件系统，演示原型链的应用
class Component {
    constructor(name) {
        this.name = name;
        this.props = {};
        this.state = {};
    }
    
    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.render();
    }
    
    render() {
        console.log(`${this.name} component rendered`);
    }
}

class Button extends Component {
    constructor(name, text) {
        super(name);
        this.text = text;
    }
    
    click() {
        console.log(`${this.text} button clicked`);
    }
}

class IconButton extends Button {
    constructor(name, text, icon) {
        super(name, text);
        this.icon = icon;
    }
    
    render() {
        console.log(`${this.icon} ${this.text} button rendered`);
    }
}

const iconButton = new IconButton('myButton', 'Submit', '✓');

// 多层继承的体现
iconButton.click(); // "Submit button clicked" (继承自Button)
iconButton.setState({ enabled: true }); // 调用Component的方法
iconButton.render(); // "✓ Submit button rendered" (重写的render方法)

// instanceof检查
console.log(iconButton instanceof IconButton); // true
console.log(iconButton instanceof Button);     // true
console.log(iconButton instanceof Component);  // true
```

### 总结

原型链确实是为了解决JavaScript中的继承问题而设计的，它是JavaScript实现面向对象编程的关键机制。通过原型链，JavaScript实现了对象间的继承关系，支持方法和属性的继承，同时也提供了代码复用和动态性等特性。虽然原型链有其局限性，但它是JavaScript语言设计的核心概念之一，理解原型链对于掌握JavaScript至关重要。
