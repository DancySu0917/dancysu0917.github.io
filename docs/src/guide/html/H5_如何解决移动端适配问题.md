# H5 如何解决移动端适配问题？（了解）

**题目**: H5 如何解决移动端适配问题？（了解）

## 答案

移动端适配是前端开发中的重要问题，主要解决不同设备屏幕尺寸和分辨率差异导致的显示问题。以下是几种主流的移动端适配方案：

### 1. 视口（Viewport）设置

首先需要设置正确的viewport，这是移动端适配的基础：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

参数说明：
- width=device-width: 设置视口宽度等于设备宽度
- initial-scale=1.0: 初始缩放比例为1
- maximum-scale=1.0: 最大缩放比例
- user-scalable=no: 禁止用户缩放

### 2. REM 布局方案

REM 是相对于根元素（html）字体大小的单位，通过动态设置html的font-size来实现适配：

```javascript
// 动态设置根字体大小
function setRootFontSize() {
  const deviceWidth = document.documentElement.clientWidth;
  const rootFontSize = (deviceWidth / 375) * 16; // 以iPhone6/7/8为基准（375px）
  document.documentElement.style.fontSize = rootFontSize + 'px';
}

// 监听屏幕变化
window.addEventListener('resize', setRootFontSize);
window.addEventListener('orientationchange', setRootFontSize);

setRootFontSize();
```

CSS 使用：
```css
.container {
  width: 23.4375rem; /* 375px / 16px = 23.4375rem */
  height: 6.25rem;   /* 100px / 16px = 6.25rem */
}
```

### 3. VW 布局方案

VW 是相对于视口宽度的单位（1vw = 视口宽度的1%），现代浏览器支持良好：

```css
.container {
  width: 100vw;      /* 视口宽度的100% */
  height: 26.67vw;   /* 100px / 375px * 100vw ≈ 26.67vw */
  padding: 2.67vw;   /* 10px / 375px * 100vw ≈ 2.67vw */
}
```

使用 CSS 的 `calc()` 函数：
```css
/* 以iPhone6/7/8为基准，设计稿宽度375px */
/* 实际尺寸 = (设计稿尺寸 / 375) * 100vw */
.container {
  width: calc(375 / 375 * 100vw);
  height: calc(100 / 375 * 100vw);
  font-size: calc(16 / 375 * 100vw);
}
```

### 4. 媒体查询（Media Queries）

针对不同屏幕尺寸应用不同的样式：

```css
/* iPhone 6/7/8 */
@media screen and (width: 375px) and (device-pixel-ratio: 2) {
  .container {
    font-size: 16px;
  }
}

/* iPhone 6/7/8 Plus */
@media screen and (width: 414px) and (device-pixel-ratio: 3) {
  .container {
    font-size: 18px;
  }
}

/* iPad */
@media screen and (min-width: 768px) {
  .container {
    font-size: 20px;
  }
}
```

### 5. Flexible.js 方案（阿里早期方案）

阿里早期的移动端适配方案，通过动态设置viewport和rem来适配：

```javascript
(function flexible(window, document) {
  var docEl = document.documentElement;
  var dpr = window.devicePixelRatio || 1;
  
  // 设置data-dpr属性
  docEl.setAttribute('data-dpr', dpr);
  
  // 设置基准字体大小
  var fakeBody = document.createElement('body');
  var testElement = document.createElement('div');
  testElement.style.border = '.5px solid transparent';
  fakeBody.appendChild(testElement);
  docEl.appendChild(fakeBody);
  if (testElement.offsetHeight === 1) {
    docEl.classList.add('hairlines');
  }
  docEl.removeChild(fakeBody);
  
  // 动态设置根字体大小
  function setRemUnit() {
    var rem = docEl.clientWidth * dpr / 10;
    docEl.style.fontSize = rem + 'px';
  }
  
  setRemUnit();
  
  // 重新设置
  window.addEventListener('resize', setRemUnit);
  window.addEventListener('pageshow', function(e) {
    if (e.persisted) {
      setRemUnit();
    }
  });
})(window, document);
```

### 6. PostCSS 插件自动化处理

使用 postcss-pxtorem 插件自动转换px到rem：

```javascript
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 37.5,  // 设计稿宽度/10，如750px设计稿用75，375px设计稿用37.5
      propList: ['*'],  // 需要转换的属性，*表示所有
      selectorBlackList: ['.no-rem'],  // 忽略转换的类名
    }
  }
}
```

```css
/* 编译前 */
.container {
  width: 375px;
  height: 100px;
  font-size: 16px;
}

/* 编译后 */
.container {
  width: 10rem;      /* 375 / 37.5 = 10 */
  height: 2.67rem;   /* 100 / 37.5 ≈ 2.67 */
  font-size: 0.43rem; /* 16 / 37.5 ≈ 0.43 */
}
```

### 7. 1px边框问题解决方案

在高清屏上，CSS的1px可能显示为物理像素的多倍，需要特殊处理：

```css
/* 使用伪元素和transform */
.border-1px {
  position: relative;
}

.border-1px::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px;
  background-color: #ddd;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}

/* 根据dpr设置 */
[data-dpr="2"] .border-1px::after {
  transform: scaleY(0.5);
}

[data-dpr="3"] .border-1px::after {
  transform: scaleY(0.33);
}
```

### 8. 实际项目中的完整解决方案

结合使用多种技术：

```javascript
// utils/adaptive.js
(function() {
  const doc = document.documentElement;
  const designWidth = 375; // 设计稿宽度
  const maxWidth = 540;    // 最大宽度限制
  const minWidth = 320;    // 最小宽度限制
  
  function refreshRem() {
    let clientWidth = doc.clientWidth;
    
    // 限制最大最小宽度
    if (clientWidth > maxWidth) {
      clientWidth = maxWidth;
    } else if (clientWidth < minWidth) {
      clientWidth = minWidth;
    }
    
    // 设置根字体大小，以设计稿宽度为基准
    const rem = clientWidth / 10;
    doc.style.fontSize = rem + 'px';
  }
  
  refreshRem();
  window.addEventListener('resize', refreshRem);
  window.addEventListener('orientationchange', refreshRem);
})();
```

```css
/* CSS 示例 */
.container {
  width: 10rem;        /* 100% 宽度 */
  padding: 1rem;       /* 10px 内边距 */
  margin: 0.5rem;      /* 5px 外边距 */
  font-size: 1.6rem;   /* 16px 字体大小 */
}

/* 使用vw的替代方案 */
.header {
  height: 44px;
  /* 使用CSS自定义属性配合JS计算 */
}

/* 响应式图片 */
.responsive-img {
  width: 100%;
  height: auto;
}
```

### 9. 最佳实践建议

1. **选择合适的方案**：根据项目需求选择 REM、VW 或其他方案
2. **统一设计基准**：与设计师约定统一的设计稿尺寸（如375px或750px）
3. **自动化处理**：使用构建工具自动转换单位
4. **考虑兼容性**：在低版本浏览器中降级处理
5. **性能优化**：避免频繁的DOM操作和重排

这些方案可以根据项目实际情况单独使用或组合使用，关键是找到最适合项目需求的适配方案。
