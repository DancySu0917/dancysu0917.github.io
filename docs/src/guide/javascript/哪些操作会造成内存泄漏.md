# 哪些操作会造成内存泄漏？（必会）

**题目**: 哪些操作会造成内存泄漏？（必会）

## 答案

内存泄漏是指程序在运行过程中，已经不再使用的内存没有被释放，导致这部分内存无法被重新利用的现象。在JavaScript中，以下操作容易造成内存泄漏：

### 1. 意外的全局变量

当在函数中忘记使用 `var`、`let` 或 `const` 声明变量时，JavaScript会自动创建全局变量，这些变量会一直存在于内存中。

```javascript
function createGlobalVariable() {
    // 没有用var/let/const声明，创建了全局变量
    leakyVariable = "I'm a global variable now!";
    anotherLeakyVar = { data: new Array(1000000).fill('data') };
}

// 正确写法
function createLocalVariable() {
    let properVariable = "I'm a local variable";
    const anotherProperVar = { data: new Array(1000000).fill('data') };
}
```

### 2. 被遗忘的定时器和回调函数

定时器和回调函数会保持对闭包内变量的引用，如果不及时清理，会导致这些变量无法被垃圾回收。

```javascript
// 问题代码 - 定时器未清理
let myObj = {
    name: 'My Object',
    data: new Array(1000000).fill('data'), // 大量数据
    method: function() {
        console.log(this.name);
    }
};

let intervalId = setInterval(myObj.method, 1000);

// 即使myObj不再需要，由于intervalId的存在，它也不会被回收

// 解决方案 - 记得清理
function setupTimer() {
    let intervalId = setInterval(() => {
        console.log('Timer running');
    }, 1000);
    
    return function cleanup() {
        clearInterval(intervalId);
    };
}

// 使用后记得清理
const cleanup = setupTimer();
// 在适当的时候调用
cleanup();
```

### 3. 未移除的事件监听器

事件监听器会保持对回调函数的引用，如果元素被移除但事件监听器未被移除，则会造成内存泄漏。

```javascript
// 问题代码
function attachListener() {
    const button = document.getElementById('myButton');
    const handler = function() {
        console.log('Button clicked');
        // 如果这个函数引用了外部作用域的变量，这些变量也不会被回收
        let largeData = new Array(1000000).fill('data');
        console.log(largeData.length);
    };
    
    button.addEventListener('click', handler);
    // 如果button从DOM中移除，但监听器未被移除，可能会造成内存泄漏
}

// 解决方案 - 使用后及时移除
function properEventListener() {
    const button = document.getElementById('myButton');
    const handler = function() {
        console.log('Button clicked');
    };
    
    button.addEventListener('click', handler);
    
    // 返回清理函数
    return function removeListener() {
        button.removeEventListener('click', handler);
    };
}

// 使用示例
const removeListener = properEventListener();
// 在适当时机移除监听器
removeListener();
```

### 4. 闭包引起的内存泄漏

闭包会保持对外部函数变量的引用，如果不正确使用，可能导致大对象无法被回收。

```javascript
// 问题代码 - 闭包保持对大对象的引用
function createProblematicClosure() {
    const largeData = new Array(1000000).fill('data'); // 大数组
    
    return function() {
        // 这个闭包保持对largeData的引用
        // 即使不需要largeData，它也不会被回收
        console.log('Closure executed');
    };
}

// 解决方案 - 明确清理不需要的引用
function createProperClosure() {
    let largeData = new Array(1000000).fill('data'); // 使用let，可以重新赋值
    
    return function() {
        // 使用完后清理大对象
        if (largeData) {
            largeData = null; // 清空引用
        }
        console.log('Closure executed');
    };
}
```

### 5. DOM节点引用泄漏

保持对已从DOM中移除的节点的引用，会导致这些节点无法被垃圾回收。

```javascript
// 问题代码
let nodeReferences = [];

function addNodeToCollection() {
    const div = document.createElement('div');
    div.innerHTML = 'Some content';
    document.body.appendChild(div);
    
    // 将DOM节点保存在数组中
    nodeReferences.push(div);
    
    // 即使从DOM中移除了div，由于nodeReferences的存在，它仍会被保持在内存中
    div.remove();
    // div仍然在nodeReferences数组中，不会被回收
}

// 解决方案 - 管理DOM引用
function manageDOMReferences() {
    const nodeReferences = new Set();
    
    function addNode() {
        const div = document.createElement('div');
        div.innerHTML = 'Some content';
        document.body.appendChild(div);
        
        nodeReferences.add(div);
        
        return function removeNode() {
            nodeReferences.delete(div);
            if (div.parentNode) {
                div.parentNode.removeChild(div);
            }
        };
    }
    
    return { addNode };
}
```

### 6. 控制台日志记录对象

在开发工具控制台中记录大对象，可能会导致这些对象被保持在内存中。

```javascript
// 问题代码
const largeObject = {
    data: new Array(1000000).fill('data'),
    metadata: { created: new Date(), version: '1.0' }
};

console.log(largeObject); // 控制台会保持对largeObject的引用

// 解决方案 - 避免在生产环境中记录大对象
function safeLogging(obj) {
    if (process.env.NODE_ENV === 'development') {
        console.log(obj);
    } else {
        // 生产环境只记录必要信息
        console.log('Object processed');
    }
}
```

### 7. 没有清理的观察者模式

使用观察者模式或发布订阅模式时，如果没有正确清理订阅，会导致内存泄漏。

```javascript
// 问题代码
class EventObserver {
    constructor() {
        this.subscribers = new Map();
    }
    
    subscribe(event, callback) {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }
        this.subscribers.get(event).push(callback);
    }
    
    notify(event, data) {
        const callbacks = this.subscribers.get(event) || [];
        callbacks.forEach(callback => callback(data));
    }
    
    // 没有提供取消订阅的方法
}

// 解决方案 - 提供取消订阅功能
class ProperEventObserver {
    constructor() {
        this.subscribers = new Map();
    }
    
    subscribe(event, callback) {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, new Set());
        }
        this.subscribers.get(event).add(callback);
        
        // 返回取消订阅函数
        return () => {
            const callbacks = this.subscribers.get(event);
            if (callbacks) {
                callbacks.delete(callback);
                if (callbacks.size === 0) {
                    this.subscribers.delete(event);
                }
            }
        };
    }
    
    notify(event, data) {
        const callbacks = this.subscribers.get(event);
        if (callbacks) {
            callbacks.forEach(callback => callback(data));
        }
    }
    
    clear() {
        this.subscribers.clear();
    }
}
```

### 8. 缓存未清理

不适当的缓存策略，特别是没有过期机制的缓存，会导致内存持续增长。

```javascript
// 问题代码 - 没有大小限制的缓存
const cache = new Map();

function expensiveOperation(key) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    
    const result = performExpensiveCalculation(key);
    cache.set(key, result); // 缓存结果，但没有清理机制
    return result;
}

// 解决方案 - 实现有限大小的LRU缓存
class LRUCache {
    constructor(maxSize = 100) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }
    
    get(key) {
        if (this.cache.has(key)) {
            const value = this.cache.get(key);
            // 更新访问顺序
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return undefined;
    }
    
    set(key, value) {
        if (this.cache.size >= this.maxSize) {
            // 删除最久未使用的项
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
    
    clear() {
        this.cache.clear();
    }
}
```

### 如何避免内存泄漏

1. **及时清理事件监听器**：在组件销毁或不再需要时移除事件监听器
2. **清理定时器**：使用 `clearInterval` 和 `clearTimeout` 清理定时器
3. **避免意外的全局变量**：始终使用 `let`、`const` 或 `var` 声明变量
4. **合理使用闭包**：注意闭包对外部变量的引用
5. **管理DOM引用**：避免保持对已移除DOM节点的引用
6. **使用WeakMap和WeakSet**：当需要关联对象时，使用弱引用集合
7. **定期清理缓存**：实现适当的缓存清理策略

通过注意这些常见的内存泄漏场景并采取预防措施，可以显著提高应用程序的性能和稳定性。
