# 移动端适配方案

## 概述

移动端适配是指让网页在不同尺寸、不同分辨率的移动设备上都能正常显示和使用的技术方案。由于移动设备的屏幕尺寸和分辨率差异巨大，需要采用合适的适配策略来保证用户体验的一致性。

## 主流适配方案

### 1. viewport + rem 适配方案

这是目前最常用的适配方案之一，通过设置 viewport 和使用 rem 单位实现适配。

```html
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Viewport + Rem 适配</title>
</head>
<body>
  <div class="container">
    <h1 class="title">适配标题</h1>
    <p class="content">这是一段适配内容</p>
  </div>
</body>
</html>
```

```css
/* 设置根元素字体大小，1rem = 100px */
html {
  font-size: 100px; /* 以 iPhone 6/7/8 为基准（375px）, 37.5px = 0.375rem */
}

/* 媒体查询调整不同屏幕的根字体大小 */
@media screen and (min-width: 320px) {
  html {
    font-size: 85.33px; /* 320/375 * 100 */
  }
}

@media screen and (min-width: 375px) {
  html {
    font-size: 100px; /* iPhone 6/7/8 */
  }
}

@media screen and (min-width: 414px) {
  html {
    font-size: 110.4px; /* iPhone 6+/6s+/7+/8+ */
  }
}

.container {
  width: 3.75rem; /* 375px */
  padding: 0.2rem; /* 20px */
  margin: 0 auto;
}

.title {
  font-size: 0.4rem; /* 40px */
  margin-bottom: 0.2rem; /* 20px */
}

.content {
  font-size: 0.28rem; /* 28px */
  line-height: 1.5;
}
```

JavaScript 动态设置 rem 基准值：

```javascript
(function() {
  // 设计稿基准宽度（通常为iPhone 6/7/8的375px）
  const baseWidth = 375;
  
  function setRem() {
    // 获取当前设备的屏幕宽度
    const screenWidth = document.documentElement.clientWidth;
    
    // 计算缩放比例
    const scale = screenWidth / baseWidth;
    
    // 设置根元素字体大小
    document.documentElement.style.fontSize = 100 * scale + 'px';
  }
  
  // 初始化
  setRem();
  
  // 监听屏幕变化
  window.addEventListener('resize', setRem);
  window.addEventListener('orientationchange', setRem);
})();
```

### 2. vw/vh 适配方案

使用 CSS3 的视口单位 vw 和 vh，无需 JavaScript，纯 CSS 解决方案。

```css
/* 1vw = 1% of viewport width */
/* 1vh = 1% of viewport height */

.container {
  width: 100vw; /* 全屏宽度 */
  height: 100vh; /* 全屏高度 */
  padding: 5vw; /* 5% of viewport width */
}

.title {
  font-size: 4vw; /* 字体大小随屏幕宽度变化 */
  margin-bottom: 3vw;
}

.content {
  font-size: 2.8vw; /* 约28px在375px屏幕上 */
  line-height: 1.5;
}

/* 使用 calc() 进行复杂计算 */
.card {
  width: calc(100vw - 40px); /* 考虑边距的宽度 */
  margin: 20px auto;
}
```

使用 CSS 自定义属性增强适配：

```css
:root {
  /* 定义基准尺寸 */
  --base-font-size: calc(100vw / 3.75); /* 以375px为基准 */
  --base-padding: calc(var(--base-font-size) * 0.2); /* 20px基准 */
  --base-margin: calc(var(--base-font-size) * 0.1); /* 10px基准 */
}

.container {
  padding: var(--base-padding);
  margin: var(--base-margin);
}

.title {
  font-size: calc(var(--base-font-size) * 0.4); /* 40px基准 */
}

.content {
  font-size: calc(var(--base-font-size) * 0.28); /* 28px基准 */
  line-height: 1.5;
}
```

### 3. flexible.js 方案

阿里早期提出的适配方案，通过动态设置 viewport 和 rem 来适配。

```javascript
// flexible.js 简化版实现
(function flexible(window, document) {
  var docEl = document.documentElement;
  var dpr = window.devicePixelRatio || 1;
  
  // 设置 data-dpr 属性
  docEl.setAttribute('data-dpr', dpr);
  
  // 设置缩放
  var scale = 1 / dpr;
  var metaEl = document.createElement('meta');
  metaEl.setAttribute('name', 'viewport');
  metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');
  if (docEl.firstElementChild) {
    docEl.firstElementChild.appendChild(metaEl);
  } else {
    var wrap = document.createElement('div');
    wrap.appendChild(metaEl);
    document.write(wrap.innerHTML);
  }
  
  function refreshRem() {
    var width = docEl.getBoundingClientRect().width;
    if (width / dpr > 540) {
      width = 540 * dpr;
    }
    var rem = width / 10;
    docEl.style.fontSize = rem + 'px';
  }
  
  refreshRem();
  window.addEventListener('resize', refreshRem);
  window.addEventListener('pageshow', function(e) {
    if (e.persisted) {
      refreshRem();
    }
  });
})(window, document);
```

CSS 使用：

```css
/* 使用 rem 单位进行布局 */
.container {
  width: 7.5rem; /* 750设计稿的100% */
  padding: 0.2rem; /* 20px */
}

.title {
  font-size: 0.4rem; /* 40px */
}

/* 针对不同 dpr 设备的特殊处理 */
[data-dpr="2"] .title {
  font-size: 0.8rem; /* 2倍屏 */
}

[data-dpr="3"] .title {
  font-size: 1.2rem; /* 3倍屏 */
}
```

### 4. PostCSS 插件适配方案

使用 postcss-pxtorem 等插件自动转换 px 到 rem。

```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-pxtorem')({
      rootValue: 37.5, // 设计稿宽度/10，如375/10=37.5
      propList: ['*'], // 需要转换的属性，*表示所有
      selectorBlackList: ['.ignore'], // 忽略的选择器
      minPixelValue: 2, // 小于2px的不转换
      mediaQuery: false, // 媒体查询中的px不转换
      exclude: /node_modules/i // 排除node_modules文件夹
    })
  ]
}
```

```css
/* 编译前 */
.container {
  width: 375px;
  padding: 20px;
  font-size: 16px;
}

/* 编译后 */
.container {
  width: 10rem; /* 375/37.5 */
  padding: 0.53333rem; /* 20/37.5 */
  font-size: 0.42667rem; /* 16/37.5 */
}
```

### 5. 响应式设计适配方案

使用媒体查询针对不同屏幕尺寸提供不同样式。

```css
/* 基础样式 */
.container {
  width: 100%;
  padding: 10px;
  font-size: 16px;
}

/* 小屏幕设备 (iPhone SE等) */
@media screen and (max-width: 320px) {
  .container {
    padding: 8px;
    font-size: 14px;
  }
}

/* 中等屏幕设备 (iPhone 6/7/8等) */
@media screen and (min-width: 375px) and (max-width: 413px) {
  .container {
    padding: 12px;
    font-size: 16px;
  }
}

/* 大屏幕设备 (iPhone 6+/6s+/7+/8+等) */
@media screen and (min-width: 414px) {
  .container {
    padding: 15px;
    font-size: 18px;
  }
}

/* 超大屏幕设备 (iPad等) */
@media screen and (min-width: 768px) {
  .container {
    width: 80%;
    max-width: 600px;
    padding: 20px;
    font-size: 18px;
    margin: 0 auto;
  }
}
```

## 各方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| viewport + rem | 兼容性好，支持老版本浏览器 | 需要 JavaScript 支持 | 老项目改造，需要兼容低版本浏览器 |
| vw/vh | 纯 CSS 解决，无需 JS | IE9-11 支持有限 | 现代项目，对兼容性要求不高 |
| flexible.js | 适配精度高 | 需要引入额外 JS，可能影响性能 | 对适配精度要求极高的项目 |
| PostCSS 插件 | 开发体验好，自动转换 | 需要构建工具支持 | 现代前端项目构建 |
| 响应式设计 | 灵活性高，控制精确 | 代码量大，维护成本高 | 需要针对不同设备做特殊处理 |

## 实际项目中的最佳实践

```javascript
// 移动端适配工具类
class MobileAdapter {
  constructor(options = {}) {
    this.designWidth = options.designWidth || 375; // 设计稿宽度
    this.rem2px = options.rem2px || 100; // 1rem 对应的 px 值
    this.maxWidth = options.maxWidth || 540; // 最大适配宽度
    
    this.init();
  }
  
  init() {
    this.setRootFontSize();
    this.bindEvents();
  }
  
  setRootFontSize() {
    const screenWidth = window.innerWidth || document.documentElement.clientWidth;
    const dpr = window.devicePixelRatio || 1;
    
    // 限制最大适配宽度
    const width = Math.min(screenWidth, this.maxWidth);
    
    // 计算 rem 值
    const rem = (width / this.designWidth) * this.rem2px;
    
    // 设置根元素字体大小
    document.documentElement.style.fontSize = rem + 'px';
    document.documentElement.setAttribute('data-dpr', dpr);
  }
  
  bindEvents() {
    // 防抖函数
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };
    
    // 监听窗口变化
    window.addEventListener('resize', debounce(() => {
      this.setRootFontSize();
    }, 100));
    
    window.addEventListener('orientationchange', debounce(() => {
      setTimeout(() => {
        this.setRootFontSize();
      }, 100);
    }, 100));
  }
  
  // px 转 rem 工具方法
  px2rem(px) {
    return px / this.rem2px;
  }
  
  // rem 转 px 工具方法
  rem2px(rem) {
    return rem * this.rem2px;
  }
}

// 使用示例
const adapter = new MobileAdapter({
  designWidth: 375,
  rem2px: 100
});
```

## 注意事项

1. **字体大小**：避免使用 rem 设置字体大小，可能导致字体过小或过大
2. **1px 边框**：在高清屏上实现真正的 1px 边框
3. **性能考虑**：避免频繁触发重排重绘
4. **兼容性测试**：在不同设备和浏览器上测试适配效果
5. **设计稿标注**：与设计师确认设计稿尺寸和标注规范

通过以上各种适配方案的合理运用，可以有效解决移动端的适配问题，提升用户体验。