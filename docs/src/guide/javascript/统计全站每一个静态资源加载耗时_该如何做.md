# 统计全站每一个静态资源加载耗时，该如何做？（了解）

## 前端性能监控概述

前端性能监控是现代Web应用优化的重要组成部分，通过监控静态资源的加载耗时，可以识别性能瓶颈，优化用户体验。

## 统计静态资源加载耗时的方法

### 1. 使用 Performance API

Performance API 是浏览器原生提供的性能监控接口，可以获取详细的资源加载时间信息。

```javascript
// 获取所有资源的性能信息
function getResourceTiming() {
  const resources = performance.getEntriesByType('resource');
  
  resources.forEach(resource => {
    console.log('资源名称:', resource.name);
    console.log('开始时间:', resource.startTime);
    console.log('DNS查询时间:', resource.domainLookupEnd - resource.domainLookupStart);
    console.log('TCP连接时间:', resource.connectEnd - resource.connectStart);
    console.log('请求响应时间:', resource.responseEnd - resource.requestStart);
    console.log('内容下载时间:', resource.responseEnd - resource.responseStart);
    console.log('总耗时:', resource.responseEnd);
    console.log('-------------------');
  });
}

// 页面加载完成后获取资源信息
window.addEventListener('load', () => {
  setTimeout(getResourceTiming, 0); // 确保资源信息已收集完成
});
```

### 2. PerformanceObserver API

使用 PerformanceObserver 可以实时监听资源加载事件：

```javascript
// 实时监听资源加载
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.entryType === 'resource') {
      const resourceData = {
        url: entry.name,
        startTime: entry.startTime,
        duration: entry.duration,
        size: entry.transferSize || entry.encodedBodySize,
        type: getResourceType(entry.name),
        loadTime: entry.responseEnd - entry.startTime
      };
      
      // 发送数据到监控系统
      sendPerformanceData(resourceData);
    }
  });
});

// 监听资源类型
observer.observe({ entryTypes: ['resource'] });

// 根据URL判断资源类型
function getResourceType(url) {
  if (/\.(js)$/.test(url)) return 'script';
  if (/\.(css)$/.test(url)) return 'stylesheet';
  if (/\.(png|jpe?g|gif|svg|webp)$/.test(url)) return 'image';
  if (/\.(woff2?|ttf|eot)$/.test(url)) return 'font';
  if (/\.(json)$/.test(url)) return 'json';
  return 'other';
}
```

### 3. Resource Timing API 详细指标

```javascript
// 获取详细的资源加载时间指标
function getDetailedResourceMetrics(entry) {
  return {
    // 重定向时间
    redirectTime: entry.redirectEnd - entry.redirectStart,
    
    // DNS查询时间
    dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
    
    // TCP连接时间
    tcpTime: entry.connectEnd - entry.connectStart,
    
    // SSL握手时间
    sslTime: entry.secureConnectionStart > 0 ? 
      entry.connectEnd - entry.secureConnectionStart : 0,
    
    // 请求时间
    requestTime: entry.responseStart - entry.requestStart,
    
    // 响应时间
    responseTime: entry.responseEnd - entry.responseStart,
    
    // 总加载时间
    totalTime: entry.responseEnd - entry.startTime,
    
    // 资源大小
    size: entry.encodedBodySize,
    transferSize: entry.transferSize
  };
}
```

### 4. 监控所有静态资源的完整实现

```javascript
class ResourceMonitor {
  constructor(options = {}) {
    this.options = {
      collectInterval: options.collectInterval || 5000, // 收集间隔
      reportUrl: options.reportUrl || '/api/performance', // 上报地址
      enableCompression: options.enableCompression || false, // 是否启用压缩
      ...options
    };
    
    this.resourceMap = new Map();
    this.init();
  }
  
  init() {
    // 使用 PerformanceObserver 监听资源加载
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver(this.handleResource.bind(this));
      this.observer.observe({ entryTypes: ['resource'] });
    }
    
    // 页面隐藏时上报数据
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        this.reportData();
      }
    });
    
    // 页面卸载时上报数据
    window.addEventListener('beforeunload', () => {
      this.reportData();
    });
  }
  
  handleResource(list) {
    list.getEntries().forEach(entry => {
      if (entry.entryType === 'resource') {
        const resourceInfo = this.extractResourceInfo(entry);
        this.resourceMap.set(entry.name, resourceInfo);
        
        // 触发自定义事件
        this.dispatchResourceEvent('resourceLoaded', resourceInfo);
      }
    });
  }
  
  extractResourceInfo(entry) {
    return {
      url: entry.name,
      type: this.getResourceType(entry.name),
      startTime: entry.startTime,
      duration: entry.duration,
      size: entry.encodedBodySize || 0,
      transferSize: entry.transferSize || 0,
      
      // 详细时间指标
      timing: {
        redirect: entry.redirectEnd - entry.redirectStart,
        dns: entry.domainLookupEnd - entry.domainLookupStart,
        tcp: entry.connectEnd - entry.connectStart,
        ssl: entry.secureConnectionStart > 0 ? 
          entry.connectEnd - entry.secureConnectionStart : 0,
        request: entry.responseStart - entry.requestStart,
        response: entry.responseEnd - entry.responseStart,
        totalTime: entry.responseEnd - entry.startTime
      },
      
      // 额外信息
      timestamp: Date.now(),
      origin: window.location.origin
    };
  }
  
  getResourceType(url) {
    const ext = url.split('.').pop().toLowerCase();
    const typeMap = {
      'js': 'script',
      'css': 'stylesheet',
      'png': 'image',
      'jpg': 'image',
      'jpeg': 'image',
      'gif': 'image',
      'svg': 'image',
      'webp': 'image',
      'woff': 'font',
      'woff2': 'font',
      'ttf': 'font',
      'eot': 'font',
      'json': 'json',
      'xml': 'xml'
    };
    
    return typeMap[ext] || 'other';
  }
  
  dispatchResourceEvent(type, data) {
    const event = new CustomEvent(`resource:${type}`, { detail: data });
    document.dispatchEvent(event);
  }
  
  // 上报性能数据
  async reportData() {
    if (this.resourceMap.size === 0) return;
    
    const resources = Array.from(this.resourceMap.values());
    
    try {
      // 发送数据到服务端
      await fetch(this.options.reportUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          pageUrl: window.location.href,
          timestamp: Date.now(),
          resources: resources,
          userAgent: navigator.userAgent
        })
      });
      
      // 清空已上报的数据
      this.resourceMap.clear();
    } catch (error) {
      console.error('性能数据上报失败:', error);
    }
  }
  
  // 获取当前统计的资源
  getResources() {
    return Array.from(this.resourceMap.values());
  }
  
  // 销毁监听器
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// 使用示例
const monitor = new ResourceMonitor({
  reportUrl: '/api/performance/resource'
});

// 监听资源加载事件
document.addEventListener('resource:resourceLoaded', (event) => {
  console.log('资源加载完成:', event.detail);
});
```

### 5. 第三方监控工具集成

```javascript
// 集成第三方监控工具（如 Sentry、New Relic 等）
function integrateWithThirdParty() {
  // 使用 Web Vitals 库监控核心指标
  import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
    getCLS(sendToAnalytics);
    getFID(sendToAnalytics);
    getFCP(sendToAnalytics);
    getLCP(sendToAnalytics);
    getTTFB(sendToAnalytics);
  });
  
  function sendToAnalytics(metric) {
    // 发送到分析服务
    console.log('Performance Metric:', metric);
  }
}
```

### 6. 自定义资源加载监控

```javascript
// 自定义资源加载监控（适用于动态加载的资源）
class CustomResourceLoader {
  constructor() {
    this.loadHistory = [];
  }
  
  async loadScript(src) {
    const startTime = performance.now();
    const controller = new AbortController();
    
    try {
      const script = document.createElement('script');
      script.src = src;
      
      return new Promise((resolve, reject) => {
        script.onload = () => {
          const endTime = performance.now();
          this.recordResourceLoad({
            url: src,
            type: 'script',
            startTime,
            endTime,
            duration: endTime - startTime,
            status: 'success'
          });
          resolve(script);
        };
        
        script.onerror = () => {
          const endTime = performance.now();
          this.recordResourceLoad({
            url: src,
            type: 'script',
            startTime,
            endTime,
            duration: endTime - startTime,
            status: 'error'
          });
          reject(new Error(`Script load failed: ${src}`));
        };
        
        document.head.appendChild(script);
      });
    } catch (error) {
      const endTime = performance.now();
      this.recordResourceLoad({
        url: src,
        type: 'script',
        startTime,
        endTime,
        duration: endTime - startTime,
        status: 'error',
        error: error.message
      });
      throw error;
    }
  }
  
  recordResourceLoad(record) {
    this.loadHistory.push(record);
    
    // 如果超过阈值，上报数据
    if (this.loadHistory.length >= 10) {
      this.reportLoadHistory();
    }
  }
  
  reportLoadHistory() {
    // 上报加载历史
    console.log('Resource Load History:', this.loadHistory);
    this.loadHistory = []; // 清空历史记录
  }
}
```

## 数据上报策略

### 1. 实时上报
- 优点：数据实时性高
- 缺点：可能影响性能，网络请求频繁

### 2. 批量上报
- 优点：减少网络请求，提高效率
- 缺点：数据有一定延迟

### 3. 按需上报
- 优点：在合适的时机上报，平衡性能和实时性
- 推荐使用页面隐藏或卸载时上报

## 注意事项

1. **性能影响**：监控代码本身不应影响页面性能
2. **隐私合规**：注意收集的数据是否涉及用户隐私
3. **数据采样**：对于高流量网站，可考虑采样上报
4. **错误处理**：确保监控代码的健壮性
5. **跨域资源**：跨域资源可能无法获取详细时间信息

## 监控指标总结

- DNS查询时间
- TCP连接时间
- SSL握手时间
- 请求响应时间
- 内容下载时间
- 资源大小
- 总加载时间
- 缓存命中情况

通过以上方法，可以全面监控全站静态资源的加载耗时，为性能优化提供数据支持。
