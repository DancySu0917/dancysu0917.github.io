# 什么是中间件？（高薪常问）

**题目**: 什么是中间件？（高薪常问）

## 标准答案

中间件（Middleware）是一种软件组件，位于客户端和服务器之间，用于处理请求和响应的流程。在Web开发中，中间件是一个函数，可以访问请求对象（request）、响应对象（response）和下一个中间件函数（next）。中间件的主要功能包括请求预处理、身份验证、日志记录、错误处理、路由匹配等。中间件按照定义的顺序执行，形成一个处理管道，每个中间件可以选择结束请求/响应循环或调用下一个中间件。

## 深入分析

### 中间件的核心概念

中间件本质上是一个函数，接收三个参数：请求对象（req）、响应对象（res）和下一个中间件函数（next）。中间件函数可以执行以下任务：

1. 执行任何代码
2. 修改请求和响应对象
3. 结束请求-响应周期
4. 调用下一个中间件函数

### 中间件的执行流程

中间件按照定义的顺序形成一个执行链（pipeline），请求按照顺序通过每个中间件，响应则按相反顺序返回。这种机制使得中间件可以对请求进行预处理，对响应进行后处理。

### 中间件的类型

1. **应用级中间件**：绑定到应用实例的中间件
2. **路由级中间件**：绑定到Router实例的中间件
3. **错误处理中间件**：专门处理错误的中间件，接收四个参数
4. **内置中间件**：框架内置的中间件
5. **第三方中间件**：外部库提供的中间件

### 中间件的优势

- **模块化**：将复杂逻辑拆分为可重用的组件
- **可组合性**：中间件可以灵活组合使用
- **职责分离**：不同中间件处理不同功能
- **可维护性**：便于测试和维护

## 代码实现

```javascript
// 1. 基础中间件实现
function basicMiddleware(req, res, next) {
  console.log('Time:', Date.now());
  req.requestTime = Date.now();
  next(); // 调用下一个中间件
}

// 2. Express风格的中间件系统实现
class ExpressLikeMiddleware {
  constructor() {
    this.middlewares = [];
  }

  // 使用中间件
  use(middleware) {
    this.middlewares.push(middleware);
  }

  // 处理请求
  async handleRequest(req, res) {
    let index = 0;
    const next = async () => {
      if (index >= this.middlewares.length) {
        return;
      }
      
      const middleware = this.middlewares[index++];
      await middleware(req, res, next);
    };
    
    await next();
  }
}

// 3. 身份验证中间件
function authMiddleware(req, res, next) {
  const token = req.headers.authorization;
  
  if (!token) {
    return res.status(401).json({ error: 'Unauthorized: No token provided' });
  }
  
  // 验证token（实际应用中会使用JWT等库）
  try {
    // 这里模拟token验证
    const isValid = validateToken(token);
    if (isValid) {
      req.user = getUserFromToken(token); // 将用户信息添加到请求对象
      next();
    } else {
      res.status(401).json({ error: 'Unauthorized: Invalid token' });
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
}

// 4. 日志中间件
function loggerMiddleware(req, res, next) {
  const startTime = Date.now();
  
  // 记录请求信息
  console.log(`${req.method} ${req.url} - ${new Date().toISOString()}`);
  
  // 监听响应结束事件
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    console.log(`${req.method} ${req.url} - ${res.statusCode} - ${duration}ms`);
  });
  
  next();
}

// 5. 错误处理中间件
function errorHandler(err, req, res, next) {
  console.error('Error:', err);
  
  if (res.headersSent) {
    return next(err);
  }
  
  res.status(500).json({
    error: {
      message: 'Internal Server Error',
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
}

// 6. CORS中间件
function corsMiddleware(req, res, next) {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
}

// 7. 请求体解析中间件
function bodyParserMiddleware(req, res, next) {
  if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
    let body = '';
    
    req.on('data', chunk => {
      body += chunk.toString();
    });
    
    req.on('end', () => {
      try {
        if (req.headers['content-type'] === 'application/json') {
          req.body = JSON.parse(body);
        } else {
          req.body = body;
        }
        next();
      } catch (error) {
        res.status(400).json({ error: 'Invalid JSON' });
      }
    });
  } else {
    next();
  }
}

// 8. 限流中间件
class RateLimiter {
  constructor(options = {}) {
    this.maxRequests = options.maxRequests || 100;
    this.windowMs = options.windowMs || 15 * 60 * 1000; // 15分钟
    this.clients = new Map();
  }

  middleware() {
    return (req, res, next) => {
      const clientId = req.ip || 'unknown';
      const now = Date.now();
      
      if (!this.clients.has(clientId)) {
        this.clients.set(clientId, []);
      }
      
      const requests = this.clients.get(clientId);
      
      // 清理过期请求
      const validRequests = requests.filter(time => now - time < this.windowMs);
      
      if (validRequests.length >= this.maxRequests) {
        return res.status(429).json({ error: 'Too Many Requests' });
      }
      
      validRequests.push(now);
      this.clients.set(clientId, validRequests);
      
      next();
    };
  }
}

// 9. 自定义中间件链实现
class MiddlewareChain {
  constructor() {
    this.middlewares = [];
  }

  use(fn) {
    this.middlewares.push(fn);
    return this;
  }

  async execute(req, res) {
    const run = (index = 0) => {
      if (index >= this.middlewares.length) {
        return Promise.resolve();
      }
      
      const middleware = this.middlewares[index];
      const next = () => run(index + 1);
      
      try {
        const result = middleware(req, res, next);
        if (result && typeof result.then === 'function') {
          return result.then(() => next()).catch(err => {
            // 如果有错误处理中间件，应该传递错误
            throw err;
          });
        } else {
          return next();
        }
      } catch (error) {
        throw error;
      }
    };
    
    return run();
  }
}

// 10. Koa风格的中间件实现（洋葱模型）
class KoaLikeApp {
  constructor() {
    this.middleware = [];
  }

  use(fn) {
    this.middleware.push(fn);
    return this;
  }

  async handleRequest(ctx) {
    const fn = this.compose(this.middleware);
    return fn(ctx);
  }

  compose(middleware) {
    if (!Array.isArray(middleware)) {
      throw new TypeError('Middleware stack must be an array!');
    }
    for (const fn of middleware) {
      if (typeof fn !== 'function') {
        throw new TypeError('Middleware must be composed of functions!');
      }
    }

    return function (context, next) {
      let index = -1;
      return dispatch(0);
      
      function dispatch(i) {
        if (i <= index) {
          return Promise.reject(new Error('next() called multiple times'));
        }
        index = i;
        let fn = middleware[i];
        if (i === middleware.length) fn = next;
        if (!fn) return Promise.resolve();
        try {
          return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
        } catch (err) {
          return Promise.reject(err);
        }
      }
    };
  }
}

// 11. 中间件使用示例
const app = new ExpressLikeMiddleware();

// 应用中间件
app.use(loggerMiddleware);
app.use(corsMiddleware);
app.use(bodyParserMiddleware);
app.use(RateLimiter({ maxRequests: 50, windowMs: 10000 }).middleware());
app.use(authMiddleware);

// 错误处理中间件应该放在最后
// app.use(errorHandler);

// 12. 自定义中间件示例
function customHeaderMiddleware(req, res, next) {
  res.setHeader('X-Powered-By', 'Custom-Server');
  next();
}

function requestIDMiddleware(req, res, next) {
  req.id = generateRequestId();
  res.setHeader('X-Request-ID', req.id);
  next();
}

function generateRequestId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// 13. 条件中间件
function conditionalMiddleware(condition, middleware) {
  return (req, res, next) => {
    if (condition(req)) {
      middleware(req, res, next);
    } else {
      next();
    }
  };
}

// 14. 中间件工厂函数
function createValidator(validationSchema) {
  return (req, res, next) => {
    try {
      // 这里应该使用实际的验证库如Joi、Yup等
      const isValid = validateAgainstSchema(req.body, validationSchema);
      if (isValid) {
        next();
      } else {
        res.status(400).json({ error: 'Validation failed' });
      }
    } catch (error) {
      res.status(500).json({ error: 'Validation error' });
    }
  };
}

// 15. 综合示例：构建一个完整的中间件系统
class WebFramework {
  constructor() {
    this.middlewares = [];
    this.routes = [];
  }

  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }

  get(path, handler) {
    this.routes.push({ method: 'GET', path, handler });
    return this;
  }

  post(path, handler) {
    this.routes.push({ method: 'POST', path, handler });
    return this;
  }

  async handleRequest(req, res) {
    // 执行中间件
    await this.executeMiddlewares(req, res);
    
    // 匹配路由
    const route = this.routes.find(r => 
      r.method === req.method && this.matchPath(r.path, req.url)
    );
    
    if (route) {
      route.handler(req, res);
    } else {
      res.status(404).send('Not Found');
    }
  }

  async executeMiddlewares(req, res) {
    for (const middleware of this.middlewares) {
      await new Promise((resolve, reject) => {
        middleware(req, res, () => resolve());
      });
    }
  }

  matchPath(routePath, requestPath) {
    // 简单路径匹配，实际应用中可能需要更复杂的路由匹配
    return routePath === requestPath;
  }
}

// 使用示例
const framework = new WebFramework();
framework.use(loggerMiddleware);
framework.use(corsMiddleware);
framework.use(bodyParserMiddleware);

framework.get('/api/users', (req, res) => {
  res.json({ users: [] });
});

framework.post('/api/users', (req, res) => {
  res.json({ message: 'User created', data: req.body });
});

// 辅助函数
function validateToken(token) {
  // 模拟token验证
  return token.startsWith('Bearer ');
}

function getUserFromToken(token) {
  // 模拟从token获取用户信息
  return { id: 1, name: 'John Doe' };
}

function validateAgainstSchema(data, schema) {
  // 模拟数据验证
  return true;
}
```

## 实际应用场景

1. **API服务认证**: 使用JWT中间件验证用户身份，保护API端点。

2. **日志记录**: 记录所有请求的详细信息，用于监控和调试。

3. **跨域处理**: 处理CORS请求，允许前端跨域访问API。

4. **请求限流**: 防止API被恶意请求攻击，保护服务稳定性。

5. **数据验证**: 验证请求参数格式和内容，确保数据完整性。

6. **错误处理**: 统一处理应用错误，返回格式化的错误信息。

7. **静态文件服务**: 处理静态资源请求，如CSS、JS、图片等。

8. **会话管理**: 管理用户会话状态，维护登录状态。

9. **安全防护**: 防止SQL注入、XSS攻击等安全威胁。

10. **性能监控**: 监控请求响应时间，收集性能指标。
