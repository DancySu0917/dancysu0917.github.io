# 在前端应用如何进行权限设计？（了解）

**题目**: 在前端应用如何进行权限设计？（了解）

**答案**:

前端权限设计是构建安全、可维护的 Web 应用的关键环节。以下是完整的前端权限设计方案：

## 1. 权限模型设计

### RBAC (Role-Based Access Control) 模型
```javascript
// 权限数据结构示例
const permissionModel = {
  user: {
    id: 1,
    name: 'John Doe',
    roles: ['admin', 'editor'],
    permissions: ['read', 'write', 'delete']
  },
  roles: {
    admin: ['read', 'write', 'delete', 'manage_users'],
    editor: ['read', 'write'],
    viewer: ['read']
  }
}
```

### 权限层级结构
```
用户 (User)
├── 角色 (Role)
│   ├── 权限 (Permission)
│   │   ├── 页面权限 (Page Access)
│   │   ├── 操作权限 (Action Access)
│   │   └── 数据权限 (Data Access)
```

## 2. 权限数据管理

### 使用状态管理 (Redux/Vuex/Zustand)
```javascript
// Redux 示例
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    permissions: [],
    roles: [],
    isAuthenticated: false
  },
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload.user
      state.permissions = action.payload.permissions
      state.roles = action.payload.roles
      state.isAuthenticated = true
    },
    clearUser: (state) => {
      state.user = null
      state.permissions = []
      state.roles = []
      state.isAuthenticated = false
    }
  }
})

// 权限检查函数
export const hasPermission = (permission) => (state) => {
  return state.auth.permissions.includes(permission)
}

export const hasRole = (role) => (state) => {
  return state.auth.roles.includes(role)
}
```

## 3. 权限验证组件

### Vue 权限指令
```vue
<!-- 自定义权限指令 -->
<script>
export default {
  directives: {
    permission: {
      mounted(el, binding) {
        const { value } = binding
        const permissions = this.$store.getters['user/permissions']
        
        if (value && !permissions.includes(value)) {
          el.style.display = 'none'
        }
      }
    }
  }
}
</script>

<template>
  <div>
    <button v-permission="'create_post'">创建文章</button>
    <button v-permission="'edit_post'">编辑文章</button>
  </div>
</template>
```

### React 权限高阶组件 (HOC)
```jsx
// 权限高阶组件
const withPermission = (WrappedComponent, requiredPermission) => {
  return function PermissionComponent(props) {
    const { permissions } = useAuth()
    
    if (!permissions.includes(requiredPermission)) {
      return <div>无权限访问</div>
    }
    
    return <WrappedComponent {...props} />
  }
}

// 使用示例
const ProtectedButton = withPermission(Button, 'create_post')
```

### React 权限 Hook
```jsx
// 自定义权限 Hook
function usePermission(permission) {
  const { permissions } = useAuth()
  return permissions.includes(permission)
}

// 使用示例
function PostActions() {
  const canCreate = usePermission('create_post')
  const canEdit = usePermission('edit_post')
  const canDelete = usePermission('delete_post')
  
  return (
    <div>
      {canCreate && <button>创建</button>}
      {canEdit && <button>编辑</button>}
      {canDelete && <button>删除</button>}
    </div>
  )
}
```

## 4. 路由权限控制

### Vue Router 权限控制
```javascript
// 路由守卫
router.beforeEach(async (to, from, next) => {
  const token = localStorage.getItem('token')
  
  if (token) {
    const user = store.getters['user/info']
    
    if (!user) {
      // 获取用户信息
      await store.dispatch('user/getInfo')
    }
    
    const userPermissions = store.getters['user/permissions']
    
    // 检查路由权限
    if (to.meta.permission && !userPermissions.includes(to.meta.permission)) {
      next('/403') // 无权限页面
    } else {
      next()
    }
  } else if (to.path !== '/login') {
    next('/login')
  } else {
    next()
  }
})

// 动态路由
function generateRoutes(roles) {
  const accessedRoutes = []
  const allRoutes = [
    // 所有路由配置
  ]
  
  roles.forEach(role => {
    const route = allRoutes.filter(route => route.role.includes(role))
    accessedRoutes.push(...route)
  })
  
  return accessedRoutes
}
```

### React Router 权限控制
```jsx
// 权限路由组件
function ProtectedRoute({ children, requiredPermission }) {
  const { isAuthenticated, permissions } = useAuth()
  const location = useLocation()
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }
  
  if (requiredPermission && !permissions.includes(requiredPermission)) {
    return <Navigate to="/403" replace />
  }
  
  return children
}

// 路由配置
function App() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route path="/dashboard" element={
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      } />
      <Route path="/admin" element={
        <ProtectedRoute requiredPermission="admin">
          <AdminPanel />
        </ProtectedRoute>
      } />
    </Routes>
  )
}
```

## 5. 权限数据获取策略

### 应用启动时获取
```javascript
// 应用初始化时获取权限数据
async function initializeApp() {
  const token = localStorage.getItem('token')
  
  if (token) {
    try {
      // 获取用户信息和权限
      const userInfo = await api.getUserInfo()
      const permissions = await api.getUserPermissions()
      
      // 存储到状态管理中
      store.dispatch('auth/setUser', {
        user: userInfo,
        permissions: permissions
      })
    } catch (error) {
      // 获取失败，清除 token
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
  }
}

// 在应用启动时调用
initializeApp()
```

### 路由切换时获取
```javascript
// 路由切换时检查权限更新
router.beforeEach(async (to, from, next) => {
  // 检查权限是否过期
  const lastFetchTime = localStorage.getItem('permissions_last_fetch')
  const now = Date.now()
  
  // 如果权限数据超过30分钟未更新，则重新获取
  if (now - lastFetchTime > 30 * 60 * 1000) {
    await store.dispatch('user/refreshPermissions')
  }
  
  next()
})
```

## 6. 权限缓存策略

```javascript
// 权限缓存管理
class PermissionCache {
  constructor() {
    this.cache = new Map()
    this.cacheTimeout = 30 * 60 * 1000 // 30分钟过期
  }
  
  set(userId, permissions) {
    this.cache.set(userId, {
      permissions,
      timestamp: Date.now()
    })
  }
  
  get(userId) {
    const cached = this.cache.get(userId)
    if (!cached) return null
    
    if (Date.now() - cached.timestamp > this.cacheTimeout) {
      this.cache.delete(userId)
      return null
    }
    
    return cached.permissions
  }
  
  clear() {
    this.cache.clear()
  }
}

const permissionCache = new PermissionCache()
```

## 7. 权限更新机制

```javascript
// 权限更新事件
class PermissionManager {
  constructor() {
    this.subscribers = []
  }
  
  subscribe(callback) {
    this.subscribers.push(callback)
  }
  
  unsubscribe(callback) {
    this.subscribers = this.subscribers.filter(sub => sub !== callback)
  }
  
  notify(permissions) {
    this.subscribers.forEach(callback => callback(permissions))
  }
  
  async updatePermissions(userId) {
    const newPermissions = await api.getUserPermissions(userId)
    this.notify(newPermissions)
    permissionCache.set(userId, newPermissions)
  }
}

const permissionManager = new PermissionManager()
```

## 8. 安全最佳实践

### 客户端权限仅用于用户体验
```javascript
// 重要：客户端权限控制仅用于改善用户体验
// 所有关键权限验证必须在服务端进行
const clientPermissionCheck = (permission) => {
  // 仅用于控制 UI 显示
  return user.permissions.includes(permission)
}

const serverPermissionCheck = async (permission) => {
  // 关键操作必须通过服务端验证
  const response = await api.checkPermission(permission)
  return response.data.allowed
}
```

### 权限最小化原则
```javascript
// 遵循权限最小化原则
const minimalPermissions = {
  'read_only_user': ['read'],
  'content_editor': ['read', 'write'],
  'moderator': ['read', 'write', 'moderate'],
  'admin': ['read', 'write', 'delete', 'manage_users', 'system_config']
}
```

## 9. 权限调试和监控

```javascript
// 权限调试工具
const PermissionDebugger = {
  logPermissionCheck(permission, result) {
    console.group(`Permission Check: ${permission}`)
    console.log('Result:', result)
    console.log('User Permissions:', this.getCurrentUserPermissions())
    console.groupEnd()
  },
  
  checkPermission(permission) {
    const result = this.hasPermission(permission)
    this.logPermissionCheck(permission, result)
    return result
  }
}
```

通过以上方案，可以构建一个完整的前端权限管理体系，确保应用的安全性和可维护性。记住，前端权限控制主要是为了提升用户体验，真正的安全验证必须在服务端进行。
