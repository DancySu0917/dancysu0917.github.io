# 防止前端页面重复请求？（了解）

**题目**: 防止前端页面重复请求？（了解）

## 标准答案

防止前端页面重复请求的常见方法包括：请求去重（使用请求URL+参数作为唯一标识）、请求节流（限制相同请求的并发数量）、请求缓存（对相同请求返回缓存结果）、按钮禁用（UI层面防止重复点击）和请求取消（取消之前的相同请求）。其中，请求去重和请求缓存是最常用且有效的方案。

## 深入理解

### 1. 重复请求的产生原因
重复请求通常由以下原因造成：用户快速点击按钮、网络延迟导致用户重复操作、页面刷新或重新加载、多个组件同时发起相同请求、竞态条件等。这些重复请求不仅浪费服务器资源，还可能导致数据不一致或用户体验问题。

### 2. 请求去重机制
请求去重通过为每个请求生成唯一标识符来避免重复请求。通常使用请求方法、URL和参数的组合来创建标识符。当检测到相同标识符的请求正在进行时，新请求会被忽略或排队等待。

### 3. 请求缓存策略
请求缓存可以有效避免重复请求，特别是对于相同参数的GET请求。可以使用内存缓存、localStorage或专门的缓存库来存储请求结果，并在一定时间内对相同请求返回缓存结果。

### 4. UI层面的防护
在UI层面，可以通过按钮禁用、加载状态显示、防抖节流等方式防止用户重复触发请求。这是用户体验优化的重要方面，可以在请求发起期间禁用相关操作按钮。

## 代码演示

```javascript
// 1. 请求去重管理器
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map(); // 存储进行中的请求
  }
  
  // 生成请求唯一标识
  generateRequestKey(config) {
    const { method = 'GET', url, params = {}, data = {} } = config;
    const sortedParams = Object.keys(params)
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');
    
    const sortedData = method.toUpperCase() === 'GET' 
      ? '' 
      : JSON.stringify(data, Object.keys(data).sort());
    
    return `${method.toUpperCase()}:${url}?${sortedParams}#${sortedData}`;
  }
  
  // 发起请求（带去重）
  async request(config) {
    const key = this.generateRequestKey(config);
    
    // 如果相同请求正在进行，返回已有的Promise
    if (this.pendingRequests.has(key)) {
      console.log(`Duplicate request detected for: ${key}`);
      return this.pendingRequests.get(key);
    }
    
    // 创建新的请求Promise
    const requestPromise = this.makeRequest(config)
      .finally(() => {
        // 请求完成后从pending列表中移除
        this.pendingRequests.delete(key);
      });
    
    // 存储请求Promise
    this.pendingRequests.set(key, requestPromise);
    
    return requestPromise;
  }
  
  // 实际的请求方法（这里用fetch模拟）
  async makeRequest(config) {
    const { url, method = 'GET', headers = {}, data } = config;
    
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      }
    };
    
    if (data && method.toUpperCase() !== 'GET') {
      options.body = JSON.stringify(data);
    }
    
    const response = await fetch(url, options);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
  
  // 取消所有pending请求
  cancelAllPendingRequests() {
    this.pendingRequests.clear();
  }
}

// 2. 带缓存的请求管理器
class CachedRequestManager {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();
    this.defaultCacheTime = 5 * 60 * 1000; // 默认缓存5分钟
  }
  
  // 生成缓存键
  generateCacheKey(config) {
    const { method = 'GET', url, params = {} } = config;
    const sortedParams = Object.keys(params)
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');
    
    return `${method.toUpperCase()}:${url}?${sortedParams}`;
  }
  
  // 设置缓存
  setCache(key, data, cacheTime) {
    const expireTime = Date.now() + (cacheTime || this.defaultCacheTime);
    this.cache.set(key, { data, expireTime });
  }
  
  // 获取缓存
  getCache(key) {
    const cached = this.cache.get(key);
    if (cached && Date.now() < cached.expireTime) {
      return cached.data;
    }
    // 过期则删除
    this.cache.delete(key);
    return null;
  }
  
  // 发起带缓存的请求
  async request(config, options = {}) {
    const cacheKey = this.generateCacheKey(config);
    const { cacheTime = this.defaultCacheTime, forceRefresh = false } = options;
    
    // 检查缓存（仅对GET请求）
    if (config.method?.toUpperCase() === 'GET' && !forceRefresh) {
      const cachedData = this.getCache(cacheKey);
      if (cachedData) {
        console.log('Returning cached data for:', cacheKey);
        return cachedData;
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pendingRequests.has(cacheKey)) {
      console.log('Waiting for pending request:', cacheKey);
      return this.pendingRequests.get(cacheKey);
    }
    
    // 创建新的请求Promise
    const requestPromise = this.makeRequest(config)
      .then(data => {
        // 请求成功后存入缓存（仅对GET请求）
        if (config.method?.toUpperCase() === 'GET') {
          this.setCache(cacheKey, data, cacheTime);
        }
        return data;
      })
      .finally(() => {
        this.pendingRequests.delete(cacheKey);
      });
    
    // 存储进行中的请求
    this.pendingRequests.set(cacheKey, requestPromise);
    
    return requestPromise;
  }
  
  // 实际请求方法
  async makeRequest(config) {
    const { url, method = 'GET', headers = {}, data } = config;
    
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      }
    };
    
    if (data && method.toUpperCase() !== 'GET') {
      options.body = JSON.stringify(data);
    }
    
    const response = await fetch(url, options);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
  
  // 清除缓存
  clearCache() {
    this.cache.clear();
  }
  
  // 清除过期缓存
  clearExpiredCache() {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now >= value.expireTime) {
        this.cache.delete(key);
      }
    }
  }
}

// 3. 按钮防重复点击的React Hook
import { useState, useCallback } from 'react';

function useRequestLock() {
  const [loading, setLoading] = useState(false);
  
  const executeRequest = useCallback(async (requestFn) => {
    if (loading) {
      console.log('Request is already in progress, ignoring...');
      return;
    }
    
    setLoading(true);
    try {
      const result = await requestFn();
      return result;
    } catch (error) {
      console.error('Request failed:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [loading]);
  
  return { loading, executeRequest };
}

// 使用示例
function UserComponent() {
  const [userData, setUserData] = useState(null);
  const { loading, executeRequest } = useRequestLock();
  const requestDeduplicator = new RequestDeduplicator();
  
  const fetchUserData = async () => {
    const response = await requestDeduplicator.request({
      method: 'GET',
      url: '/api/user',
      params: { id: 123 }
    });
    
    setUserData(response);
    return response;
  };
  
  const handleFetch = () => {
    executeRequest(fetchUserData);
  };
  
  return (
    <div>
      <button onClick={handleFetch} disabled={loading}>
        {loading ? '加载中...' : '获取用户数据'}
      </button>
      {userData && <pre>{JSON.stringify(userData, null, 2)}</pre>}
    </div>
  );
}

// 4. 综合请求管理器
class ComprehensiveRequestManager {
  constructor(options = {}) {
    this.deduplicator = new RequestDeduplicator();
    this.cacheManager = new CachedRequestManager();
    this.requestTimeout = options.requestTimeout || 10000; // 10秒超时
  }
  
  // 综合请求方法
  async request(config, options = {}) {
    const {
      useCache = true,
      cacheTime,
      deduplicate = true,
      timeout = this.requestTimeout
    } = options;
    
    // 对于GET请求，优先使用缓存
    if (useCache && config.method?.toUpperCase() === 'GET') {
      return this.cacheManager.request(config, { cacheTime });
    }
    
    // 对于其他请求，使用去重
    if (deduplicate) {
      return this.deduplicator.request(config);
    }
    
    // 直接发起请求
    return this.makeRequestWithTimeout(config, timeout);
  }
  
  // 带超时的请求
  async makeRequestWithTimeout(config, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const { url, method = 'GET', headers = {}, data } = config;
      
      const options = {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        signal: controller.signal
      };
      
      if (data && method.toUpperCase() !== 'GET') {
        options.body = JSON.stringify(data);
      }
      
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
  
  // 取消所有请求
  cancelAll() {
    this.deduplicator.cancelAllPendingRequests();
  }
  
  // 清除缓存
  clearCache() {
    this.cacheManager.clearCache();
  }
}

// 5. Axios拦截器实现请求去重
// 注意：需要先安装axios: npm install axios
/*
import axios from 'axios';

class AxiosRequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
    this.setupInterceptors();
  }
  
  // 生成请求标识
  getRequestId(config) {
    return `${config.method?.toUpperCase() || 'GET'}_${config.url}_${JSON.stringify(config.params || {})}_${JSON.stringify(config.data || {})}`;
  }
  
  // 设置请求和响应拦截器
  setupInterceptors() {
    // 请求拦截器
    axios.interceptors.request.use(
      config => {
        const requestId = this.getRequestId(config);
        
        // 如果相同请求正在进行，取消之前的请求
        if (this.pendingRequests.has(requestId)) {
          this.pendingRequests.get(requestId).cancel();
        }
        
        // 创建cancelToken用于取消请求
        const source = axios.CancelToken.source();
        config.cancelToken = source.token;
        
        this.pendingRequests.set(requestId, source);
        
        return config;
      },
      error => {
        return Promise.reject(error);
      }
    );
    
    // 响应拦截器
    axios.interceptors.response.use(
      response => {
        // 请求完成后清理
        const requestId = this.getRequestId(response.config);
        this.pendingRequests.delete(requestId);
        
        return response;
      },
      error => {
        // 错误处理时也清理
        if (axios.isCancel(error)) {
          console.log('Request canceled:', error.message);
        } else {
          const requestId = this.getRequestId(error.config);
          this.pendingRequests.delete(requestId);
        }
        
        return Promise.reject(error);
      }
    );
  }
}

// 使用
const deduplicator = new AxiosRequestDeduplicator();
*/

// 6. 实际使用示例
const requestManager = new ComprehensiveRequestManager({
  requestTimeout: 15000
});

// 示例：获取用户信息
async function fetchUserInfo(userId) {
  try {
    const result = await requestManager.request({
      method: 'GET',
      url: '/api/user',
      params: { id: userId }
    }, {
      useCache: true,
      cacheTime: 60000 // 缓存1分钟
    });
    
    console.log('User info:', result);
    return result;
  } catch (error) {
    console.error('Failed to fetch user info:', error);
    throw error;
  }
}

// 示例：提交表单数据
async function submitFormData(data) {
  try {
    const result = await requestManager.request({
      method: 'POST',
      url: '/api/form',
      data: data
    }, {
      deduplicate: true // 启用去重
    });
    
    console.log('Form submitted:', result);
    return result;
  } catch (error) {
    console.error('Failed to submit form:', error);
    throw error;
  }
}
```

## 实际应用场景

### 1. 表单提交防重复
在用户提交表单时，防止用户多次点击提交按钮导致重复提交。可以通过按钮禁用或请求去重来实现。

### 2. 数据列表刷新
当用户频繁点击刷新按钮时，避免发起多个相同的数据获取请求，提升用户体验和服务器性能。

### 3. 搜索功能优化
在搜索功能中，当用户快速输入时，避免为每个输入字符都发起请求，可以结合防抖和请求去重。

### 4. 购物车操作
在电商应用中，防止用户重复添加相同商品到购物车或重复提交订单。

### 5. 支付流程保护
在支付流程中，防止用户重复提交支付请求，避免重复扣款。

### 6. API接口保护
在调用第三方API时，防止因网络问题导致的重复请求，避免超出API调用限制。

### 7. 实时数据更新
在需要实时更新数据的场景中，避免同时发起多个数据更新请求造成冲突。

### 8. 用户权限检查
在进行用户权限验证时，避免重复发起权限检查请求，提高应用响应速度。
