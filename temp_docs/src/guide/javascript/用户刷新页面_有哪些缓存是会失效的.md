# 用户刷新页面，有哪些缓存是会失效的？（了解）

**题目**: 用户刷新页面，有哪些缓存是会失效的？（了解）

## 标准答案

用户刷新页面时会失效的缓存主要包括：1) 内存缓存(Volatile Memory Cache)：存储在JavaScript变量、对象、数组中的数据；2) 会话存储(Session Storage)：仅在当前浏览器标签页/窗口有效；3) 页面内缓存：DOM元素状态、组件状态、临时计算结果等。而持久化缓存如本地存储(Local Storage)、Cookie、IndexedDB、文件系统缓存等通常不会因页面刷新而失效。

## 详细解析

### 浏览器缓存层次结构

浏览器中的缓存可以分为多个层次，不同层次的缓存在页面刷新时表现不同：

1. **CPU缓存**：L1、L2、L3缓存，对前端开发透明
2. **内存缓存**：JavaScript运行时中的变量、对象
3. **页面缓存**：DOM状态、CSSOM、渲染树
4. **会话缓存**：Session Storage、页面生命周期缓存
5. **持久化缓存**：Local Storage、IndexedDB、Cookie、文件系统

### 会失效的缓存类型

#### 1. 内存缓存 (Memory Cache)
```javascript
// 这些数据在页面刷新后会丢失
let temporaryData = {
    userSession: { id: 123, name: 'John' },
    computedResults: [/* some calculated data */],
    cachedApiResponses: new Map()
};

// 临时DOM引用
const tempElements = document.querySelectorAll('.temp');
```

#### 2. 会话存储 (Session Storage)
```javascript
// Session Storage 在页面刷新时会保留
// 但在关闭标签页/窗口后会失效
sessionStorage.setItem('currentPageState', JSON.stringify({
    scrollPosition: window.scrollY,
    formInputs: { username: 'john', email: 'john@example.com' }
}));

// 页面刷新后仍然存在
const savedState = sessionStorage.getItem('currentPageState');
```

#### 3. 页面内缓存
```javascript
// React 中的组件状态
function MyComponent() {
    const [localState, setLocalState] = useState(''); // 页面刷新后重置
    const [derivedData, setDerivedData] = useState([]); // 页面刷新后重置
    
    // 使用 useRef 保存的引用也会在刷新时丢失
    const tempRef = useRef(null);
    
    return <div>{localState}</div>;
}
```

### 不会失效的缓存类型

#### 1. 本地存储 (Local Storage)
```javascript
// Local Storage 在页面刷新后仍然存在
localStorage.setItem('userPreferences', JSON.stringify({
    theme: 'dark',
    language: 'zh-CN',
    notifications: true
}));

// 页面刷新后仍然可以获取
const preferences = JSON.parse(localStorage.getItem('userPreferences'));
```

#### 2. Cookie
```javascript
// Cookie 不会因页面刷新而失效（除非设置了过期时间）
document.cookie = "username=john; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";
```

#### 3. IndexedDB
```javascript
// IndexedDB 是持久化数据库，不会因页面刷新而丢失
class DatabaseManager {
    constructor() {
        this.dbName = 'AppDatabase';
        this.version = 1;
    }
    
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('cache')) {
                    const store = db.createObjectStore('cache', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }
    
    async setItem(key, value) {
        const transaction = this.db.transaction(['cache'], 'readwrite');
        const store = transaction.objectStore('cache');
        
        return store.put({
            id: key,
            value: value,
            timestamp: Date.now()
        });
    }
    
    async getItem(key) {
        const transaction = this.db.transaction(['cache'], 'readonly');
        const store = transaction.objectStore('cache');
        
        return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result?.value);
            request.onerror = () => reject(request.error);
        });
    }
}
```

### 实际场景分析

#### 硬刷新 vs 软刷新
```javascript
// 不同刷新方式对缓存的影响
/*
硬刷新 (Ctrl+F5 / Cmd+Shift+R):
- 清除内存缓存 ✓
- 清除页面内缓存 ✓
- 清除DNS缓存 ✓
- 清除浏览器缓存 ✓
- 保留持久化缓存 (Local Storage, Cookie等) ✗

软刷新 (F5 / Ctrl+R):
- 清除内存缓存 ✓
- 清除页面内缓存 ✓
- 保留部分浏览器缓存 (取决于缓存策略)
- 保留持久化缓存 (Local Storage, Cookie等) ✗
*/
```

#### 实际应用示例
```javascript
// 缓存管理器，处理不同类型的缓存
class CacheManager {
    constructor() {
        this.memoryCache = new Map(); // 内存缓存，会失效
        this.sessionCache = {}; // 会话缓存，页面刷新保留
    }
    
    // 内存缓存 - 页面刷新后失效
    setMemoryCache(key, value) {
        this.memoryCache.set(key, {
            value,
            timestamp: Date.now(),
            ttl: 300000 // 5分钟过期
        });
    }
    
    getMemoryCache(key) {
        const item = this.memoryCache.get(key);
        if (!item) return null;
        
        // 检查是否过期
        if (Date.now() - item.timestamp > item.ttl) {
            this.memoryCache.delete(key);
            return null;
        }
        
        return item.value;
    }
    
    // 会话缓存 - 页面刷新保留
    setSessionCache(key, value) {
        sessionStorage.setItem(`session_${key}`, JSON.stringify({
            value,
            timestamp: Date.now()
        }));
    }
    
    getSessionCache(key) {
        const item = sessionStorage.getItem(`session_${key}`);
        if (!item) return null;
        
        const parsed = JSON.parse(item);
        return parsed.value;
    }
    
    // 持久化缓存 - 页面刷新不丢失
    setPersistentCache(key, value) {
        localStorage.setItem(`persistent_${key}`, JSON.stringify({
            value,
            timestamp: Date.now()
        }));
    }
    
    getPersistentCache(key) {
        const item = localStorage.getItem(`persistent_${key}`);
        if (!item) return null;
        
        const parsed = JSON.parse(item);
        return parsed.value;
    }
    
    // 清理过期缓存
    cleanupExpired() {
        // 清理内存缓存中过期的项
        for (const [key, item] of this.memoryCache) {
            if (Date.now() - item.timestamp > item.ttl) {
                this.memoryCache.delete(key);
            }
        }
    }
}

// 使用示例
const cacheManager = new CacheManager();

// 存储临时计算结果（页面刷新后失效）
cacheManager.setMemoryCache('calculatedData', {
    result: 12345,
    inputs: [1, 2, 3, 4, 5]
});

// 存储页面状态（页面刷新后保留）
cacheManager.setSessionCache('formState', {
    username: 'john',
    email: 'john@example.com',
    preferences: { theme: 'dark' }
});

// 存储用户偏好（长期保留）
cacheManager.setPersistentCache('userSettings', {
    language: 'zh-CN',
    timezone: 'Asia/Shanghai',
    notifications: true
});
```

### 高级缓存策略

```javascript
// 智能缓存恢复机制
class SmartCacheRecovery {
    constructor() {
        this.cacheStrategies = {
            // 短暂数据 - 存储在内存，刷新后需要重新获取
            temporary: {
                storage: 'memory',
                recover: () => this.recoverTemporaryData(),
                ttl: 300000 // 5分钟
            },
            // 页面状态 - 存储在sessionStorage，刷新后恢复
            pageState: {
                storage: 'session',
                recover: () => this.recoverPageState(),
                ttl: 3600000 // 1小时
            },
            // 用户数据 - 存储在localStorage，长期保留
            userData: {
                storage: 'local',
                recover: () => this.recoverUserData(),
                ttl: Infinity
            }
        };
    }
    
    // 页面加载时恢复缓存
    async restoreOnLoad() {
        for (const [type, strategy] of Object.entries(this.cacheStrategies)) {
            if (strategy.storage === 'session' || strategy.storage === 'local') {
                await strategy.recover();
            }
        }
    }
    
    // 恢复页面状态
    async recoverPageState() {
        const savedState = sessionStorage.getItem('pageState');
        if (savedState) {
            const state = JSON.parse(savedState);
            // 恢复滚动位置
            if (state.scrollPosition) {
                window.scrollTo(0, state.scrollPosition);
            }
            // 恢复表单数据
            if (state.formData) {
                this.restoreFormData(state.formData);
            }
        }
    }
    
    // 恢复表单数据
    restoreFormData(formData) {
        Object.entries(formData).forEach(([selector, value]) => {
            const element = document.querySelector(selector);
            if (element) {
                element.value = value;
            }
        });
    }
    
    // 恢复用户数据
    async recoverUserData() {
        const userData = localStorage.getItem('userData');
        if (userData) {
            return JSON.parse(userData);
        }
        return null;
    }
    
    // 恢复临时数据（需要重新计算或获取）
    async recoverTemporaryData() {
        // 临时数据无法恢复，需要重新获取
        console.log('Temporary data needs to be recalculated');
        return null;
    }
}

// 页面加载时自动恢复缓存
window.addEventListener('load', async () => {
    const recovery = new SmartCacheRecovery();
    await recovery.restoreOnLoad();
});

// 页面卸载前保存状态
window.addEventListener('beforeunload', () => {
    // 保存滚动位置
    sessionStorage.setItem('pageState', JSON.stringify({
        scrollPosition: window.scrollY,
        formData: this.collectFormData(),
        timestamp: Date.now()
    }));
});
```

### 实际应用场景

1. **单页应用(SPA)**：使用内存缓存存储组件状态，使用持久化缓存存储用户数据
2. **电商网站**：购物车状态存储在内存中（易变），用户偏好存储在本地存储中
3. **内容管理系统**：草稿内容使用本地存储防止丢失，预览数据使用内存缓存
4. **在线工具**：用户配置使用持久化存储，临时计算结果使用内存缓存

### 注意事项

1. **内存管理**：定期清理内存缓存，避免内存泄漏
2. **数据一致性**：确保不同缓存层之间的数据同步
3. **安全考虑**：敏感数据不应存储在客户端缓存中
4. **存储限制**：注意不同存储机制的容量限制
5. **性能优化**：合理使用缓存，避免不必要的数据重复存储
