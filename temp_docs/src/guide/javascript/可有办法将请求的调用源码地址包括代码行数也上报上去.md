# 可有办法将请求的调用源码地址包括代码行数也上报上去？（了解）

**题目**: 可有办法将请求的调用源码地址包括代码行数也上报上去？（了解）

## 标准答案

可以通过以下几种方式实现请求调用源码地址和代码行数的上报：

1. **Error.stack**：利用Error对象的stack属性获取调用栈信息
2. **Source Map**：通过Source Map将压缩后的代码映射回原始源码位置
3. **AST转换**：在构建过程中使用AST转换自动注入源码位置信息
4. **装饰器模式**：使用装饰器自动记录函数调用位置
5. **拦截器机制**：在请求库层面拦截请求并注入调用位置信息

## 深入理解

在实际开发中，追踪请求的原始调用位置对于调试和错误定位非常重要，特别是在大型项目中。以下是几种实现方案的深入分析：

### 1. Error.stack方案

利用JavaScript中Error对象的stack属性可以获取完整的调用栈信息，通过解析调用栈可以定位到原始调用位置。

### 2. Source Map方案

在生产环境中，代码通常会被压缩和混淆，Source Map可以将压缩后的代码映射回原始源码，实现准确的位置定位。

### 3. 构建时注入方案

在构建阶段通过AST转换或Babel插件，在每个请求调用处自动注入位置信息。

### 4. 代理和拦截方案

通过代理请求库或使用拦截器，在请求发送前自动收集调用位置信息。

## 代码演示

### 1. 基于Error.stack的调用位置追踪

```javascript
// 调用位置追踪工具类
class CallLocationTracker {
  // 获取调用栈信息
  static getCallLocation(skipFrames = 2) {
    const obj = {};
    Error.captureStackTrace(obj, CallLocationTracker.getCallLocation);
    
    const stackLines = obj.stack.split('\n');
    // 跳过前几行（当前函数和调用函数）
    const callerLine = stackLines[skipFrames];
    
    if (callerLine) {
      // 解析调用位置：at functionName (filename:line:column)
      const match = callerLine.match(/at\s+(.+?)\s+\((.+):(\d+):(\d+)\)/) ||
                   callerLine.match(/at\s+(.+):(\d+):(\d+)/);
      
      if (match) {
        return {
          functionName: match[1] || 'anonymous',
          fileName: match[2] || match[1],
          lineNumber: parseInt(match[3]),
          columnNumber: parseInt(match[4]) || 0,
          fullLocation: callerLine.trim()
        };
      }
    }
    
    return null;
  }
  
  // 获取完整的调用栈
  static getFullCallStack(skipFrames = 2) {
    const obj = {};
    Error.captureStackTrace(obj, CallLocationTracker.getFullCallStack);
    
    const stackLines = obj.stack.split('\n');
    const stack = [];
    
    for (let i = skipFrames; i < stackLines.length; i++) {
      const line = stackLines[i].trim();
      if (line) {
        const match = line.match(/at\s+(.+?)\s+\((.+):(\d+):(\d+)\)/) ||
                     line.match(/at\s+(.+):(\d+):(\d+)/);
        
        if (match) {
          stack.push({
            functionName: match[1] || 'anonymous',
            fileName: match[2] || match[1],
            lineNumber: parseInt(match[3]),
            columnNumber: parseInt(match[4]) || 0,
            fullLine: line
          });
        }
      }
    }
    
    return stack;
  }
}

// 请求拦截器类
class RequestInterceptor {
  constructor(options = {}) {
    this.apiUrl = options.apiUrl || '';
    this.onError = options.onError || null;
    this.enableLocationTracking = options.enableLocationTracking !== false;
  }
  
  // 通用请求方法
  async request(config) {
    const locationInfo = this.enableLocationTracking 
      ? CallLocationTracker.getCallLocation(2) // 跳过request和当前函数
      : null;
    
    const requestInfo = {
      url: config.url,
      method: config.method || 'GET',
      timestamp: Date.now(),
      location: locationInfo
    };
    
    try {
      // 在请求头中添加调用位置信息
      const headers = {
        ...config.headers,
        'X-Call-Location': locationInfo 
          ? `${locationInfo.fileName}:${locationInfo.lineNumber}:${locationInfo.columnNumber}`
          : 'unknown'
      };
      
      console.log('请求信息:', requestInfo);
      
      // 模拟发送请求
      const response = await this.sendRequest({
        ...config,
        headers
      });
      
      return response;
    } catch (error) {
      // 错误上报时包含调用位置
      this.reportError(error, requestInfo);
      throw error;
    }
  }
  
  // 模拟发送请求
  async sendRequest(config) {
    // 这里应该是实际的请求逻辑
    // 比如使用fetch、axios等
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          data: { message: 'success' },
          status: 200,
          headers: {}
        });
      }, 100);
    });
  }
  
  // 错误上报
  reportError(error, requestInfo) {
    console.error('请求错误:', {
      error: error.message,
      requestInfo,
      timestamp: Date.now()
    });
    
    if (this.onError) {
      this.onError(error, requestInfo);
    }
  }
}

// 使用示例
const requestInterceptor = new RequestInterceptor({
  enableLocationTracking: true,
  onError: (error, requestInfo) => {
    console.log('错误上报:', { error, requestInfo });
  }
});

// 模拟API调用
async function fetchUserData(userId) {
  return await requestInterceptor.request({
    url: `/api/users/${userId}`,
    method: 'GET'
  });
}

// 调用API
fetchUserData(123).then(response => {
  console.log('响应:', response);
});
```

### 2. 基于装饰器的请求位置追踪

```javascript
// 装饰器工厂函数
function TrackCallLocation(target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args) {
    const locationInfo = CallLocationTracker.getCallLocation(3); // 跳过装饰器相关函数
    
    console.log(`方法 ${propertyKey} 被调用位置:`, locationInfo);
    
    // 将位置信息添加到参数中或存储在实例上
    this._lastCallLocation = locationInfo;
    
    return originalMethod.apply(this, args);
  };
  
  return descriptor;
}

// API服务类
class ApiService {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.requestInterceptor = new RequestInterceptor();
  }
  
  @TrackCallLocation
  async getUser(id) {
    return await this.requestInterceptor.request({
      url: `${this.baseURL}/users/${id}`,
      method: 'GET'
    });
  }
  
  @TrackCallLocation
  async updateUser(id, data) {
    return await this.requestInterceptor.request({
      url: `${this.baseURL}/users/${id}`,
      method: 'PUT',
      data
    });
  }
  
  // 获取最后一次调用的位置信息
  getLastCallLocation() {
    return this._lastCallLocation;
  }
}

// 注意：装饰器需要Babel或TypeScript支持
// 如果不支持装饰器，可以使用高阶函数替代
function withCallLocationTracking(apiMethod) {
  return function(...args) {
    const locationInfo = CallLocationTracker.getCallLocation(2);
    console.log('API调用位置:', locationInfo);
    
    // 将位置信息注入到请求配置中
    if (args[0] && typeof args[0] === 'object') {
      args[0]._callLocation = locationInfo;
    }
    
    return apiMethod.apply(this, args);
  };
}
```

### 3. Babel插件实现自动注入

```javascript
// 模拟Babel插件的逻辑（实际需要在构建时运行）
class BuildTimeLocationInjector {
  // 模拟AST转换：在请求调用前注入位置信息
  static injectLocationInfo(sourceCode) {
    // 这里是简化的模拟，实际Babel插件会更复杂
    return sourceCode
      // 检测请求调用模式，如 axios.get, fetch 等
      .replace(/(axios\.get|axios\.post|fetch)\(/g, (match, method) => {
        const locationInfo = CallLocationTracker.getCallLocation(2);
        return `injectLocationInfo(${JSON.stringify(locationInfo)}, ${method}(`;
      });
  }
  
  // 注入位置信息的辅助函数
  static injectLocationInfo(location, requestCall) {
    console.log('请求调用位置:', location);
    return requestCall;
  }
}

// 通用请求包装器
class RequestWrapper {
  constructor() {
    this.interceptors = {
      request: [],
      response: []
    };
  }
  
  // 添加请求拦截器
  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }
  
  // 添加响应拦截器
  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }
  
  // 执行请求
  async execute(config) {
    // 获取调用位置
    const location = CallLocationTracker.getCallLocation(2);
    
    // 创建请求上下文
    const context = {
      config: { ...config },
      location: location,
      timestamp: Date.now()
    };
    
    // 执行请求拦截器
    for (const interceptor of this.interceptors.request) {
      context.config = await interceptor(context.config, context);
    }
    
    try {
      // 执行实际请求
      let response = await this.sendRequest(context.config);
      
      // 执行响应拦截器
      for (const interceptor of this.interceptors.response) {
        response = await interceptor(response, context);
      }
      
      return response;
    } catch (error) {
      // 错误处理也可以包含位置信息
      error.callLocation = location;
      throw error;
    }
  }
  
  // 发送实际请求
  async sendRequest(config) {
    // 这里可以是任何请求库的实现
    // 例如 axios, fetch, 或其他HTTP客户端
    const url = config.url;
    const method = config.method || 'GET';
    
    // 添加调用位置到请求头
    const headers = {
      ...config.headers,
      'X-Source-Location': config._location 
        ? `${config._location.fileName}:${config._location.lineNumber}`
        : 'unknown'
    };
    
    // 模拟请求
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.1) { // 90% 成功率
          resolve({
            data: { message: 'success' },
            status: 200,
            headers: {},
            config: config
          });
        } else {
          const error = new Error('Network Error');
          error.config = config;
          reject(error);
        }
      }, 100);
    });
  }
}

// 使用示例
const requestWrapper = new RequestWrapper();

// 添加请求拦截器
requestWrapper.addRequestInterceptor(async (config, context) => {
  console.log('请求拦截 - 位置:', context.location);
  config._location = context.location; // 将位置信息保存到配置中
  return config;
});

// 添加响应拦截器
requestWrapper.addResponseInterceptor(async (response, context) => {
  console.log('响应拦截 - 位置:', context.location);
  response.config._location = context.location;
  return response;
});

// 使用包装器发送请求
async function testRequest() {
  try {
    const response = await requestWrapper.execute({
      url: '/api/test',
      method: 'GET'
    });
    console.log('响应:', response);
  } catch (error) {
    console.error('错误位置:', error.callLocation);
  }
}

testRequest();
```

### 4. Source Map集成方案

```javascript
// Source Map处理器（简化版）
class SourceMapProcessor {
  constructor() {
    this.sourceMaps = new Map();
  }
  
  // 加载Source Map文件
  async loadSourceMap(mapUrl) {
    try {
      const response = await fetch(mapUrl);
      const sourceMap = await response.json();
      this.sourceMaps.set(mapUrl, sourceMap);
      return sourceMap;
    } catch (error) {
      console.error('Failed to load source map:', error);
      return null;
    }
  }
  
  // 将压缩代码位置转换为源码位置
  mapToSource(compressedFile, line, column) {
    // 这里需要实际的Source Map解析逻辑
    // 实际实现会使用 source-map 库
    const map = this.sourceMaps.get(compressedFile + '.map');
    
    if (!map) {
      return {
        sourceFile: compressedFile,
        line: line,
        column: column,
        name: null
      };
    }
    
    // 简化的映射逻辑（实际会更复杂）
    // 实际应该使用 mozilla/source-map 库
    return {
      sourceFile: map.sources[0] || compressedFile,
      line: line, // 实际会根据映射表转换
      column: column,
      name: null
    };
  }
}

// 完整的错误追踪系统
class ComprehensiveErrorTracker {
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/api/errors';
    this.enableSourceMap = options.enableSourceMap !== false;
    this.sourceMapProcessor = new SourceMapProcessor();
  }
  
  // 上报错误
  async reportError(error, additionalInfo = {}) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...additionalInfo
    };
    
    // 如果启用了Source Map，尝试解析源码位置
    if (this.enableSourceMap && error.stack) {
      errorInfo.parsedStack = this.parseStackWithSourceMap(error.stack);
    } else {
      // 使用基本的调用栈解析
      errorInfo.parsedStack = this.parseBasicStack(error.stack);
    }
    
    try {
      await fetch(this.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorInfo)
      });
    } catch (reportError) {
      console.error('Failed to report error:', reportError);
    }
  }
  
  // 解析基本调用栈
  parseBasicStack(stack) {
    if (!stack) return [];
    
    const lines = stack.split('\n');
    const parsedStack = [];
    
    for (let i = 1; i < lines.length; i++) { // 跳过第一行错误信息
      const line = lines[i].trim();
      if (line) {
        const match = line.match(/at\s+(.+?)\s+\((.+):(\d+):(\d+)\)/) ||
                     line.match(/at\s+(.+):(\d+):(\d+)/) ||
                     line.match(/at\s+(.+?)\s+\((.+)\)/);
        
        if (match) {
          parsedStack.push({
            function: match[1] || 'anonymous',
            file: match[2] || match[1],
            line: match[3] ? parseInt(match[3]) : null,
            column: match[4] ? parseInt(match[4]) : null
          });
        }
      }
    }
    
    return parsedStack;
  }
  
  // 解析带Source Map的调用栈
  parseStackWithSourceMap(stack) {
    const basicStack = this.parseBasicStack(stack);
    const mappedStack = [];
    
    for (const frame of basicStack) {
      if (frame.file && frame.line !== null && frame.column !== null) {
        const sourceLocation = this.sourceMapProcessor.mapToSource(
          frame.file, 
          frame.line, 
          frame.column
        );
        mappedStack.push({
          ...frame,
          source: sourceLocation
        });
      } else {
        mappedStack.push(frame);
      }
    }
    
    return mappedStack;
  }
}

// 使用示例
const errorTracker = new ComprehensiveErrorTracker({
  apiEndpoint: '/api/errors',
  enableSourceMap: true
});

// 模拟错误上报
async function simulateApiCall() {
  try {
    // 模拟一个错误
    throw new Error('API request failed');
  } catch (error) {
    // 获取调用位置并上报
    const location = CallLocationTracker.getCallLocation(2);
    await errorTracker.reportError(error, {
      callLocation: location,
      requestInfo: {
        url: '/api/test',
        method: 'GET'
      }
    });
  }
}

simulateApiCall();
```

## 实际应用场景

### 1. 生产环境错误监控

在生产环境中，当API请求失败时，能够准确知道是哪行代码发起了请求，有助于快速定位问题。

### 2. 性能监控

追踪每个请求的调用位置，可以帮助识别哪些功能模块的请求频率较高，为性能优化提供数据支持。

### 3. 安全审计

监控请求的调用来源，可以发现异常的请求模式，提高应用安全性。

### 4. 开发调试

在开发过程中，能够快速定位请求发起的具体位置，提高开发效率。

### 5. 代码质量分析

通过分析请求调用模式，可以发现代码中的潜在问题，如重复请求、无效请求等。

这些方案可以根据项目的具体需求和技术栈选择使用，其中Error.stack方案最为简单直接，而Source Map方案在生产环境中更为准确。
