# 用 JavaScript 实现冒泡排序。数据为 23、45、18、37、92、13、24？（必会）

**题目**: 用 JavaScript 实现冒泡排序。数据为 23、45、18、37、92、13、24？（必会）

**答案**:

## 冒泡排序算法原理

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行的，直到没有再需要交换的元素，也就是说该数列已经排序完成。

## JavaScript实现

### 基础版本
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  
  // 外层循环控制排序轮数
  for (let i = 0; i < n - 1; i++) {
    // 内层循环进行相邻元素比较
    for (let j = 0; j < n - 1 - i; j++) {
      // 如果前一个元素大于后一个元素，则交换
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // ES6解构交换
      }
    }
  }
  
  return arr;
}

// 使用示例：对数据 [23, 45, 18, 37, 92, 13, 24] 进行排序
const data = [23, 45, 18, 37, 92, 13, 24];
console.log("原数组:", data);
const sortedData = bubbleSort([...data]); // 使用展开运算符避免修改原数组
console.log("排序后:", sortedData); // [13, 18, 23, 24, 37, 45, 92]
```

### 优化版本（提前结束）
```javascript
function bubbleSortOptimized(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    let swapped = false; // 标记本轮是否发生交换
    
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true; // 发生了交换
      }
    }
    
    // 如果本轮没有发生交换，说明数组已经有序，可以提前结束
    if (!swapped) {
      break;
    }
  }
  
  return arr;
}

// 使用示例
const data = [23, 45, 18, 37, 92, 13, 24];
console.log("原数组:", data);
const sortedData = bubbleSortOptimized([...data]);
console.log("排序后:", sortedData); // [13, 18, 23, 24, 37, 45, 92]
```

### 对指定数据的排序过程演示
```javascript
function bubbleSortWithSteps(arr) {
  const n = arr.length;
  console.log("初始数组:", [...arr]);
  
  for (let i = 0; i < n - 1; i++) {
    console.log(`第 ${i + 1} 轮排序:`);
    let swapped = false;
    
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        console.log(`  交换 ${arr[j]} 和 ${arr[j + 1]}`);
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    
    console.log(`  本轮结果:`, [...arr]);
    
    if (!swapped) {
      console.log("  数组已有序，提前结束");
      break;
    }
  }
  
  return arr;
}

// 对题目中的数据进行排序
const data = [23, 45, 18, 37, 92, 13, 24];
const result = bubbleSortWithSteps([...data]);
console.log("最终结果:", result);
```

## 算法复杂度分析

- **时间复杂度**：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序（优化版本）
  - 平均情况：O(n²)

- **空间复杂度**：O(1) - 只需要常数级的额外空间

- **稳定性**：稳定 - 相等元素的相对位置不会改变

## 特点总结

1. **优点**：实现简单，代码易懂，是稳定的排序算法
2. **缺点**：效率较低，时间复杂度为O(n²)，不适合大数据量排序
3. **适用场景**：数据量小，对稳定性有要求，或作为教学示例

对于题目中的数据 [23, 45, 18, 37, 92, 13, 24]，排序后的结果为 [13, 18, 23, 24, 37, 45, 92]。
