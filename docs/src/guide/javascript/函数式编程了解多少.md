# 函数式编程了解多少（了解）

**题目**: 函数式编程了解多少（了解）

## 标准答案

函数式编程是一种编程范式，它将计算视为数学函数的求值，强调函数的使用，避免改变状态和可变数据。主要特点包括：纯函数、不可变性、函数是一等公民、高阶函数、柯里化、组合等。在JavaScript中，函数式编程可以提高代码的可读性、可维护性和可测试性。

## 详细解释

函数式编程的核心概念包括：

1. **纯函数（Pure Functions）**：对于相同的输入总是产生相同的输出，且没有副作用
2. **不可变性（Immutability）**：数据一旦创建就不能被修改
3. **一等函数（First-Class Functions）**：函数可以作为值传递
4. **高阶函数（Higher-Order Functions）**：接受函数作为参数或返回函数
5. **柯里化（Currying）**：将多参数函数转换为一系列单参数函数
6. **函数组合（Function Composition）**：将多个函数组合成一个函数
7. **避免共享状态**：减少状态相关的bug

## 代码示例

```javascript
// 1. 纯函数示例
const add = (a, b) => a + b; // 纯函数 - 相同输入总是相同输出，无副作用

const addWithSideEffect = (a, b) => {
    console.log('Adding numbers:', a, b); // 有副作用 - 打印到控制台
    return a + b;
};

// 2. 不可变性示例
// 非函数式 - 修改原数组
const numbers1 = [1, 2, 3];
numbers1.push(4); // 修改了原数组

// 函数式 - 创建新数组
const numbers2 = [1, 2, 3];
const newNumbers = [...numbers2, 4]; // 创建新数组，不修改原数组

// 3. 高阶函数示例
const numbers = [1, 2, 3, 4, 5];

// map - 转换数组
const doubled = numbers.map(x => x * 2); // [2, 4, 6, 8, 10]

// filter - 过滤数组
const evens = numbers.filter(x => x % 2 === 0); // [2, 4]

// reduce - 聚合数组
const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 15

// 4. 柯里化示例
const multiply = (a, b, c) => a * b * c;
const curriedMultiply = a => b => c => a * b * c;

const multiplyByTwo = curriedMultiply(2);
const multiplyByTwoAndThree = multiplyByTwo(3);
const result = multiplyByTwoAndThree(4); // 24
// 或者直接调用
const result2 = curriedMultiply(2)(3)(4); // 24

// 5. 函数组合示例
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

const add10 = x => x + 10;
const multiply2 = x => x * 2;
const subtract5 = x => x - 5;

// 从右到左执行: subtract5(multiply2(add10(5))) = subtract5(multiply2(15)) = subtract5(30) = 25
const composedFunction = compose(subtract5, multiply2, add10);
const result3 = composedFunction(5); // 25

// 6. 实际应用示例：数据处理管道
const users = [
    { name: 'Alice', age: 25, active: true },
    { name: 'Bob', age: 30, active: false },
    { name: 'Charlie', age: 35, active: true }
];

// 函数式方法 - 管道操作
const getActiveUsers = users =>
    users
        .filter(user => user.active)
        .map(user => ({ name: user.name, age: user.age }));

const activeUsers = getActiveUsers(users);
console.log(activeUsers); // [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 35 }]

// 7. 避免副作用的示例
// 非函数式 - 有副作用
let globalCounter = 0;
const increment = () => {
    globalCounter++; // 修改全局状态
    return globalCounter;
};

// 函数式 - 无副作用
const incrementFunctional = (counter) => counter + 1;
const newCounter = incrementFunctional(5); // 6，不修改原值

// 8. 使用函数式方法重构命令式代码
// 命令式写法
function processOrders(orders) {
    const results = [];
    for (let i = 0; i < orders.length; i++) {
        if (orders[i].status === 'completed') {
            const processedOrder = {
                id: orders[i].id,
                total: orders[i].items.reduce((sum, item) => sum + item.price, 0)
            };
            results.push(processedOrder);
        }
    }
    return results;
}

// 函数式写法
const processOrdersFunctional = orders =>
    orders
        .filter(order => order.status === 'completed')
        .map(order => ({
            id: order.id,
            total: order.items.reduce((sum, item) => sum + item.price, 0)
        }));

// 9. 高阶函数实际应用
const memoize = (fn) => {
    const cache = {};
    return (...args) => {
        const key = JSON.stringify(args);
        if (key in cache) {
            console.log('从缓存获取结果');
            return cache[key];
        }
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
};

const expensiveOperation = memoize((n) => {
    console.log('执行昂贵操作');
    return n * n;
});

expensiveOperation(5); // 执行昂贵操作，返回25
expensiveOperation(5); // 从缓存获取结果，返回25
