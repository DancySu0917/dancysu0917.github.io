# 为什么会有跨域的问题出现，如何解决跨域问题？（必会）

## 标准答案

跨域问题出现的根本原因是浏览器的**同源策略**，它限制了一个源（协议+域名+端口）的文档或脚本与另一个源的资源进行交互。

主要解决跨域问题的方法包括：
1. **CORS（跨域资源共享）**：服务器设置响应头允许跨域访问
2. **JSONP**：利用script标签不受同源策略限制的特性
3. **代理转发**：通过同源服务器代理请求
4. **Nginx反向代理**：配置Nginx转发请求
5. **PostMessage**：用于iframe通信

## 深入理解

### 同源策略详解

同源策略是浏览器的核心安全机制，它要求协议、域名、端口三者完全相同才允许资源访问。例如：
- `http://example.com:80` 与 `https://example.com:80`（协议不同）- 跨域
- `http://example.com:80` 与 `http://api.example.com:80`（域名不同）- 跨域
- `http://example.com:80` 与 `http://example.com:8080`（端口不同）- 跨域

### CORS跨域解决方案

CORS是最常用的跨域解决方案，通过服务器设置响应头实现：

**简单请求**（无需预检）：
- 请求方法：GET、POST、HEAD
- 请求头限制：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type（仅限application/x-www-form-urlencoded、multipart/form-data、text/plain）

**预检请求**（复杂请求）：
- 请求方法：PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH
- 自定义请求头
- Content-Type为application/json等

### 其他跨域解决方案

**JSONP原理**：
- 动态创建script标签
- 利用src属性不受同源策略限制
- 服务端返回函数调用形式的数据

**代理转发原理**：
- 前端请求同源服务器
- 服务器代理请求目标API
- 服务器返回结果给前端

## 代码示例

### 1. CORS解决方案

```javascript
// 前端请求示例
fetch('http://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ data: 'example' })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));

// Node.js后端CORS配置示例
const express = require('express');
const app = express();

// 简单CORS配置
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*'); // 允许所有源
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// 更安全的CORS配置（指定域名）
const cors = require('cors');
const corsOptions = {
  origin: ['http://localhost:3000', 'https://yourdomain.com'],
  credentials: true,
  optionsSuccessStatus: 200
};
app.use(cors(corsOptions));
```

### 2. JSONP实现

```javascript
// JSONP实现函数
function jsonp(url, callbackName, callback) {
  // 创建script标签
  const script = document.createElement('script');
  
  // 生成随机回调函数名
  const uniqueCallback = `jsonp_callback_${Date.now()}_${Math.random().toString(36).substr(2)}`;
  
  // 定义全局回调函数
  window[uniqueCallback] = function(data) {
    try {
      callback(data);
    } finally {
      // 清理全局函数和script标签
      delete window[uniqueCallback];
      document.head.removeChild(script);
    }
  };
  
  // 设置请求URL
  script.src = `${url}${url.includes('?') ? '&' : '?'}callback=${uniqueCallback}`;
  
  // 错误处理
  script.onerror = () => {
    console.error('JSONP request failed');
    delete window[uniqueCallback];
    document.head.removeChild(script);
  };
  
  // 添加到DOM并发起请求
  document.head.appendChild(script);
}

// 使用JSONP
jsonp('http://api.example.com/data', 'callback', function(data) {
  console.log('JSONP response:', data);
});

// 服务端JSONP响应示例（Node.js）
app.get('/api/jsonp', (req, res) => {
  const callback = req.query.callback;
  const data = { message: 'Hello from JSONP', timestamp: Date.now() };
  
  if (callback) {
    // 返回函数调用格式
    res.setHeader('Content-Type', 'application/javascript');
    res.send(`${callback}(${JSON.stringify(data)})`);
  } else {
    res.json(data);
  }
});
```

### 3. 代理转发解决方案

```javascript
// Webpack代理配置（开发环境）
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': '' // 重写路径
        }
      }
    }
  }
};

// Nginx代理配置
/*
server {
    listen 80;
    server_name localhost;
    
    location /api/ {
        proxy_pass http://api.example.com/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
*/

// Node.js代理实现
const { createProxyMiddleware } = require('http-proxy-middleware');

const apiProxy = createProxyMiddleware('/api', {
  target: 'http://api.example.com',
  changeOrigin: true,
  pathRewrite: {
    '^/api': ''
  }
});

app.use('/api', apiProxy);
```

### 4. PostMessage实现跨域通信

```javascript
// 父页面发送消息
function sendMessageToIframe() {
  const iframe = document.getElementById('myIframe');
  const message = {
    type: 'getData',
    data: { userId: 123 }
  };
  
  // 发送消息到iframe
  iframe.contentWindow.postMessage(message, 'http://different-domain.com');
}

// 监听来自iframe的消息
window.addEventListener('message', function(event) {
  // 验证来源（安全考虑）
  if (event.origin !== 'http://different-domain.com') {
    return;
  }
  
  console.log('收到iframe消息:', event.data);
  
  // 处理不同类型的消息
  switch(event.data.type) {
    case 'response':
      console.log('接收到响应:', event.data.payload);
      break;
    case 'error':
      console.error('发生错误:', event.data.message);
      break;
  }
});

// iframe内部接收消息
window.addEventListener('message', function(event) {
  // 验证来源
  if (event.origin !== 'http://parent-domain.com') {
    return;
  }
  
  console.log('收到父页面消息:', event.data);
  
  // 处理消息并回复
  if (event.data.type === 'getData') {
    // 模拟异步获取数据
    setTimeout(() => {
      const response = {
        type: 'response',
        payload: { userData: 'some data' }
      };
      
      // 发送回复到父页面
      event.source.postMessage(response, event.origin);
    }, 1000);
  }
});
```

### 5. WebSocket跨域处理

```javascript
// WebSocket连接不受同源策略限制
const ws = new WebSocket('ws://api.example.com/websocket');

ws.onopen = function(event) {
  console.log('WebSocket连接已建立');
  ws.send('Hello Server');
};

ws.onmessage = function(event) {
  console.log('收到消息:', event.data);
};

// 服务端WebSocket跨域设置（Node.js + ws库）
const WebSocket = require('ws');

const wss = new WebSocket.Server({
  port: 8080,
  // 设置跨域允许的源
  verifyClient: function(info) {
    const allowedOrigins = ['http://localhost:3000', 'https://yourdomain.com'];
    return allowedOrigins.includes(info.origin);
  }
});

wss.on('connection', function connection(ws, req) {
  console.log('新的WebSocket连接:', req.headers.origin);
  
  ws.on('message', function incoming(message) {
    console.log('收到消息:', message);
    
    // 广播消息给所有连接
    wss.clients.forEach(function each(client) {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
});
```

## 实践场景

### 1. 开发环境跨域
- 使用Webpack DevServer代理
- 配置CORS中间件
- 使用Mock服务

### 2. 生产环境跨域
- 正确配置CORS策略
- 避免使用通配符(*)，指定具体域名
- 实现安全的JSONP服务

### 3. 微前端架构跨域
- 使用Import-Map解决模块加载跨域
- 配置各子应用的CORS策略
- 实现安全的通信机制

### 4. 安全考虑
- 避免宽松的CORS配置
- 验证Origin头
- 实施适当的认证和授权
- 防止JSONP注入攻击
