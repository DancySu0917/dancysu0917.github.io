# 算法题：如何对一个无序的单向链表进行排序？给出一个最优实现算法？（了解）

**题目**: 算法题：如何对一个无序的单向链表进行排序？给出一个最优实现算法？（了解）

**答案**:

对单向链表进行排序有多种方法，其中最优的是归并排序，时间复杂度为 O(n log n)，空间复杂度为 O(log n)（递归栈）或 O(1)（迭代实现）。

## 首先定义链表节点结构

```javascript
class ListNode {
    constructor(val, next) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}
```

## 方法一：归并排序（递归实现）- 最优解

### 思路：
1. 使用快慢指针找到链表中点
2. 递归地对左右两部分进行排序
3. 合并两个已排序的链表

### 实现：
```javascript
function sortList(head) {
    if (!head || !head.next) return head;
    
    // 使用快慢指针找到中点
    let slow = head;
    let fast = head;
    let prev = null; // 用于断开链表
    
    while (fast && fast.next) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // 断开链表，分成两部分
    prev.next = null;
    
    // 递归排序两部分
    const left = sortList(head);
    const right = sortList(slow);
    
    // 合并两个已排序的链表
    return merge(left, right);
}

function merge(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // 连接剩余节点
    current.next = l1 || l2;
    
    return dummy.next;
}

// 测试
// 创建链表: 4 -> 2 -> 1 -> 3
const head = new ListNode(4, new ListNode(2, new ListNode(1, new ListNode(3))));
const sorted = sortList(head);
// 结果: 1 -> 2 -> 3 -> 4
```

### 复杂度分析：
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(log n)，递归调用栈的深度

## 方法二：归并排序（迭代实现）- 空间最优

### 思路：
1. 自底向上进行归并，避免递归
2. 按照长度为1, 2, 4, 8...进行归并

### 实现：
```javascript
function sortListIterative(head) {
    if (!head || !head.next) return head;
    
    // 计算链表长度
    let length = 0;
    let current = head;
    while (current) {
        length++;
        current = current.next;
    }
    
    const dummy = new ListNode(0);
    dummy.next = head;
    
    // 按照子序列长度进行归并
    for (let size = 1; size < length; size *= 2) {
        let prev = dummy;
        current = dummy.next;
        
        while (current) {
            // 获取第一段
            const l1 = current;
            const l2 = split(l1, size);
            current = split(l2, size);
            
            // 合并两段
            prev.next = merge(l1, l2);
            
            // 移动prev到合并后链表的末尾
            while (prev.next) {
                prev = prev.next;
            }
        }
    }
    
    return dummy.next;
}

// 从头开始截取size个节点，并返回剩余部分的头节点
function split(head, size) {
    if (!head) return null;
    
    for (let i = 1; i < size && head.next; i++) {
        head = head.next;
    }
    
    const rest = head.next;
    head.next = null;
    return rest;
}
```

### 复杂度分析：
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(1)

## 方法三：转换为数组后排序

### 思路：
1. 将链表转换为数组
2. 对数组进行排序
3. 将排序后的数组重新构建链表

### 实现：
```javascript
function sortListByArray(head) {
    if (!head) return null;
    
    // 转换为数组
    const values = [];
    let current = head;
    while (current) {
        values.push(current.val);
        current = current.next;
    }
    
    // 排序
    values.sort((a, b) => a - b);
    
    // 重新构建链表
    const dummy = new ListNode(0);
    current = dummy;
    
    for (const val of values) {
        current.next = new ListNode(val);
        current = current.next;
    }
    
    return dummy.next;
}
```

### 复杂度分析：
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

## 方法四：快速排序

### 实现：
```javascript
function sortListQuick(head) {
    if (!head || !head.next) return head;
    
    // 分区操作
    const { left, right, equal } = partitionList(head);
    
    // 递归排序左右两部分
    const sortedLeft = sortListQuick(left);
    const sortedRight = sortListQuick(right);
    
    // 合并结果
    return mergeQuick(sortedLeft, equal, sortedRight);
}

function partitionList(head) {
    if (!head) return { left: null, right: null, equal: null };
    
    const pivotVal = head.val;
    const leftDummy = new ListNode(0);
    const rightDummy = new ListNode(0);
    const equalDummy = new ListNode(0);
    
    let leftTail = leftDummy;
    let rightTail = rightDummy;
    let equalTail = equalDummy;
    
    let current = head;
    while (current) {
        const next = current.next;
        current.next = null;
        
        if (current.val < pivotVal) {
            leftTail.next = current;
            leftTail = current;
        } else if (current.val > pivotVal) {
            rightTail.next = current;
            rightTail = current;
        } else {
            equalTail.next = current;
            equalTail = current;
        }
        
        current = next;
    }
    
    return {
        left: leftDummy.next,
        right: rightDummy.next,
        equal: equalDummy.next
    };
}

function mergeQuick(left, equal, right) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    // 连接左部分
    current.next = left;
    while (current.next) current = current.next;
    
    // 连接相等部分
    current.next = equal;
    while (current.next) current = current.next;
    
    // 连接右部分
    current.next = right;
    
    return dummy.next;
}
```

## 各方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 稳定性 | 实现难度 |
|------|------------|------------|--------|----------|
| 归并排序（递归） | O(n log n) | O(log n) | 稳定 | 中等 |
| 归并排序（迭代） | O(n log n) | O(1) | 稳定 | 困难 |
| 数组转换法 | O(n log n) | O(n) | 稳定 | 简单 |
| 快速排序 | O(n log n) 平均 | O(log n) | 不稳定 | 中等 |

## 最优解推荐

**归并排序（递归实现）**是最推荐的解法，因为：
1. 时间复杂度稳定为 O(n log n)
2. 算法稳定（相等元素的相对位置不变）
3. 实现相对简洁
4. 适合链表结构，不需要随机访问

**归并排序（迭代实现）**在空间复杂度上更优，为 O(1)，但实现更复杂，在面试中如果时间充裕可以考虑实现。
