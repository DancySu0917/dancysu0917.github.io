# 帧率监控你们是怎么做的？（了解）

**题目**: 帧率监控你们是怎么做的？（了解）

**答案**:

帧率监控是前端性能优化的重要组成部分，用于检测页面渲染的流畅度。以下是几种常见的帧率监控方法：

## 1. 使用 requestAnimationFrame 计算帧率

通过 requestAnimationFrame 的回调频率来计算当前帧率：

```javascript
class FrameRateMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 0;
    this.fpsList = []; // 存储历史FPS数据
    this.isMonitoring = false;
  }
  
  start() {
    this.isMonitoring = true;
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.update();
  }
  
  stop() {
    this.isMonitoring = false;
  }
  
  update() {
    if (!this.isMonitoring) return;
    
    this.frameCount++;
    const currentTime = performance.now();
    
    // 每秒计算一次FPS
    if (currentTime - this.lastTime >= 1000) {
      this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
      this.fpsList.push({
        time: Date.now(),
        fps: this.fps
      });
      
      // 保持历史数据在合理范围内
      if (this.fpsList.length > 100) {
        this.fpsList.shift();
      }
      
      console.log(`当前FPS: ${this.fps}`);
      
      // 重置计数器
      this.frameCount = 0;
      this.lastTime = currentTime;
    }
    
    requestAnimationFrame(() => this.update());
  }
  
  getFPS() {
    return this.fps;
  }
  
  getAverageFPS() {
    if (this.fpsList.length === 0) return 0;
    const sum = this.fpsList.reduce((acc, curr) => acc + curr.fps, 0);
    return Math.round(sum / this.fpsList.length);
  }
  
  // 获取FPS统计信息
  getStats() {
    if (this.fpsList.length === 0) return null;
    
    const fpsValues = this.fpsList.map(item => item.fps);
    const min = Math.min(...fpsValues);
    const max = Math.max(...fpsValues);
    const avg = this.getAverageFPS();
    
    return {
      min,
      max,
      avg,
      count: this.fpsList.length
    };
  }
}

// 使用示例
const fpsMonitor = new FrameRateMonitor();
fpsMonitor.start();

// 在控制台显示FPS
setInterval(() => {
  console.log(`实时FPS: ${fpsMonitor.getFPS()}`);
}, 1000);
```

## 2. 使用 Performance API 监控渲染性能

利用浏览器的 Performance API 获取更详细的渲染性能数据：

```javascript
class AdvancedFrameRateMonitor {
  constructor() {
    this.observer = null;
    this.metrics = {
      frameCount: 0,
      lastFrameTime: performance.now(),
      fps: 0,
      frameTimes: [],
      slowFrameCount: 0 // 慢帧计数（>16.67ms）
    };
  }
  
  start() {
    // 监听绘制事件
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'measure') {
            // 自定义测量
            console.log(`${entry.name}: ${entry.duration}ms`);
          }
        });
      });
      
      this.observer.observe({ entryTypes: ['measure', 'paint'] });
    }
    
    // 开始帧率监测
    this.monitorFrameRate();
  }
  
  monitorFrameRate() {
    let lastTime = performance.now();
    let frameCount = 0;
    
    const calculateFPS = (currentTime) => {
      frameCount++;
      
      if (currentTime - lastTime >= 1000) {
        this.metrics.fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        frameCount = 0;
        lastTime = currentTime;
        
        console.log(`FPS: ${this.metrics.fps}`);
      }
      
      requestAnimationFrame(calculateFPS);
    };
    
    requestAnimationFrame(calculateFPS);
  }
  
  // 监控单帧渲染时间
  monitorFrameRenderTime() {
    let lastFrameTime = performance.now();
    
    const monitor = () => {
      const currentFrameTime = performance.now();
      const frameDuration = currentFrameTime - lastFrameTime;
      this.metrics.frameTimes.push(frameDuration);
      
      // 检查是否为慢帧 (超过16.67ms，对应60FPS)
      if (frameDuration > 16.67) {
        this.metrics.slowFrameCount++;
        console.warn(`慢帧检测: ${frameDuration.toFixed(2)}ms`);
      }
      
      // 保持数组大小合理
      if (this.metrics.frameTimes.length > 100) {
        this.metrics.frameTimes.shift();
      }
      
      lastFrameTime = currentFrameTime;
      requestAnimationFrame(monitor);
    };
    
    requestAnimationFrame(monitor);
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      averageFrameTime: this.metrics.frameTimes.length 
        ? this.metrics.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameTimes.length
        : 0
    };
  }
  
  stop() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}
```

## 3. 使用 Web Vitals 库监控帧率

Google 的 web-vitals 库可以监控核心Web指标，包括帧率相关数据：

```javascript
// 需要先安装: npm install web-vitals
import { getLCP, getFID, getCLS, getFCP, getTTFB } from 'web-vitals';

// 监控所有核心Web指标
function reportWebVitals() {
  getFCP(console.log);  // 首次内容绘制
  getLCP(console.log);  // 最大内容绘制
  getFID(console.log);  // 首次输入延迟
  getCLS(console.log);  // 累积布局偏移
  getTTFB(console.log); // Time to First Byte
}

// 上报到分析服务
function sendToAnalytics(metric) {
  // 发送到你的分析服务
  navigator.sendBeacon('/analytics', JSON.stringify(metric));
}

// 实际使用
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getFID(sendToAnalytics);
```

## 4. 自定义 FPS 指示器组件

创建一个可视化 FPS 监控组件：

```jsx
import React, { useEffect, useState } from 'react';

const FPSMonitor = ({ showWhenBelow = 30 }) => {
  const [fps, setFps] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();
    let animationFrameId;
    
    const updateFPS = (currentTime) => {
      frameCount++;
      
      if (currentTime - lastTime >= 1000) {
        const currentFPS = Math.round((frameCount * 1000) / (currentTime - lastTime));
        setFps(currentFPS);
        setIsVisible(currentFPS < showWhenBelow); // 当FPS低于阈值时显示
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      animationFrameId = requestAnimationFrame(updateFPS);
    };
    
    animationFrameId = requestAnimationFrame(updateFPS);
    
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [showWhenBelow]);
  
  if (!isVisible) return null;
  
  // 根据FPS值设置颜色
  const getFpsColor = (fpsValue) => {
    if (fpsValue >= 50) return '#4CAF50'; // 绿色 - 流畅
    if (fpsValue >= 30) return '#FFC107'; // 黄色 - 可接受
    return '#F44336'; // 红色 - 卡顿
  };
  
  return (
    <div style={{
      position: 'fixed',
      top: '10px',
      right: '10px',
      padding: '8px 12px',
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      color: getFpsColor(fps),
      fontFamily: 'monospace',
      fontSize: '14px',
      borderRadius: '4px',
      zIndex: 9999
    }}>
      FPS: {fps}
    </div>
  );
};

// 在应用中使用
const App = () => {
  return (
    <div>
      <FPSMonitor />
      {/* 你的应用内容 */}
    </div>
  );
};
```

## 5. 性能监控上报系统

将帧率数据上报到监控系统：

```javascript
class PerformanceReporter {
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/performance-report';
    this.sampleRate = options.sampleRate || 0.1; // 采样率 10%
    this.fpsThreshold = options.fpsThreshold || 30; // FPS阈值
    this.reportInterval = options.reportInterval || 30000; // 30秒上报一次
    this.performanceData = {
      fps: [],
      slowFrameCount: 0,
      totalFrames: 0
    };
  }
  
  init() {
    // 随机采样
    if (Math.random() > this.sampleRate) {
      return; // 不在采样范围内，不启动监控
    }
    
    this.startFPSMonitoring();
    this.setupPeriodicReporting();
  }
  
  startFPSMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    let slowFrameCount = 0;
    
    const monitor = (currentTime) => {
      frameCount++;
      this.performanceData.totalFrames++;
      
      if (currentTime - lastTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        this.performanceData.fps.push(fps);
        
        if (fps < this.fpsThreshold) {
          slowFrameCount++;
          this.performanceData.slowFrameCount++;
        }
        
        // 保持数组大小
        if (this.performanceData.fps.length > 60) {
          this.performanceData.fps.shift();
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(monitor);
    };
    
    requestAnimationFrame(monitor);
  }
  
  setupPeriodicReporting() {
    setInterval(() => {
      this.reportPerformanceData();
    }, this.reportInterval);
  }
  
  reportPerformanceData() {
    if (this.performanceData.fps.length === 0) return;
    
    const reportData = {
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      performance: {
        avgFps: this.performanceData.fps.reduce((a, b) => a + b, 0) / this.performanceData.fps.length,
        minFps: Math.min(...this.performanceData.fps),
        maxFps: Math.max(...this.performanceData.fps),
        slowFrameCount: this.performanceData.slowFrameCount,
        totalFrames: this.performanceData.totalFrames,
        fpsSamples: [...this.performanceData.fps]
      }
    };
    
    // 发送到服务器
    fetch(this.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(reportData)
    }).catch(error => {
      console.error('性能数据上报失败:', error);
    });
  }
}

// 初始化性能监控
const performanceReporter = new PerformanceReporter({
  apiEndpoint: '/api/performance',
  sampleRate: 0.2, // 20% 采样率
  fpsThreshold: 25, // 低于25FPS认为是慢帧
  reportInterval: 60000 // 每分钟上报一次
});

performanceReporter.init();
```

## 6. 使用 Chrome DevTools Protocol

在开发环境中使用更详细的性能监控：

```javascript
// 通过CDP监控更详细的性能指标
async function monitorWithCDP() {
  if ('chrome' in window && 'webstore' in window.chrome) {
    // 在Chrome扩展或支持CDP的环境中
    try {
      // 获取详细的渲染性能数据
      const performanceEntries = performance.getEntriesByType('measure');
      console.log('Performance measures:', performanceEntries);
    } catch (error) {
      console.log('CDP not available:', error);
    }
  }
}
```

## 总结

帧率监控的关键点：

1. **实时监控**：使用 requestAnimationFrame 计算FPS
2. **数据收集**：记录历史FPS数据、慢帧统计
3. **阈值报警**：当FPS低于阈值时触发警报
4. **数据上报**：将性能数据上报到监控系统
5. **可视化展示**：在页面上显示实时FPS
6. **分析优化**：根据监控数据进行性能优化

通过这些方法，可以有效地监控和优化页面的渲染性能，确保用户获得流畅的体验。
