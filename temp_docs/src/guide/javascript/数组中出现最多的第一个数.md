# 数组中出现最多的第一个数？（了解）

**题目**: 数组中出现最多的第一个数？（了解）

## 解题思路

这个问题要求找出数组中出现次数最多的元素，如果有多个元素出现次数相同，则返回最先出现的那个元素。这需要我们既要统计元素出现的次数，也要记录元素首次出现的位置。

## 解决方案

### 方法一：哈希表 + 位置记录（推荐）

```javascript
function findMostFrequentFirst(arr) {
    if (!arr || arr.length === 0) {
        return null;
    }
    
    // 使用Map来记录每个元素的出现次数和首次出现位置
    const countMap = new Map(); // {value: count}
    const firstIndexMap = new Map(); // {value: firstIndex}
    
    // 遍历数组，统计出现次数和记录首次出现位置
    for (let i = 0; i < arr.length; i++) {
        const num = arr[i];
        
        // 记录首次出现位置（只记录一次）
        if (!firstIndexMap.has(num)) {
            firstIndexMap.set(num, i);
        }
        
        // 统计出现次数
        countMap.set(num, (countMap.get(num) || 0) + 1);
    }
    
    let maxCount = 0;
    let result = null;
    let earliestIndex = arr.length; // 初始化为最大索引+1
    
    // 遍历所有唯一元素，找出出现次数最多且首次出现最早的元素
    for (const [num, count] of countMap) {
        const firstIndex = firstIndexMap.get(num);
        
        // 如果出现次数更多，或者出现次数相同但首次出现更早，则更新结果
        if (count > maxCount || (count === maxCount && firstIndex < earliestIndex)) {
            maxCount = count;
            result = num;
            earliestIndex = firstIndex;
        }
    }
    
    return result;
}

// 测试示例
console.log(findMostFrequentFirst([4, 5, 6, 5, 4, 3])); // 输出: 4 (4和5都出现2次，但4先出现)
console.log(findMostFrequentFirst([1, 2, 3, 2, 1, 1])); // 输出: 1
console.log(findMostFrequentFirst([7, 7, 4, 4, 7]));    // 输出: 7
```

### 方法二：一次遍历优化

```javascript
function findMostFrequentFirstOptimized(arr) {
    if (!arr || arr.length === 0) {
        return null;
    }
    
    const countMap = new Map();
    const firstIndexMap = new Map();
    let maxCount = 0;
    let result = arr[0]; // 初始化为第一个元素
    let earliestIndex = 0;
    
    for (let i = 0; i < arr.length; i++) {
        const num = arr[i];
        
        // 记录首次出现位置
        if (!firstIndexMap.has(num)) {
            firstIndexMap.set(num, i);
        }
        
        // 更新计数
        const newCount = (countMap.get(num) || 0) + 1;
        countMap.set(num, newCount);
        
        // 检查是否需要更新结果
        if (newCount > maxCount || 
            (newCount === maxCount && firstIndexMap.get(num) < firstIndexMap.get(result))) {
            maxCount = newCount;
            result = num;
        }
    }
    
    return result;
}
```

### 方法三：使用对象替代Map

```javascript
function findMostFrequentFirstWithObject(arr) {
    if (!arr || arr.length === 0) {
        return null;
    }
    
    const stats = {}; // {value: {count: count, firstIndex: index}}
    
    for (let i = 0; i < arr.length; i++) {
        const num = arr[i];
        
        if (stats[num] === undefined) {
            stats[num] = { count: 0, firstIndex: i };
        }
        
        stats[num].count++;
    }
    
    let maxCount = 0;
    let earliestIndex = arr.length;
    let result = null;
    
    for (const num in stats) {
        const { count, firstIndex } = stats[num];
        const numValue = isNaN(num) ? num : Number(num);
        
        if (count > maxCount || (count === maxCount && firstIndex < earliestIndex)) {
            maxCount = count;
            earliestIndex = firstIndex;
            result = numValue;
        }
    }
    
    return result;
}
```

## 复杂度分析

- 时间复杂度：O(n)，其中n是数组长度，需要遍历数组一次
- 空间复杂度：O(k)，其中k是数组中不同元素的个数，用于存储哈希表

## 关键点总结

1. 需要同时记录元素出现次数和首次出现位置
2. 当多个元素出现次数相同时，选择首次出现位置最靠前的元素
3. 使用Map数据结构可以更方便地处理各种类型的元素
4. 可以在一次遍历中完成统计，提高效率
5. 需要考虑边界情况，如空数组或单元素数组
