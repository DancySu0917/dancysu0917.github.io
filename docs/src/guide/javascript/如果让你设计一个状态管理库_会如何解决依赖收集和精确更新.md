# 如果让你设计一个状态管理库，会如何解决依赖收集和精确更新？（了解）

## 问题分析

这个问题考察的是对状态管理库核心机制的理解，主要包括两个方面：
1. 依赖收集：如何追踪哪些组件或函数依赖于哪些状态
2. 精确更新：如何只更新依赖于变化状态的组件，而不是全局更新

## 核心解决方案

### 1. 依赖收集机制

依赖收集的核心思想是：
- 在组件渲染时，记录哪些状态被访问了
- 将这些状态和组件建立映射关系
- 当状态变化时，只通知对应的组件更新

### 2. 精确更新机制

精确更新的关键在于：
- 状态变化时，只通知依赖该状态的组件
- 避免不必要的重新渲染
- 保持最小的更新粒度

## 实现方案

### 方案一：基于 Proxy 的响应式系统

```javascript
class Store {
  constructor(initialState) {
    this.state = this.createReactive(initialState);
    this.subscribers = new Map(); // 依赖收集映射
    this.activeEffect = null;
  }

  // 创建响应式对象
  createReactive(obj) {
    const self = this;
    return new Proxy(obj, {
      get(target, key, receiver) {
        // 依赖收集：记录当前effect依赖于这个key
        if (self.activeEffect) {
          self.collectDependency(key);
        }
        return Reflect.get(target, key, receiver);
      },
      set(target, key, value, receiver) {
        const result = Reflect.set(target, key, value, receiver);
        // 触发更新：通知依赖于这个key的effects
        self.triggerUpdate(key);
        return result;
      }
    });
  }

  // 收集依赖
  collectDependency(key) {
    if (this.activeEffect) {
      if (!this.subscribers.has(key)) {
        this.subscribers.set(key, new Set());
      }
      this.subscribers.get(key).add(this.activeEffect);
    }
  }

  // 触发更新
  triggerUpdate(key) {
    const subscribers = this.subscribers.get(key);
    if (subscribers) {
      subscribers.forEach(effect => {
        effect();
      });
    }
  }

  // 注册副作用函数
  effect(fn) {
    const effectFn = () => {
      this.activeEffect = effectFn;
      fn();
      this.activeEffect = null;
    };
    effectFn();
  }
}
```

### 方案二：基于订阅发布模式

```javascript
class StateManager {
  constructor() {
    this.state = {};
    this.observers = {}; // 观察者模式
    this.dependencyGraph = new Map(); // 依赖图
  }

  setState(newState) {
    const oldState = { ...this.state };
    this.state = { ...this.state, ...newState };

    // 精确更新：只通知依赖于变化状态的组件
    Object.keys(newState).forEach(key => {
      if (oldState[key] !== newState[key]) {
        this.notifyObservers(key);
      }
    });
  }

  subscribe(key, callback) {
    if (!this.observers[key]) {
      this.observers[key] = [];
    }
    this.observers[key].push(callback);
  }

  unsubscribe(key, callback) {
    if (this.observers[key]) {
      this.observers[key] = this.observers[key].filter(cb => cb !== callback);
    }
  }

  notifyObservers(key) {
    if (this.observers[key]) {
      this.observers[key].forEach(callback => callback(this.state[key]));
    }
  }

  // 依赖收集：记录组件对状态的依赖关系
  trackDependency(componentId, stateKey) {
    if (!this.dependencyGraph.has(componentId)) {
      this.dependencyGraph.set(componentId, new Set());
    }
    this.dependencyGraph.get(componentId).add(stateKey);
  }
}
```

### 方案三：基于 WeakMap 的精细化依赖管理

```javascript
class ReactiveStore {
  constructor(initialState) {
    this.state = initialState;
    this.depMap = new WeakMap(); // 存储响应式依赖
    this.subscribers = new Map(); // 存储订阅者
  }

  // 创建响应式数据
  reactive(data) {
    const self = this;
    return new Proxy(data, {
      get(target, key, receiver) {
        // 收集依赖
        if (self.activeEffect) {
          self.track(target, key);
        }
        const value = Reflect.get(target, key, receiver);
        if (typeof value === 'object' && value !== null) {
          return self.reactive(value);
        }
        return value;
      },
      set(target, key, value, receiver) {
        const oldValue = target[key];
        const result = Reflect.set(target, key, value, receiver);
        if (oldValue !== value) {
          // 精确触发更新
          self.trigger(target, key);
        }
        return result;
      }
    });
  }

  track(target, key) {
    if (this.activeEffect) {
      let depsMap = this.depMap.get(target);
      if (!depsMap) {
        depsMap = new Map();
        this.depMap.set(target, depsMap);
      }
      let dep = depsMap.get(key);
      if (!dep) {
        dep = new Set();
        depsMap.set(key, dep);
      }
      dep.add(this.activeEffect);
    }
  }

  trigger(target, key) {
    const depsMap = this.depMap.get(target);
    if (depsMap) {
      const dep = depsMap.get(key);
      if (dep) {
        dep.forEach(effect => {
          effect();
        });
      }
    }
  }

  // 创建响应式副作用
  effect(fn) {
    const effectFn = () => {
      this.activeEffect = effectFn;
      fn();
      this.activeEffect = null;
    };
    effectFn();
    return effectFn;
  }
}
```

## 实际应用示例

```javascript
// 使用示例
const store = new ReactiveStore({
  user: { name: 'John', age: 30 },
  count: 0
});

// 组件A只依赖count
store.effect(() => {
  console.log('Count changed:', store.state.count);
});

// 组件B只依赖user.name
store.effect(() => {
  console.log('User name changed:', store.state.user.name);
});

// 修改count只会触发组件A的更新
store.state.count = 1; // 只触发第一个effect
store.state.user.name = 'Jane'; // 只触发第二个effect
```

## 优化策略

### 1. 批量更新
```javascript
class BatchUpdateStore {
  constructor() {
    this.pendingUpdates = new Set();
    this.isFlushing = false;
  }

  scheduleUpdate(key) {
    this.pendingUpdates.add(key);
    if (!this.isFlushing) {
      this.isFlushing = true;
      Promise.resolve().then(() => {
        this.flushUpdates();
      });
    }
  }

  flushUpdates() {
    this.pendingUpdates.forEach(key => {
      this.notifyObservers(key);
    });
    this.pendingUpdates.clear();
    this.isFlushing = false;
  }
}
```

### 2. 订阅优化
- 使用路径订阅而非对象级订阅
- 支持深度路径依赖追踪
- 实现依赖关系的动态更新

## 总结

设计状态管理库时，依赖收集和精确更新是核心机制：
1. 依赖收集通过Proxy或getter/setter机制实现
2. 精确更新通过订阅发布模式确保只更新相关组件
3. 需要考虑性能优化，如批量更新、依赖缓存等
4. 实际实现中需要处理边界情况，如异步更新、嵌套对象等