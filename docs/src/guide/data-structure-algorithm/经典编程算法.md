# 经典编程算法？（高薪常问）

**题目**: 经典编程算法？（高薪常问）

**答案**:

经典的编程算法是面试中的重点，以下是几类重要的算法及其应用场景：

## 1. 排序算法

### 冒泡排序（Bubble Sort）
- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 思路：相邻元素比较，大的往后移

```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
```

### 快速排序（Quick Sort）
- 时间复杂度：平均 O(n log n)，最坏 O(n²)
- 空间复杂度：O(log n)
- 思路：分治法，选择基准元素分割数组

```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}
```

### 归并排序（Merge Sort）
- 时间复杂度：O(n log n)
- 空间复杂度：O(n)
- 思路：分治法，将数组分成两半分别排序再合并

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    return result.concat(left.slice(i), right.slice(j));
}
```

## 2. 搜索算法

### 二分搜索（Binary Search）
- 时间复杂度：O(log n)
- 空间复杂度：O(1) 或 O(log n) 递归
- 适用：已排序数组

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

## 3. 动态规划（Dynamic Programming）

### 斐波那契数列
```javascript
function fibonacci(n) {
    if (n <= 1) return n;
    
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}
```

### 最长公共子序列（LCS）
```javascript
function longestCommonSubsequence(text1, text2) {
    const m = text1.length;
    const n = text2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}
```

## 4. 贪心算法（Greedy Algorithm）

### 活动选择问题
```javascript
function activitySelection(start, end) {
    const n = start.length;
    const activities = [];
    
    for (let i = 0; i < n; i++) {
        activities.push({ start: start[i], end: end[i], index: i });
    }
    
    // 按结束时间排序
    activities.sort((a, b) => a.end - b.end);
    
    const result = [activities[0]];
    let lastEnd = activities[0].end;
    
    for (let i = 1; i < n; i++) {
        if (activities[i].start >= lastEnd) {
            result.push(activities[i]);
            lastEnd = activities[i].end;
        }
    }
    
    return result;
}
```

## 5. 回溯算法（Backtracking）

### 八皇后问题
```javascript
function solveNQueens(n) {
    const result = [];
    const board = Array(n).fill().map(() => Array(n).fill('.'));
    
    function isValid(row, col) {
        // 检查列
        for (let i = 0; i < row; i++) {
            if (board[i][col] === 'Q') return false;
        }
        
        // 检查左上对角线
        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }
        
        // 检查右上对角线
        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] === 'Q') return false;
        }
        
        return true;
    }
    
    function backtrack(row) {
        if (row === n) {
            result.push(board.map(r => r.join('')));
            return;
        }
        
        for (let col = 0; col < n; col++) {
            if (isValid(row, col)) {
                board[row][col] = 'Q';
                backtrack(row + 1);
                board[row][col] = '.';
            }
        }
    }
    
    backtrack(0);
    return result;
}
```

## 6. 图算法

### 深度优先搜索（DFS）
```javascript
function dfs(graph, start) {
    const visited = new Set();
    const result = [];
    
    function dfsHelper(node) {
        visited.add(node);
        result.push(node);
        
        for (const neighbor of graph[node] || []) {
            if (!visited.has(neighbor)) {
                dfsHelper(neighbor);
            }
        }
    }
    
    dfsHelper(start);
    return result;
}
```

### 广度优先搜索（BFS）
```javascript
function bfs(graph, start) {
    const visited = new Set();
    const queue = [start];
    const result = [];
    
    visited.add(start);
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph[node] || []) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return result;
}
```

## 7. 字符串算法

### KMP算法（字符串匹配）
```javascript
function kmpSearch(text, pattern) {
    if (!pattern) return 0;
    
    // 构建部分匹配表
    const lps = buildLPS(pattern);
    let i = 0; // text的索引
    let j = 0; // pattern的索引
    
    while (i < text.length) {
        if (text[i] === pattern[j]) {
            i++;
            j++;
        }
        
        if (j === pattern.length) {
            return i - j; // 找到匹配
        } else if (i < text.length && text[i] !== pattern[j]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return -1; // 未找到匹配
}

function buildLPS(pattern) {
    const lps = Array(pattern.length).fill(0);
    let len = 0;
    let i = 1;
    
    while (i < pattern.length) {
        if (pattern[i] === pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len !== 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}
```

掌握这些经典算法及其变种是解决复杂问题的基础，面试中通常会考查对这些算法的理解和应用能力。
