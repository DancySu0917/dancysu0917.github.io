# 封装运动函数（必会）

**题目**: 封装运动函数（必会）

## 核心答案

封装运动函数的核心是创建可复用的动画函数，主要涉及：

1. 使用 `requestAnimationFrame` 实现平滑动画
2. 支持多种缓动函数（linear, ease-in, ease-out, ease-in-out等）
3. 提供回调函数支持
4. 支持中断和暂停功能

## 详细说明

### 1. 基础运动函数

```javascript
/**
 * 基础运动函数
 * @param {HTMLElement} element - 要运动的元素
 * @param {Object} target - 目标样式对象
 * @param {number} duration - 动画持续时间（毫秒）
 * @param {Function} callback - 动画完成后的回调函数
 */
function animate(element, target, duration, callback) {
    // 记录开始时间
    const startTime = Date.now();
    
    // 获取当前样式
    const current = {};
    for (let prop in target) {
        current[prop] = parseFloat(getComputedStyle(element)[prop]) || 0;
    }
    
    // 动画执行函数
    function step() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 计算当前值
        for (let prop in target) {
            const startValue = current[prop];
            const targetValue = target[prop];
            const currentValue = startValue + (targetValue - startValue) * progress;
            
            element.style[prop] = currentValue + (prop === 'opacity' ? '' : 'px');
        }
        
        if (progress < 1) {
            requestAnimationFrame(step);
        } else if (callback) {
            callback();
        }
    }
    
    // 开始动画
    requestAnimationFrame(step);
}

// 使用示例
const box = document.getElementById('box');
animate(box, { left: 300, top: 200, opacity: 0.5 }, 2000, () => {
    console.log('动画完成');
});
```

### 2. 支持缓动函数的运动函数

```javascript
/**
 * 缓动函数集合
 */
const easingFunctions = {
    // 线性运动
    linear: t => t,
    
    // 二次缓入
    easeInQuad: t => t * t,
    
    // 二次缓出
    easeOutQuad: t => t * (2 - t),
    
    // 二次缓入缓出
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    
    // 三次缓入
    easeInCubic: t => t * t * t,
    
    // 三次缓出
    easeOutCubic: t => (--t) * t * t + 1,
    
    // 三次缓入缓出
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
};

/**
 * 支持缓动函数的运动函数
 * @param {HTMLElement} element - 要运动的元素
 * @param {Object} target - 目标样式对象
 * @param {number} duration - 动画持续时间（毫秒）
 * @param {string} easing - 缓动函数名称
 * @param {Function} callback - 动画完成后的回调函数
 */
function animateWithEasing(element, target, duration, easing = 'linear', callback) {
    const startTime = Date.now();
    const easingFn = easingFunctions[easing] || easingFunctions.linear;
    
    // 获取当前样式
    const current = {};
    for (let prop in target) {
        current[prop] = parseFloat(getComputedStyle(element)[prop]) || 0;
    }
    
    function step() {
        const elapsed = Date.now() - startTime;
        const rawProgress = elapsed / duration;
        const progress = Math.min(rawProgress, 1);
        const easedProgress = easingFn(progress);
        
        // 计算当前值
        for (let prop in target) {
            const startValue = current[prop];
            const targetValue = target[prop];
            const currentValue = startValue + (targetValue - startValue) * easedProgress;
            
            element.style[prop] = currentValue + (prop === 'opacity' ? '' : 'px');
        }
        
        if (progress < 1) {
            requestAnimationFrame(step);
        } else if (callback) {
            callback();
        }
    }
    
    requestAnimationFrame(step);
}

// 使用示例
animateWithEasing(box, { left: 500 }, 2000, 'easeOutCubic', () => {
    console.log('缓动动画完成');
});
```

### 3. 完整的运动函数类

```javascript
class Motion {
    constructor() {
        this.animations = new Map(); // 存储所有动画实例
    }
    
    /**
     * 执行动画
     * @param {HTMLElement} element - 要运动的元素
     * @param {Object} target - 目标样式对象
     * @param {Object} options - 动画选项
     */
    animate(element, target, options = {}) {
        const {
            duration = 300,
            easing = 'linear',
            delay = 0,
            callback = null,
            onStart = null,
            onUpdate = null
        } = options;
        
        // 生成唯一ID
        const id = this.generateId();
        
        // 获取当前样式
        const current = {};
        for (let prop in target) {
            current[prop] = this.getCurrentValue(element, prop);
        }
        
        let startTime = null;
        let animationId = null;
        
        // 创建动画对象
        const animation = {
            id,
            element,
            target,
            current,
            duration,
            easing: easingFunctions[easing] || easingFunctions.linear,
            delay,
            callback,
            onStart,
            onUpdate,
            isRunning: true,
            pauseTime: 0,
            paused: false
        };
        
        // 将动画添加到集合中
        this.animations.set(id, animation);
        
        // 开始动画
        const startAnimation = () => {
            if (animation.onStart) {
                animation.onStart();
            }
            
            const step = (timestamp) => {
                if (!startTime) startTime = timestamp;
                
                if (animation.paused) {
                    startTime = timestamp - animation.pauseTime;
                    animationId = requestAnimationFrame(step);
                    return;
                }
                
                const elapsed = timestamp - startTime;
                const rawProgress = (elapsed - delay) / duration;
                const progress = Math.min(Math.max(rawProgress, 0), 1);
                const easedProgress = animation.easing(progress);
                
                // 计算当前值
                for (let prop in target) {
                    const startValue = current[prop];
                    const targetValue = target[prop];
                    const currentValue = startValue + (targetValue - startValue) * easedProgress;
                    
                    this.applyStyle(element, prop, currentValue);
                }
                
                if (animation.onUpdate) {
                    animation.onUpdate({
                        progress,
                        elapsed: elapsed - delay,
                        element
                    });
                }
                
                if (progress < 1) {
                    animationId = requestAnimationFrame(step);
                } else {
                    if (animation.callback) {
                        animation.callback();
                    }
                    this.animations.delete(id);
                }
            };
            
            animationId = requestAnimationFrame(step);
        };
        
        // 延迟启动
        if (delay > 0) {
            setTimeout(startAnimation, delay);
        } else {
            startAnimation();
        }
        
        return id; // 返回动画ID，用于控制动画
    }
    
    /**
     * 暂停动画
     */
    pause(animationId) {
        const animation = this.animations.get(animationId);
        if (animation) {
            animation.paused = true;
            animation.pauseTime = Date.now();
        }
    }
    
    /**
     * 恢复动画
     */
    resume(animationId) {
        const animation = this.animations.get(animationId);
        if (animation && animation.paused) {
            animation.paused = false;
            animation.pauseTime = Date.now() - animation.pauseTime;
        }
    }
    
    /**
     * 停止动画
     */
    stop(animationId) {
        const animation = this.animations.get(animationId);
        if (animation) {
            cancelAnimationFrame(animation.animationId);
            this.animations.delete(animationId);
        }
    }
    
    /**
     * 获取当前样式值
     */
    getCurrentValue(element, prop) {
        const value = getComputedStyle(element)[prop];
        return parseFloat(value) || 0;
    }
    
    /**
     * 应用样式
     */
    applyStyle(element, prop, value) {
        if (prop === 'opacity') {
            element.style[prop] = value;
        } else if (prop === 'transform') {
            element.style.transform = value;
        } else {
            element.style[prop] = value + 'px';
        }
    }
    
    /**
     * 生成唯一ID
     */
    generateId() {
        return 'motion_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
}

// 使用示例
const motion = new Motion();

// 基础动画
motion.animate(box, { left: 300, top: 200 }, {
    duration: 2000,
    easing: 'easeOutCubic',
    callback: () => console.log('动画完成'),
    onUpdate: (data) => console.log('进度:', data.progress)
});

// 暂停和恢复
const animationId = motion.animate(box, { left: 500 }, { duration: 1000 });
motion.pause(animationId);
setTimeout(() => motion.resume(animationId), 1000);
```

### 4. 支持CSS Transform的运动函数

```javascript
/**
 * 支持CSS Transform的运动函数
 * @param {HTMLElement} element - 要运动的元素
 * @param {Object} transform - 变换对象
 * @param {number} duration - 动画持续时间
 * @param {string} easing - 缓动函数
 * @param {Function} callback - 回调函数
 */
function transformAnimate(element, transform, duration, easing = 'linear', callback) {
    const startTime = Date.now();
    const currentTransform = element.style.transform || '';
    
    // 解析当前transform值
    const currentValues = parseTransform(currentTransform);
    
    // 合并目标值
    const targetValues = { ...currentValues, ...transform };
    
    function step() {
        const elapsed = Date.now() - startTime;
        const rawProgress = elapsed / duration;
        const progress = Math.min(rawProgress, 1);
        const easingFn = easingFunctions[easing] || easingFunctions.linear;
        const easedProgress = easingFn(progress);
        
        // 计算当前变换值
        const newTransform = calculateTransform(currentValues, targetValues, easedProgress);
        element.style.transform = newTransform;
        
        if (progress < 1) {
            requestAnimationFrame(step);
        } else if (callback) {
            callback();
        }
    }
    
    requestAnimationFrame(step);
}

/**
 * 解析transform字符串
 */
function parseTransform(transformStr) {
    const result = {};
    
    // 提取 translate
    const translateMatch = transformStr.match(/translate\(([^)]+)\)/);
    if (translateMatch) {
        const values = translateMatch[1].split(',').map(v => parseFloat(v.trim()));
        result.translateX = values[0] || 0;
        result.translateY = values[1] || 0;
    }
    
    // 提取 scale
    const scaleMatch = transformStr.match(/scale\(([^)]+)\)/);
    if (scaleMatch) {
        const values = scaleMatch[1].split(',').map(v => parseFloat(v.trim()));
        result.scaleX = values[0] || 1;
        result.scaleY = values[1] || values[0] || 1;
    }
    
    // 提取 rotate
    const rotateMatch = transformStr.match(/rotate\(([^)]+)\)/);
    if (rotateMatch) {
        result.rotate = parseFloat(rotateMatch[1]) || 0;
    }
    
    return result;
}

/**
 * 计算transform字符串
 */
function calculateTransform(current, target, progress) {
    let transform = '';
    
    if (target.translateX !== undefined || target.translateY !== undefined) {
        const x = current.translateX || 0;
        const y = current.translateY || 0;
        const targetX = target.translateX || 0;
        const targetY = target.translateY || 0;
        const newX = x + (targetX - x) * progress;
        const newY = y + (targetY - y) * progress;
        transform += `translate(${newX}px, ${newY}px) `;
    }
    
    if (target.scaleX !== undefined || target.scaleY !== undefined) {
        const x = current.scaleX || 1;
        const y = current.scaleY || 1;
        const targetX = target.scaleX || 1;
        const targetY = target.scaleY || 1;
        const scaleX = x + (targetX - x) * progress;
        const scaleY = y + (targetY - y) * progress;
        transform += `scale(${scaleX}, ${scaleY}) `;
    }
    
    if (target.rotate !== undefined) {
        const currentRotate = current.rotate || 0;
        const targetRotate = target.rotate || 0;
        const rotate = currentRotate + (targetRotate - currentRotate) * progress;
        transform += `rotate(${rotate}deg) `;
    }
    
    return transform.trim();
}

// 使用示例
transformAnimate(box, {
    translateX: 200,
    translateY: 100,
    scaleX: 1.5,
    scaleY: 1.5,
    rotate: 45
}, 2000, 'easeOutCubic');
```

## 实际应用场景

### 1. 页面元素淡入淡出

```javascript
function fadeIn(element, duration = 500, callback) {
    element.style.opacity = 0;
    element.style.display = 'block';
    
    animate(element, { opacity: 1 }, duration, callback);
}

function fadeOut(element, duration = 500, callback) {
    animate(element, { opacity: 0 }, duration, () => {
        element.style.display = 'none';
        if (callback) callback();
    });
}
```

### 2. 滚动动画

```javascript
function smoothScrollTo(element, targetY, duration = 500) {
    const startY = element.scrollTop;
    const distance = targetY - startY;
    
    animateScroll(element, startY, targetY, duration);
}

function animateScroll(element, startY, endY, duration) {
    const startTime = Date.now();
    
    function step() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 使用缓动函数
        const easeProgress = easingFunctions.easeOutCubic(progress);
        const currentY = startY + (endY - startY) * easeProgress;
        
        element.scrollTop = currentY;
        
        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }
    
    requestAnimationFrame(step);
}
```

### 3. 轮播图动画

```javascript
class Carousel {
    constructor(container, options = {}) {
        this.container = container;
        this.items = container.querySelectorAll('.carousel-item');
        this.currentIndex = 0;
        this.duration = options.duration || 500;
        this.autoPlay = options.autoPlay || false;
        this.interval = options.interval || 3000;
        
        this.init();
    }
    
    init() {
        this.container.style.position = 'relative';
        this.items.forEach((item, index) => {
            item.style.position = 'absolute';
            item.style.left = (index === 0 ? 0 : '100%') + 'vw';
        });
        
        if (this.autoPlay) {
            this.startAutoPlay();
        }
    }
    
    goTo(index) {
        if (index < 0) index = this.items.length - 1;
        if (index >= this.items.length) index = 0;
        
        const current = this.items[this.currentIndex];
        const next = this.items[index];
        
        // 设置下一个元素的初始位置
        next.style.left = '100%';
        
        // 动画切换
        animate(current, { left: -100 }, this.duration, null);
        animate(next, { left: 0 }, this.duration, () => {
            this.currentIndex = index;
        });
    }
    
    next() {
        this.goTo(this.currentIndex + 1);
    }
    
    prev() {
        this.goTo(this.currentIndex - 1);
    }
    
    startAutoPlay() {
        this.timer = setInterval(() => {
            this.next();
        }, this.interval);
    }
    
    stopAutoPlay() {
        if (this.timer) {
            clearInterval(this.timer);
        }
    }
}
```

## 性能优化建议

### 1. 使用 transform 和 opacity

```javascript
// 好的做法：使用 transform 和 opacity（只触发合成）
element.style.transform = `translateX(${x}px)`;
element.style.opacity = 0.5;

// 避免的做法：使用 left, top 等会触发重排重绘的属性
element.style.left = x + 'px'; // 触发重排重绘
```

### 2. 批量更新样式

```javascript
// 避免逐个设置样式
element.style.left = x + 'px';
element.style.top = y + 'px';
element.style.opacity = 0.5;

// 推荐：批量设置样式
element.style.cssText = `left: ${x}px; top: ${y}px; opacity: 0.5;`;
```

### 3. 使用 will-change 属性

```css
.animated-element {
    will-change: transform, opacity;
}
```

## 面试要点

- 理解 `requestAnimationFrame` 的优势
- 掌握缓动函数的实现原理
- 了解如何避免性能问题
- 知道如何处理动画的开始、暂停、停止
- 了解CSS Transform在动画中的应用
- 掌握动画回调函数的处理
- 理解如何实现链式动画
