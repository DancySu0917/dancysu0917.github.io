# 合并链表时要创建新的链表节点吗？不创建额外空间，直接在原链表上操作可以实现吗？（了解）

**题目**: 合并链表时要创建新的链表节点吗？不创建额外空间，直接在原链表上操作可以实现吗？（了解）

## 问题分析

这是一个关于链表合并算法的问题，主要考察：
1. 链表合并的两种实现方式：创建新节点 vs 复用原节点
2. 空间复杂度的考虑
3. 不同场景下的选择策略

## 解决方案

### 方案一：创建新节点的合并方式

```javascript
// 定义链表节点
class ListNode {
  constructor(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
  }
}

/**
 * 合并两个有序链表 - 创建新节点方式
 * @param {ListNode} list1 - 第一个有序链表
 * @param {ListNode} list2 - 第二个有序链表
 * @return {ListNode} - 合并后的有序链表
 */
function mergeTwoListsNewNodes(list1, list2) {
  // 创建虚拟头节点
  const dummy = new ListNode(0);
  let current = dummy;
  
  // 遍历两个链表
  while (list1 && list2) {
    if (list1.val <= list2.val) {
      // 创建新节点，复制值
      current.next = new ListNode(list1.val);
      list1 = list1.next;
    } else {
      current.next = new ListNode(list2.val);
      list2 = list2.next;
    }
    current = current.next;
  }
  
  // 连接剩余节点
  current.next = list1 || list2;
  
  return dummy.next;
}
```

### 方案二：直接在原链表上操作（复用节点）

```javascript
/**
 * 合并两个有序链表 - 复用原节点方式
 * @param {ListNode} list1 - 第一个有序链表
 * @param {ListNode} list2 - 第二个有序链表
 * @return {ListNode} - 合并后的有序链表
 */
function mergeTwoListsReuseNodes(list1, list2) {
  // 创建虚拟头节点
  const dummy = new ListNode(0);
  let current = dummy;
  
  // 遍历两个链表
  while (list1 && list2) {
    if (list1.val <= list2.val) {
      // 直接复用原节点，不创建新节点
      current.next = list1;
      list1 = list1.next;
    } else {
      current.next = list2;
      list2 = list2.next;
    }
    current = current.next;
  }
  
  // 连接剩余节点
  current.next = list1 || list2;
  
  return dummy.next;
}
```

### 方案三：递归方式（复用节点）

```javascript
/**
 * 递归合并两个有序链表
 * @param {ListNode} list1 - 第一个有序链表
 * @param {ListNode} list2 - 第二个有序链表
 * @return {ListNode} - 合并后的有序链表
 */
function mergeTwoListsRecursive(list1, list2) {
  // 递归终止条件
  if (!list1) return list2;
  if (!list2) return list1;
  
  if (list1.val <= list2.val) {
    list1.next = mergeTwoListsRecursive(list1.next, list2);
    return list1; // 复用list1的节点
  } else {
    list2.next = mergeTwoListsRecursive(list1, list2.next);
    return list2; // 复用list2的节点
  }
}
```

## 复杂度分析

| 方案 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 创建新节点 | O(m+n) | O(m+n) | 需要创建新节点存储所有元素 |
| 复用原节点 | O(m+n) | O(1) | 只需要常数额外空间 |
| 递归方式 | O(m+n) | O(m+n) | 递归调用栈的空间 |

## 优缺点对比

### 创建新节点方式
**优点：**
- 原链表结构不受影响
- 线程安全，不会影响其他引用
- 更容易理解和调试

**缺点：**
- 空间复杂度更高
- 需要额外的内存分配
- 性能稍差

### 复用原节点方式
**优点：**
- 空间复杂度最优 O(1)
- 不需要额外内存分配
- 性能更好

**缺点：**
- 原链表结构会被破坏
- 可能影响其他引用该链表的代码
- 需要注意并发访问问题

## 实际应用场景

### 何时选择创建新节点：
1. 原链表需要保持不变
2. 有其他代码依赖原链表结构
3. 需要线程安全的场景
4. 数据一致性要求高

### 何时选择复用原节点：
1. 确保原链表不会再被使用
2. 内存限制严格的环境
3. 性能要求高的场景
4. 临时合并操作

## 完整示例

```javascript
// 辅助函数：创建链表
function createLinkedList(arr) {
  if (arr.length === 0) return null;
  
  const head = new ListNode(arr[0]);
  let current = head;
  
  for (let i = 1; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
    current = current.next;
  }
  
  return head;
}

// 辅助函数：链表转数组
function linkedListToArray(head) {
  const result = [];
  let current = head;
  
  while (current) {
    result.push(current.val);
    current = current.next;
  }
  
  return result;
}

// 测试示例
const list1 = createLinkedList([1, 2, 4]);
const list2 = createLinkedList([1, 3, 4]);

console.log("原链表1:", linkedListToArray(list1)); // [1, 2, 4]
console.log("原链表2:", linkedListToArray(list2)); // [1, 3, 4]

// 使用复用节点方式合并
const merged1 = mergeTwoListsReuseNodes(list1, list2);
console.log("合并结果(复用节点):", linkedListToArray(merged1)); // [1, 1, 2, 3, 4, 4]

// 重新创建链表进行新节点方式测试
const list1_copy = createLinkedList([1, 2, 4]);
const list2_copy = createLinkedList([1, 3, 4]);

// 使用创建新节点方式合并
const merged2 = mergeTwoListsNewNodes(list1_copy, list2_copy);
console.log("合并结果(创建新节点):", linkedListToArray(merged2)); // [1, 1, 2, 3, 4, 4]
console.log("原链表1(新节点方式):", linkedListToArray(list1_copy)); // [1, 2, 4] - 保持不变
```

## 总结

1. **可以不创建新节点**：完全可以在原链表上直接操作，通过调整指针来实现合并
2. **空间优化**：复用原节点可以将空间复杂度从 O(m+n) 优化到 O(1)
3. **选择策略**：根据具体场景选择，如果需要保持原链表不变则创建新节点，否则复用原节点更优
4. **实际应用**：在性能敏感或内存受限的场景中，复用节点是更好的选择
