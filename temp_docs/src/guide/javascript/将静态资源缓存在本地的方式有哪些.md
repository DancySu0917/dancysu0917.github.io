# 将静态资源缓存在本地的方式有哪些？（了解）

## 标准答案

将静态资源缓存在本地的主要方式包括：
1. **HTTP缓存**：强缓存（Expires、Cache-Control）和协商缓存（Last-Modified/If-Modified-Since、Etag/If-None-Match）
2. **浏览器存储**：LocalStorage、SessionStorage、IndexedDB
3. **Service Worker缓存**：通过Cache API实现精确控制
4. **Web Storage**：Cookie、LocalStorage、SessionStorage
5. **应用缓存**：AppCache（已废弃）和现代PWA缓存策略

## 深入理解

### HTTP缓存机制

**强缓存**：
- Expires：HTTP/1.0标准，使用绝对时间
- Cache-Control：HTTP/1.1标准，优先级更高，使用相对时间

**协商缓存**：
- Last-Modified/If-Modified-Since：基于文件修改时间
- Etag/If-None-Match：基于文件内容哈希值，更精确

### 浏览器存储对比

| 存储方式 | 容量限制 | 持久性 | 适用场景 |
|---------|---------|--------|----------|
| Cookie | 4KB | 可设置过期时间 | 身份认证、小数据存储 |
| LocalStorage | 5-10MB | 持久存储 | 配置信息、用户偏好 |
| SessionStorage | 5-10MB | 会话期间 | 临时数据、表单状态 |
| IndexedDB | 大量数据 | 持久存储 | 复杂数据结构、离线应用 |

### Service Worker缓存优势

- 可编程控制缓存策略
- 支持离线访问
- 实现复杂的缓存逻辑
- 高性能的后台同步

## 代码示例

### 1. HTTP缓存配置

```javascript
// 服务端HTTP缓存头设置（Node.js + Express）
app.use('/static', express.static('public', {
  // 设置强缓存
  maxAge: 3600000, // 1小时
  // 设置ETag
  etag: true,
  // 设置Last-Modified
  lastModified: true
}));

// 手动设置缓存头
app.get('/api/data', (req, res) => {
  // 强缓存设置
  res.setHeader('Cache-Control', 'public, max-age=3600'); // 1小时
  res.setHeader('Expires', new Date(Date.now() + 3600000).toUTCString());
  
  // 协商缓存设置
  res.setHeader('ETag', 'unique-etag-value');
  res.setHeader('Last-Modified', new Date().toUTCString());
  
  res.json({ data: 'example' });
});

// 前端请求处理
async function fetchWithCache(url) {
  try {
    const response = await fetch(url, {
      cache: 'force-cache' // 强制使用缓存
    });
    
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    console.error('请求失败:', error);
  }
}
```

### 2. 浏览器存储操作

```javascript
// LocalStorage操作封装
class LocalStorageManager {
  static set(key, value) {
    try {
      const serializedValue = JSON.stringify(value);
      localStorage.setItem(key, serializedValue);
      return true;
    } catch (error) {
      console.error('LocalStorage设置失败:', error);
      return false;
    }
  }
  
  static get(key) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('LocalStorage读取失败:', error);
      return null;
    }
  }
  
  static remove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error('LocalStorage删除失败:', error);
      return false;
    }
  }
  
  static clear() {
    try {
      localStorage.clear();
      return true;
    } catch (error) {
      console.error('LocalStorage清空失败:', error);
      return false;
    }
  }
}

// IndexedDB操作示例
class IndexedDBManager {
  constructor(dbName, version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        this.db = event.target.result;
        // 创建对象存储
        if (!this.db.objectStoreNames.contains('cache')) {
          const objectStore = this.db.createObjectStore('cache', { keyPath: 'id' });
          objectStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async put(key, value) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      
      const data = {
        id: key,
        value: value,
        timestamp: Date.now()
      };
      
      const request = store.put(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async get(key) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readonly');
      const store = transaction.objectStore('cache');
      
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result?.value || null);
      request.onerror = () => reject(request.error);
    });
  }
}
```

### 3. Service Worker缓存实现

```javascript
// service-worker.js
const CACHE_NAME = 'static-cache-v1';
const DYNAMIC_CACHE_NAME = 'dynamic-cache-v1';
const STATIC_ASSETS = [
  '/',
  '/css/style.css',
  '/js/app.js',
  '/images/logo.png'
];

// 安装阶段：缓存静态资源
self.addEventListener('install', event => {
  console.log('Service Worker 安装中...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('缓存静态资源');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('Service Worker 安装完成');
        return self.skipWaiting(); // 立即激活
      })
  );
});

// 激活阶段：清理旧缓存
self.addEventListener('activate', event => {
  console.log('Service Worker 激活中...');
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME && cacheName !== DYNAMIC_CACHE_NAME) {
            console.log('删除旧缓存:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// 网络请求拦截：实现缓存策略
self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);
  
  // 静态资源：优先从缓存获取，失败后请求网络
  if (isStaticAsset(url)) {
    event.respondWith(
      caches.match(request)
        .then(response => {
          return response || fetch(request);
        })
    );
  } 
  // 动态数据：网络优先，失败后使用缓存
  else {
    event.respondWith(
      caches.open(DYNAMIC_CACHE_NAME)
        .then(cache => {
          return fetch(request)
            .then(networkResponse => {
              // 更新缓存
              cache.put(request, networkResponse.clone());
              return networkResponse;
            })
            .catch(() => {
              // 网络请求失败，返回缓存
              return cache.match(request);
            });
        })
    );
  }
});

function isStaticAsset(url) {
  return STATIC_ASSETS.some(asset => url.pathname.includes(asset));
}

// 缓存更新策略
function updateCache(url, data) {
  return caches.open(DYNAMIC_CACHE_NAME)
    .then(cache => {
      return cache.put(new Request(url), new Response(JSON.stringify(data)));
    });
}
```

### 4. 缓存策略实现

```javascript
// 缓存策略管理器
class CacheStrategy {
  constructor() {
    this.strategies = {
      // 缓存优先
      cacheFirst: async (request, cacheName) => {
        const cache = await caches.open(cacheName);
        const cachedResponse = await cache.match(request);
        
        if (cachedResponse) {
          return cachedResponse;
        }
        
        const networkResponse = await fetch(request);
        cache.put(request, networkResponse.clone());
        return networkResponse;
      },
      
      // 网络优先
      networkFirst: async (request, cacheName) => {
        try {
          const networkResponse = await fetch(request);
          const cache = await caches.open(cacheName);
          cache.put(request, networkResponse.clone());
          return networkResponse;
        } catch (error) {
          const cache = await caches.open(cacheName);
          return await cache.match(request);
        }
      },
      
      // 仅缓存
      cacheOnly: async (request, cacheName) => {
        const cache = await caches.open(cacheName);
        return await cache.match(request);
      },
      
      // 仅网络
      networkOnly: async (request) => {
        return await fetch(request);
      },
      
      // 缓存和网络并行
      staleWhileRevalidate: async (request, cacheName) => {
        const cache = await caches.open(cacheName);
        const cachedResponse = await cache.match(request);
        
        // 同时发起网络请求并更新缓存
        const networkPromise = fetch(request)
          .then(networkResponse => {
            cache.put(request, networkResponse.clone());
            return networkResponse;
          });
        
        // 优先返回缓存（如果存在），否则等待网络响应
        return cachedResponse || networkPromise;
      }
    };
  }
  
  async execute(strategyName, request, cacheName) {
    const strategy = this.strategies[strategyName];
    if (!strategy) {
      throw new Error(`未知缓存策略: ${strategyName}`);
    }
    return await strategy(request, cacheName);
  }
}

// 使用示例
const cacheStrategy = new CacheStrategy();

// 对于静态资源使用缓存优先
const staticResource = await cacheStrategy.execute(
  'cacheFirst', 
  new Request('/css/style.css'), 
  'static-cache'
);

// 对于API数据使用网络优先
const apiData = await cacheStrategy.execute(
  'networkFirst', 
  new Request('/api/user'), 
  'api-cache'
);
```

## 实践场景

### 1. PWA应用缓存
- 实现离线访问能力
- 使用Cache API和IndexedDB存储数据
- 通过Service Worker管理缓存策略

### 2. 前端性能优化
- 合理设置HTTP缓存头
- 实现静态资源版本控制
- 使用CDN缓存加速

### 3. 移动端缓存策略
- 考虑存储空间限制
- 实现智能缓存清理
- 优化缓存命中率

### 4. 安全考虑
- 避免在客户端存储敏感信息
- 实现缓存数据加密
- 防止缓存污染攻击
