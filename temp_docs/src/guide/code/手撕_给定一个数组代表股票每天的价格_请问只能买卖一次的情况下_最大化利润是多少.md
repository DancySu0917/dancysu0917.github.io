# 手撕：给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？（了解）

**题目**: 手撕：给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？（了解）

**答案**:

这是一个经典的动态规划问题，也被称为"买卖股票的最佳时机"问题。我们需要在给定的股票价格数组中找到一次买入和一次卖出的最佳时机，以获得最大利润。

## 问题分析

- 只能进行一次买卖操作（先买后卖）
- 必须先买入再卖出（买入日期必须在卖出日期之前）
- 目标是最大化利润（卖出价格 - 买入价格）
- 如果无法获得利润，则返回0

## 解决方案

### 方法一：暴力解法（时间复杂度 O(n²)）

```javascript
function maxProfitBruteForce(prices) {
  if (!prices || prices.length < 2) {
    return 0;
  }
  
  let maxProfit = 0;
  
  // 遍历每一天作为买入日
  for (let i = 0; i < prices.length - 1; i++) {
    // 遍历买入日之后的每一天作为卖出日
    for (let j = i + 1; j < prices.length; j++) {
      const profit = prices[j] - prices[i];
      maxProfit = Math.max(maxProfit, profit);
    }
  }
  
  return maxProfit;
}

// 测试
console.log(maxProfitBruteForce([7, 1, 5, 3, 6, 4])); // 输出: 5 (在价格为1时买入，在价格为6时卖出)
console.log(maxProfitBruteForce([7, 6, 4, 3, 1]));    // 输出: 0 (价格持续下跌，无法获利)
```

### 方法二：一次遍历解法（时间复杂度 O(n)）- 最优解

```javascript
function maxProfit(prices) {
  if (!prices || prices.length < 2) {
    return 0;
  }
  
  let minPrice = prices[0];  // 记录到目前为止的最低价格
  let maxProfit = 0;         // 记录到目前为止的最大利润
  
  // 从第二天开始遍历
  for (let i = 1; i < prices.length; i++) {
    // 如果当前价格比之前记录的最低价格还低，则更新最低价格
    if (prices[i] < minPrice) {
      minPrice = prices[i];
    } else {
      // 否则计算当前价格卖出能获得的利润，并更新最大利润
      const currentProfit = prices[i] - minPrice;
      maxProfit = Math.max(maxProfit, currentProfit);
    }
  }
  
  return maxProfit;
}

// 测试
console.log(maxProfit([7, 1, 5, 3, 6, 4])); // 输出: 5
console.log(maxProfit([7, 6, 4, 3, 1]));    // 输出: 0
console.log(maxProfit([1, 2, 3, 4, 5]));    // 输出: 4
```

### 方法三：动态规划思想

```javascript
function maxProfitDP(prices) {
  if (!prices || prices.length < 2) {
    return 0;
  }
  
  // 状态定义：
  // hold: 当前持有股票的最大收益
  // sold: 当前不持有股票的最大收益
  let hold = -prices[0];  // 第一天买入股票的收益
  let sold = 0;           // 第一天不持有股票的收益
  
  for (let i = 1; i < prices.length; i++) {
    // 更新状态
    const newHold = Math.max(hold, -prices[i]);  // 继续持有或新买入
    const newSold = Math.max(sold, hold + prices[i]);  // 继续不持有或卖出
    
    hold = newHold;
    sold = newSold;
  }
  
  return sold;  // 最终不持有股票时的收益即为最大利润
}
```

### 方法四：通用解法（扩展到K次交易）

```javascript
function maxProfitKTransactions(prices, k = 1) {
  if (!prices || prices.length < 2 || k <= 0) {
    return 0;
  }
  
  const n = prices.length;
  
  // 如果k大于天数的一半，相当于可以无限交易
  if (k >= n / 2) {
    let maxProfit = 0;
    for (let i = 1; i < n; i++) {
      if (prices[i] > prices[i - 1]) {
        maxProfit += prices[i] - prices[i - 1];
      }
    }
    return maxProfit;
  }
  
  // dp[i][j][0] 表示第i天，进行了j次交易，不持有股票的最大利润
  // dp[i][j][1] 表示第i天，进行了j次交易，持有股票的最大利润
  const dp = Array(n).fill(0).map(() => 
    Array(k + 1).fill(0).map(() => [0, 0])
  );
  
  // 初始化第一天的状态
  for (let j = 1; j <= k; j++) {
    dp[0][j][0] = 0;
    dp[0][j][1] = -prices[0];
  }
  
  for (let i = 1; i < n; i++) {
    for (let j = 1; j <= k; j++) {
      // 不持有股票：保持不持有或卖出
      dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);
      // 持有股票：保持持有或买入
      dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]);
    }
  }
  
  return dp[n-1][k][0];
}

// 对于本题，k=1
function maxProfitSpecific(prices) {
  return maxProfitKTransactions(prices, 1);
}
```

## 算法优化思路

1. **空间优化**: 在一次交易的情况下，我们只需要记录到目前为止的最小价格和最大利润，空间复杂度为O(1)

2. **时间优化**: 通过一次遍历解决问题，时间复杂度为O(n)

## 完整测试用例

```javascript
function testMaxProfit() {
  const testCases = [
    { input: [7, 1, 5, 3, 6, 4], expected: 5 },
    { input: [7, 6, 4, 3, 1], expected: 0 },
    { input: [1, 2, 3, 4, 5], expected: 4 },
    { input: [2, 4, 1], expected: 2 },
    { input: [1], expected: 0 },
    { input: [], expected: 0 },
    { input: [2, 1, 2, 0, 1], expected: 1 }
  ];
  
  testCases.forEach((testCase, index) => {
    const result = maxProfit(testCase.input);
    console.log(`测试用例 ${index + 1}: 输入=[${testCase.input}], 期望=${testCase.expected}, 实际=${result}, ${result === testCase.expected ? '通过' : '失败'}`);
  });
}

testMaxProfit();
```

## 复杂度分析

- 时间复杂度: O(n)，其中n是价格数组的长度，只需要遍历一次数组
- 空间复杂度: O(1)，只使用了常数级别的额外空间

## 关键点总结

1. 问题的核心是找到买入的最低价格和对应的最高卖出价格
2. 买入日期必须在卖出日期之前
3. 使用"一次遍历 + 维护最小值"的方法是最优解
4. 当前利润 = 当前价格 - 到目前为止的最低价格
5. 最大利润 = max(之前的最大利润, 当前利润)

这个问题在面试中经常出现，理解其核心思想有助于解决更复杂的股票交易问题（如多次交易、手续费等变种）。