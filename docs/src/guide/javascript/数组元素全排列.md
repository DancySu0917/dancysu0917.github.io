# 数组元素全排列？（了解）

**题目**: 数组元素全排列？（了解）

## 解题思路

数组元素全排列是经典的回溯算法问题。给定一个数组，需要生成其所有可能的排列组合。例如，[1,2,3]的全排列为[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]。

## 解决方案

### 方法一：回溯算法（推荐）

```javascript
function permute(nums) {
    const result = [];
    const path = [];
    const used = new Array(nums.length).fill(false);
    
    function backtrack() {
        // 递归终止条件：路径长度等于数组长度
        if (path.length === nums.length) {
            result.push([...path]); // 注意：需要复制当前路径
            return;
        }
        
        // 遍历所有可能的选择
        for (let i = 0; i < nums.length; i++) {
            // 如果当前元素已经被使用过，则跳过
            if (used[i]) {
                continue;
            }
            
            // 做选择
            path.push(nums[i]);
            used[i] = true;
            
            // 递归
            backtrack();
            
            // 撤销选择（回溯）
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack();
    return result;
}

// 测试示例
console.log(permute([1, 2, 3]));
// 输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 方法二：回溯算法（处理重复元素）

如果数组中有重复元素，需要去重：

```javascript
function permuteUnique(nums) {
    const result = [];
    const path = [];
    const used = new Array(nums.length).fill(false);
    
    // 先排序，便于去重
    nums.sort((a, b) => a - b);
    
    function backtrack() {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        
        for (let i = 0; i < nums.length; i++) {
            // 如果当前元素已被使用
            if (used[i]) {
                continue;
            }
            
            // 去重逻辑：如果当前元素与前一个元素相同，且前一个元素未被使用，则跳过
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
                continue;
            }
            
            path.push(nums[i]);
            used[i] = true;
            
            backtrack();
            
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack();
    return result;
}

// 测试示例（包含重复元素）
console.log(permuteUnique([1, 1, 2]));
// 输出: [[1,1,2],[1,2,1],[2,1,1]]
```

### 方法三：交换元素实现全排列

```javascript
function permuteBySwap(nums) {
    const result = [];
    const arr = [...nums]; // 创建副本，避免修改原数组
    
    function backtrack(start) {
        // 递归终止条件
        if (start === arr.length) {
            result.push([...arr]);
            return;
        }
        
        // 从start位置开始，尝试与每个位置交换
        for (let i = start; i < arr.length; i++) {
            // 交换
            [arr[start], arr[i]] = [arr[i], arr[start]];
            
            // 递归处理下一个位置
            backtrack(start + 1);
            
            // 回溯，恢复交换
            [arr[start], arr[i]] = [arr[i], arr[start]];
        }
    }
    
    backtrack(0);
    return result;
}

// 测试示例
console.log(permuteBySwap([1, 2, 3]));
```

### 方法四：使用内置方法（仅作参考）

```javascript
// JavaScript没有内置的全排列方法，但可以这样实现
function permuteIterative(nums) {
    if (nums.length <= 1) return [nums];
    
    const result = [];
    for (let i = 0; i < nums.length; i++) {
        const rest = [...nums.slice(0, i), ...nums.slice(i + 1)];
        const restPermute = permuteIterative(rest);
        
        for (const perm of restPermute) {
            result.push([nums[i], ...perm]);
        }
    }
    
    return result;
}
```

## 复杂度分析

- 时间复杂度：O(n! × n)，其中n是数组长度
  - 共有n!个排列
  - 每个排列需要O(n)时间复制到结果中
- 空间复杂度：O(n)，递归调用栈的深度为n

## 关键点总结

1. 全排列是回溯算法的经典应用
2. 需要使用used数组标记元素是否已被使用
3. 注意回溯时要撤销选择（恢复状态）
4. 当数组包含重复元素时，需要去重处理
5. 有多种实现方式，回溯法是最直观和常用的方法
6. 空间复杂度主要由递归调用栈决定
