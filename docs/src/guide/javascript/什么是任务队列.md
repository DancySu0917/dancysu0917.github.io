# 什么是任务队列？（了解）

**题目**: 什么是任务队列？（了解）

## 标准答案

任务队列（Task Queue）是JavaScript事件循环机制中的一个重要概念，用于存储待执行的回调函数。任务队列分为宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue），它们按照特定的执行顺序被事件循环处理。

## 深入理解

### 1. 任务队列的基本概念

任务队列是先进先出（FIFO）的数据结构，用于存放待执行的回调函数。JavaScript引擎通过事件循环机制不断检查调用栈是否为空，如果为空则从任务队列中取出一个任务执行。

```javascript
// 任务队列示例
console.log('1');

setTimeout(() => {
    console.log('2');  // 宏任务
}, 0);

Promise.resolve().then(() => {
    console.log('3');  // 微任务
});

console.log('4');

// 执行顺序：1, 4, 3, 2
```

### 2. 宏任务（Macro Task）与微任务（Micro Task）

#### 宏任务（Macro Task）
宏任务包括：
- setTimeout/setInterval
- setImmediate (Node.js)
- requestAnimationFrame (浏览器)
- I/O操作
- UI渲染

```javascript
// 宏任务示例
setTimeout(() => {
    console.log('宏任务1');
}, 0);

setTimeout(() => {
    console.log('宏任务2');
}, 0);

setImmediate(() => {  // Node.js环境
    console.log('宏任务3');
}, 0);

console.log('同步代码');

// 输出顺序：同步代码，然后是宏任务（顺序可能因环境而异）
```

#### 微任务（Micro Task）
微任务包括：
- Promise.then/catch/finally
- queueMicrotask
- MutationObserver (浏览器)

```javascript
// 微任务示例
Promise.resolve().then(() => {
    console.log('微任务1');
});

Promise.resolve().then(() => {
    console.log('微任务2');
});

queueMicrotask(() => {
    console.log('微任务3');
});

console.log('同步代码');

// 输出顺序：同步代码，微任务1，微任务2，微任务3
```

### 3. 事件循环执行顺序

事件循环的执行顺序如下：
1. 执行所有同步代码
2. 执行所有微任务（微任务队列清空）
3. 执行一个宏任务
4. 检查并执行所有微任务
5. 执行下一个宏任务
6. 重复步骤3-5

```javascript
// 详细展示事件循环执行顺序
console.log('1');

setTimeout(() => {
    console.log('2');
    Promise.resolve().then(() => {
        console.log('3');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('4');
});

setTimeout(() => {
    console.log('5');
    Promise.resolve().then(() => {
        console.log('6');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('7');
});

console.log('8');

// 输出顺序：1, 8, 4, 7, 2, 3, 5, 6
```

### 4. 实现一个简单的任务队列

```javascript
// 简单的任务队列实现
class TaskQueue {
    constructor() {
        this.microTaskQueue = [];
        this.isMicroTaskRunning = false;
    }

    // 添加微任务
    addMicroTask(task) {
        this.microTaskQueue.push(task);
        
        if (!this.isMicroTaskRunning) {
            this.isMicroTaskRunning = true;
            this.runMicroTasks();
        }
    }

    // 执行微任务队列
    runMicroTasks() {
        if (this.microTaskQueue.length === 0) {
            this.isMicroTaskRunning = false;
            return;
        }

        const task = this.microTaskQueue.shift();
        
        try {
            task();
        } catch (error) {
            console.error('微任务执行错误:', error);
        }

        // 使用queueMicrotask确保在当前任务完成后继续执行
        queueMicrotask(() => {
            this.runMicroTasks();
        });
    }

    // 添加宏任务（通过setTimeout模拟）
    addMacroTask(task, delay = 0) {
        setTimeout(task, delay);
    }
}

// 使用示例
const taskQueue = new TaskQueue();

console.log('开始');

taskQueue.addMicroTask(() => {
    console.log('微任务1');
});

taskQueue.addMicroTask(() => {
    console.log('微任务2');
});

taskQueue.addMacroTask(() => {
    console.log('宏任务1');
});

console.log('结束');

// 输出：开始，结束，微任务1，微任务2，宏任务1
```

### 5. 任务队列在实际开发中的应用

#### 异步操作的执行顺序管理
```javascript
// 实际开发中管理异步操作顺序
function asyncOperation1() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log('异步操作1完成');
            resolve('结果1');
        }, 100);
    });
}

function asyncOperation2() {
    return Promise.resolve().then(() => {
        console.log('异步操作2完成');
        return '结果2';
    });
}

asyncOperation1();
asyncOperation2();

console.log('主流程完成');

// 输出：主流程完成，异步操作2完成，异步操作1完成
```

#### 避免长时间运行的同步代码阻塞
```javascript
// 使用任务队列避免阻塞
function heavySyncTask() {
    // 模拟耗时的同步操作
    for (let i = 0; i < 1000000; i++) {
        // 一些计算
    }
    console.log('重同步任务完成');
}

function heavyAsyncTask() {
    // 将重任务分解为多个微任务
    return new Promise(resolve => {
        let count = 0;
        const chunkSize = 10000;

        function processChunk() {
            const end = Math.min(count + chunkSize, 1000000);
            for (; count < end; count++) {
                // 一些计算
            }

            if (count < 1000000) {
                // 让出控制权，允许其他任务执行
                queueMicrotask(processChunk);
            } else {
                console.log('重异步任务完成');
                resolve();
            }
        }

        processChunk();
    });
}

heavySyncTask();  // 会阻塞其他任务
heavyAsyncTask(); // 不会阻塞其他任务

console.log('其他任务');

// 输出：重同步任务完成，其他任务，重异步任务完成
```

### 6. 任务队列的性能优化

```javascript
// 使用任务队列优化性能
class PerformanceOptimizer {
    constructor() {
        this.taskQueue = [];
        this.isRunning = false;
    }

    // 添加任务到队列
    addTask(task) {
        this.taskQueue.push(task);
        if (!this.isRunning) {
            this.runTasks();
        }
    }

    // 批量执行任务，避免频繁的UI更新
    async runTasks() {
        this.isRunning = true;

        while (this.taskQueue.length > 0) {
            const tasks = this.taskQueue.splice(0, 10); // 每次处理10个任务
            
            for (const task of tasks) {
                await new Promise(resolve => {
                    queueMicrotask(() => {
                        try {
                            task();
                        } finally {
                            resolve();
                        }
                    });
                });
            }

            // 让出控制权，允许浏览器渲染
            await new Promise(resolve => setTimeout(resolve, 0));
        }

        this.isRunning = false;
    }
}

// 使用示例
const optimizer = new PerformanceOptimizer();

for (let i = 0; i < 100; i++) {
    optimizer.addTask(() => {
        console.log(`执行任务 ${i}`);
    });
}
```

## 总结

任务队列是JavaScript异步执行机制的核心组成部分：
- 宏任务和微任务有不同的优先级，微任务优先于宏任务执行
- 事件循环按照"执行同步代码 → 执行所有微任务 → 执行一个宏任务 → 执行所有微任务..."的顺序运行
- 理解任务队列有助于编写高效的异步代码，避免性能问题
- 在实际开发中，合理利用任务队列可以优化应用性能，避免长时间阻塞主线程
