# 判断一个对象是否为空，包含了其原型链上是否有自定义数据或方法。该如何判定（了解）

**题目**: 判断一个对象是否为空，包含了其原型链上是否有自定义数据或方法。该如何判定（了解）

## 标准答案

判断一个对象是否为空（包括原型链上的自定义数据或方法）需要区分两种情况：

1. **仅检查对象自身属性**：使用 `Object.keys()`、`Object.getOwnPropertyNames()` 等
2. **检查包括原型链上的属性**：需要遍历整个原型链

## 深入解析

### 检查对象自身属性

```javascript
// 仅检查对象自身属性（不包括原型链）
function isEmptyOwnProperties(obj) {
    // 检查是否为对象
    if (obj === null || obj === undefined || typeof obj !== 'object') {
        return true;
    }
    
    // 方法1: 使用 Object.keys()
    return Object.keys(obj).length === 0;
}

// 更全面的检查对象自身属性
function hasOwnProperties(obj) {
    if (obj === null || typeof obj !== 'object') {
        return false;
    }
    
    // 检查所有自身属性（包括不可枚举的）
    return Object.getOwnPropertyNames(obj).length === 0;
}

// 检查自身可枚举属性
function hasEnumerableOwnProperties(obj) {
    if (obj === null || typeof obj !== 'object') {
        return false;
    }
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false; // 发现自身属性，返回 false（表示不是空的）
        }
    }
    return true; // 没有发现自身属性，返回 true（表示是空的）
}
```

### 检查包括原型链上的属性

```javascript
// 检查对象及其原型链上是否有自定义数据或方法
function isEmptyIncludingPrototype(obj) {
    if (obj === null || obj === undefined || typeof obj !== 'object') {
        return true;
    }
    
    // 检查对象自身属性
    if (Object.keys(obj).length > 0) {
        return false;
    }
    
    // 检查原型链上的自定义属性
    let current = obj;
    while (current !== null) {
        const ownProps = Object.getOwnPropertyNames(current);
        // 过滤掉默认的原型属性（如 constructor）
        const customProps = ownProps.filter(prop => 
            prop !== 'constructor' && 
            obj.hasOwnProperty(prop) === false // 不是自身属性
        );
        
        if (customProps.length > 0) {
            return false;
        }
        
        current = Object.getPrototypeOf(current);
    }
    
    return true;
}

// 更精确的原型链检查
function hasCustomPrototypeProperties(obj) {
    if (obj === null || typeof obj !== 'object') {
        return false;
    }
    
    // 获取对象的原型链
    const protoChain = [];
    let current = obj;
    
    while (current !== null) {
        protoChain.push(current);
        current = Object.getPrototypeOf(current);
    }
    
    // 检查原型链上是否有自定义属性
    for (let i = 1; i < protoChain.length; i++) { // 从1开始，跳过对象自身
        const props = Object.getOwnPropertyNames(protoChain[i]);
        // 过滤掉默认属性
        const customProps = props.filter(prop => 
            !['constructor', 'toString', 'valueOf', 'hasOwnProperty', 
              'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString'].includes(prop)
        );
        
        if (customProps.length > 0) {
            return true;
        }
    }
    
    return false;
}
```

### 综合判断函数

```javascript
// 综合判断函数，可选择是否检查原型链
function isEmpty(obj, includePrototype = false) {
    if (obj === null || obj === undefined) {
        return true;
    }
    
    if (typeof obj !== 'object') {
        return false; // 原始类型不被认为是"空对象"
    }
    
    // 检查自身属性
    if (Object.keys(obj).length > 0) {
        return false;
    }
    
    if (!includePrototype) {
        return true; // 只检查自身属性，没有则返回 true
    }
    
    // 检查原型链
    let current = obj;
    while (current !== null) {
        const allProps = Object.getOwnPropertyNames(current);
        
        // 检查当前原型上是否有自定义属性（排除构造函数）
        for (const prop of allProps) {
            // 如果不是 Object.prototype 的默认方法，则认为是自定义属性
            if (!isDefaultObjectProperty(prop, current)) {
                // 如果是对象自身的属性，已经在前面检查过了
                if (current !== obj || !obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
        }
        
        current = Object.getPrototypeOf(current);
        
        // 避免无限循环（到达 Object.prototype 时停止）
        if (current === Object.prototype) {
            break;
        }
    }
    
    return true;
}

// 判断是否为 Object 的默认属性
function isDefaultObjectProperty(prop, obj) {
    // 常见的 Object 原型方法
    const defaultProps = [
        'constructor', 'toString', 'toLocaleString', 'valueOf',
        'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
        '__defineGetter__', '__defineSetter__', '__lookupGetter__',
        '__lookupSetter__', 'isPrototypeOf', 'propertyIsEnumerable'
    ];
    
    return defaultProps.includes(prop) && 
           Object.prototype.hasOwnProperty.call(Object.prototype, prop);
}
```

### 实际应用示例

```javascript
// 测试用例
function testEmptyCheck() {
    // 空对象
    const emptyObj = {};
    console.log(isEmpty(emptyObj)); // true
    console.log(isEmpty(emptyObj, true)); // true
    
    // 有自身属性的对象
    const objWithProps = { a: 1 };
    console.log(isEmpty(objWithProps)); // false
    console.log(isEmpty(objWithProps, true)); // false
    
    // 扩展原型的对象
    function Parent() {}
    Parent.prototype.parentMethod = function() {};
    
    const child = new Parent();
    console.log(isEmpty(child)); // true (自身没有属性)
    console.log(isEmpty(child, true)); // false (原型链上有自定义方法)
    
    // 使用 Object.create 创建的对象
    const objWithPrototype = Object.create({ customMethod: () => {} });
    console.log(isEmpty(objWithPrototype)); // true (自身没有属性)
    console.log(isEmpty(objWithPrototype, true)); // false (原型上有自定义方法)
    
    // 普通对象扩展
    const normalObj = {};
    normalObj.__proto__.customProp = 'test';
    console.log(isEmpty(normalObj)); // true (自身没有属性)
    console.log(isEmpty(normalObj, true)); // false (原型上有自定义属性)
}

// 实用的工具函数
const ObjectUtils = {
    // 检查对象是否为空（仅自身属性）
    isEmpty(obj) {
        if (obj === null || obj === undefined) return true;
        if (typeof obj !== 'object') return false;
        return Object.keys(obj).length === 0;
    },
    
    // 检查对象是否有任何属性（包括原型链）
    isEmptyWithPrototype(obj) {
        if (obj === null || obj === undefined) return true;
        if (typeof obj !== 'object') return false;
        
        // 检查自身属性
        if (Object.keys(obj).length > 0) return false;
        
        // 检查原型链
        let current = obj;
        while (current !== null) {
            const props = Object.getOwnPropertyNames(current);
            if (props.length > 1 || (props.length === 1 && props[0] !== 'constructor')) {
                return false;
            }
            current = Object.getPrototypeOf(current);
        }
        
        return true;
    },
    
    // 获取对象所有属性（包括原型链）
    getAllProperties(obj) {
        const props = new Set();
        let current = obj;
        
        while (current !== null) {
            Object.getOwnPropertyNames(current).forEach(prop => props.add(prop));
            current = Object.getPrototypeOf(current);
        }
        
        return Array.from(props);
    }
};
```

## 实际面试问答

**面试官**: 如何判断一个对象是否为空，包括其原型链？

**候选人**: 
需要分情况讨论：
1. **仅检查自身属性**：使用 `Object.keys(obj).length === 0`
2. **包括原型链**：需要遍历原型链，检查每个原型对象是否有自定义属性

关键是要区分默认的 Object 原型方法和真正的自定义属性。

**面试官**: 为什么需要区分默认原型方法和自定义属性？

**候选人**: 
因为所有对象都继承自 Object.prototype，具有 toString、hasOwnProperty 等默认方法。如果不区分，任何对象都会被认为"不为空"，这不符合实际需求。我们需要识别的是开发者真正添加到原型链上的自定义数据或方法。

**面试官**: 如何高效地遍历原型链？

**候选人**: 
使用 `Object.getPrototypeOf()` 方法可以获取对象的原型，然后循环遍历直到原型为 null。需要注意避免无限循环，通常在到达 Object.prototype 时停止。
