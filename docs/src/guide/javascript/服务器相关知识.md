# 服务器相关知识？（高薪常问）

**题目**: 服务器相关知识？（高薪常问）

## 标准答案

服务器相关知识包括：1) 服务器基础概念：物理/虚拟服务器、负载均衡、CDN；2) Web服务器：Nginx、Apache配置与优化；3) 服务器安全：SSL证书、防火墙、访问控制；4) 性能优化：缓存策略、压缩、资源优化；5) 部署运维：Docker容器化、CI/CD流程、监控告警。前端开发者需要了解服务器工作原理以实现前后端协作和性能优化。

## 详细解析

### 服务器基础概念

服务器是为客户端提供服务的计算机程序或设备，主要功能包括：
- 处理客户端请求
- 提供数据或服务
- 管理资源分配
- 维护系统安全

#### 服务器类型
```javascript
// 服务器架构示例
class ServerArchitecture {
    constructor() {
        this.types = {
            // 物理服务器 - 硬件层面
            physical: {
                description: '独立的物理硬件',
                advantages: ['性能稳定', '安全性高', '完全控制'],
                disadvantages: ['成本高', '维护复杂', '扩展性差']
            },
            
            // 虚拟服务器 - 虚拟化技术
            virtual: {
                description: '通过虚拟化技术创建的服务器',
                advantages: ['成本效益', '易于扩展', '灵活部署'],
                disadvantages: ['性能开销', '依赖宿主机', '资源竞争']
            },
            
            // 云服务器 - 云服务提供商
            cloud: {
                description: '基于云计算的虚拟服务器',
                advantages: ['按需付费', '弹性扩展', '全球部署'],
                disadvantages: ['厂商依赖', '网络延迟', '安全顾虑']
            }
        };
    }
}
```

### Web服务器配置与管理

#### Nginx配置
```nginx
# Nginx配置示例
server {
    listen 80;
    server_name example.com www.example.com;
    
    # 静态资源处理
    location /static/ {
        alias /var/www/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # API请求代理
    location /api/ {
        proxy_pass http://backend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
    # 前端路由支持
    location / {
        root /var/www/html;
        try_files $uri $uri/ /index.html;
    }
    
    # 安全头设置
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
}
```

#### Apache配置
```apache
# Apache虚拟主机配置
<VirtualHost *:80>
    ServerName example.com
    DocumentRoot /var/www/html
    
    # 重写规则
    RewriteEngine On
    RewriteCond %{HTTPS} off
    RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]
    
    # 自定义错误页面
    ErrorDocument 404 /404.html
    ErrorDocument 500 /500.html
    
    # 安全设置
    <Directory "/var/www/html">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
```

### 服务器安全配置

#### SSL/TLS配置
```javascript
// HTTPS服务器配置示例
const https = require('https');
const fs = require('fs');

const options = {
    key: fs.readFileSync('/path/to/private-key.pem'),
    cert: fs.readFileSync('/path/to/certificate.pem'),
    ca: fs.readFileSync('/path/to/ca-cert.pem'), // 可选
    // 安全的TLS配置
    minVersion: 'TLSv1.2',
    ciphers: [
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-RSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES256-SHA384',
        'ECDHE-RSA-AES128-SHA256'
    ].join(':'),
    honorCipherOrder: true
};

const server = https.createServer(options, (req, res) => {
    res.writeHead(200);
    res.end('Secure connection established!');
});

server.listen(443);
```

#### 安全头配置
```javascript
// Express.js安全中间件配置
const express = require('express');
const helmet = require('helmet');

const app = express();

// 使用helmet设置安全头
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000, // 一年
        includeSubDomains: true,
        preload: true
    },
    frameguard: {
        action: 'deny'
    }
}));

// 自定义安全头
app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Download-Options', 'noopen');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
    next();
});
```

### 性能优化策略

#### 缓存配置
```javascript
// 缓存策略实现
class CacheManager {
    constructor() {
        this.cache = new Map();
        this.ttl = new Map(); // 存储过期时间
    }
    
    // 设置缓存项
    set(key, value, ttl = 300000) { // 默认5分钟
        this.cache.set(key, value);
        this.ttl.set(key, Date.now() + ttl);
    }
    
    // 获取缓存项
    get(key) {
        const expired = this.ttl.get(key) < Date.now();
        if (expired) {
            this.cache.delete(key);
            this.ttl.delete(key);
            return null;
        }
        return this.cache.get(key);
    }
    
    // 清理过期缓存
    cleanup() {
        for (const [key, expiry] of this.ttl.entries()) {
            if (expiry < Date.now()) {
                this.cache.delete(key);
                this.ttl.delete(key);
            }
        }
    }
}

// HTTP缓存头配置
app.use((req, res, next) => {
    // 静态资源缓存
    if (req.path.startsWith('/static/')) {
        res.setHeader('Cache-Control', 'public, max-age=31536000'); // 1年
        res.setHeader('Expires', new Date(Date.now() + 31536000000).toUTCString());
    }
    
    // API响应缓存
    if (req.path.startsWith('/api/')) {
        res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    }
    
    next();
});
```

#### 压缩优化
```javascript
// 启用Gzip压缩
const compression = require('compression');
app.use(compression({
    // 只压缩文本类型
    filter: (req, res) => {
        if (req.headers['x-no-compression']) {
            return false;
        }
        return compression.filter(req, res);
    },
    level: 6, // 压缩级别
    threshold: 1024 // 超过1KB才压缩
}));

// Brotli压缩（更高效的压缩算法）
const express = require('express');
const app = express();

// 使用brotli中间件
app.use((req, res, next) => {
    const acceptEncoding = req.headers['accept-encoding'];
    
    if (!acceptEncoding || !acceptEncoding.includes('br')) {
        return next();
    }
    
    const fs = require('fs');
    const zlib = require('zlib');
    
    // 设置响应头
    res.setHeader('Content-Encoding', 'br');
    res.removeHeader('Content-Length');
    
    // 创建brotli压缩流
    const brotli = zlib.createBrotliCompress({
        params: {
            [zlib.constants.BROTLI_PARAM_QUALITY]: 4,
            [zlib.constants.BROTLI_PARAM_SIZE_HINT]: 1024
        }
    });
    
    res = res.pipe(brotli);
    next();
});
```

### 部署与运维

#### Docker容器化
```dockerfile
# Dockerfile示例
FROM node:16-alpine

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 更改文件所有权
RUN chown -R nextjs:nodejs /app
USER nextjs

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml示例
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
    depends_on:
      - db
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  db:
    image: postgres:14
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
```

#### CI/CD配置示例
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm test
    
    - name: Run linting
      run: npm run lint

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build
      run: npm run build
    
    - name: Deploy to server
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.KEY }}
        script: |
          cd /var/www/myapp
          git pull origin main
          npm install
          npm run build
          pm2 reload myapp
```

### 监控与日志

#### 服务器监控
```javascript
// 服务器监控工具
class ServerMonitor {
    constructor() {
        this.metrics = {
            cpu: { usage: 0, history: [] },
            memory: { usage: 0, total: 0, available: 0 },
            disk: { usage: 0, total: 0, available: 0 },
            network: { in: 0, out: 0 },
            requests: { count: 0, errors: 0, avgTime: 0 }
        };
        
        this.collectInterval = null;
    }
    
    startMonitoring() {
        this.collectInterval = setInterval(() => {
            this.collectMetrics();
            this.reportMetrics();
        }, 5000); // 每5秒收集一次
    }
    
    collectMetrics() {
        const os = require('os');
        
        // CPU使用率
        const cpus = os.cpus();
        const cpuUsage = cpus.reduce((acc, cpu) => acc + cpu.times.user + cpu.times.nice + cpu.times.sys, 0) / 
                        (cpus.length * 1000); // 简化的CPU使用率计算
        
        this.metrics.cpu.usage = cpuUsage;
        this.metrics.cpu.history.push({ time: Date.now(), usage: cpuUsage });
        
        // 内存使用情况
        this.metrics.memory = {
            total: os.totalmem(),
            available: os.freemem(),
            usage: (os.totalmem() - os.freemem()) / os.totalmem()
        };
        
        // 磁盘使用情况（简化）
        this.metrics.disk = {
            total: 100000000000, // 示例值
            available: 50000000000, // 示例值
            usage: 0.5 // 50%
        };
    }
    
    reportMetrics() {
        // 发送到监控服务
        console.log('Server Metrics:', this.metrics);
        
        // 检查阈值并告警
        if (this.metrics.cpu.usage > 0.8) {
            this.sendAlert('High CPU usage detected', 'warning');
        }
        
        if (this.metrics.memory.usage > 0.9) {
            this.sendAlert('High memory usage detected', 'critical');
        }
    }
    
    sendAlert(message, level) {
        console.log(`[${level.toUpperCase()}] ${message}`);
        // 实际应用中，这里会发送到告警系统
    }
    
    stopMonitoring() {
        if (this.collectInterval) {
            clearInterval(this.collectInterval);
        }
    }
}

// 使用示例
const monitor = new ServerMonitor();
monitor.startMonitoring();
```

### 实际应用场景

1. **Web应用部署**：配置Nginx反向代理，处理静态资源和API请求
2. **性能优化**：实现缓存策略，启用压缩，优化资源加载
3. **安全加固**：配置SSL证书，设置安全头，限制访问权限
4. **容器化部署**：使用Docker进行应用打包和部署
5. **持续集成**：自动化测试、构建和部署流程

### 注意事项

1. **安全性**：定期更新系统和软件，配置防火墙，使用安全协议
2. **备份策略**：定期备份数据，测试恢复流程
3. **性能监控**：持续监控服务器性能，及时发现和解决问题
4. **容量规划**：根据业务增长预估资源需求
5. **日志管理**：合理配置日志级别，定期清理日志文件
