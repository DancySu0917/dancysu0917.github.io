# 什么是闭包？（必会）

**题目**: 什么是闭包？（必会）

## 详细解析

闭包（Closure）是JavaScript中一个非常重要的概念，也是面试中的高频考点。闭包是指一个函数能够访问并"记住"其外部作用域中的变量，即使在其外部函数已经执行完毕之后。

### 闭包的定义

闭包是指内部函数可以访问其外部函数作用域中的变量，即使外部函数已经返回。闭包由两部分组成：
1. 一个函数
2. 该函数被创建时能够访问的环境（词法环境）

### 基本闭包示例

```javascript
// 最简单的闭包示例
function outerFunction(x) {
    // 外部函数的变量
    let outerVariable = x;
    
    // 内部函数（闭包）
    function innerFunction(y) {
        // 内部函数可以访问外部函数的变量
        return outerVariable + y;
    }
    
    // 返回内部函数
    return innerFunction;
}

// 创建闭包
const closure = outerFunction(10);
console.log(closure(5)); // 输出: 15
```

### 闭包的形成机制

```javascript
// 闭包形成过程详解
function createCounter() {
    let count = 0; // 私有变量
    
    return function() {
        count++; // 访问外部函数的变量
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// 每个闭包都有自己的环境
const counter2 = createCounter();
console.log(counter2()); // 1 (独立的计数器)
console.log(counter()); // 4 (第一个计数器继续)
```

### 闭包的实际应用

#### 1. 数据封装和私有变量

```javascript
// 使用闭包创建私有变量
function createBankAccount(initialBalance) {
    let balance = initialBalance; // 私有变量
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            } else {
                return 'Insufficient funds';
            }
        },
        
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300
console.log(account.getBalance()); // 1300
// console.log(account.balance); // undefined - 无法直接访问
```

#### 2. 函数工厂

```javascript
// 创建不同功能的函数
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const tenX = createMultiplier(10);

console.log(double(5)); // 10
console.log(triple(4)); // 12
console.log(tenX(7)); // 70
```

#### 3. 事件处理中的闭包

```javascript
// 闭包在事件处理中的应用
function setupButtons() {
    const buttons = document.querySelectorAll('.button');
    
    for (let i = 0; i < buttons.length; i++) {
        // 使用闭包保存循环变量i的值
        buttons[i].addEventListener('click', (function(index) {
            return function() {
                console.log('Button ' + index + ' clicked');
            };
        })(i));
    }
}

// 现代写法（使用let或箭头函数）
function setupButtonsModern() {
    const buttons = document.querySelectorAll('.button');
    
    buttons.forEach((button, index) => {
        button.addEventListener('click', () => {
            console.log('Button ' + index + ' clicked');
        });
    });
}
```

#### 4. 模块模式

```javascript
// 使用闭包实现模块模式
const Calculator = (function() {
    // 私有变量和函数
    let history = [];
    
    function addToHistory(operation) {
        history.push(operation);
    }
    
    // 返回公共接口
    return {
        add: function(a, b) {
            const result = a + b;
            addToHistory(`${a} + ${b} = ${result}`);
            return result;
        },
        
        subtract: function(a, b) {
            const result = a - b;
            addToHistory(`${a} - ${b} = ${result}`);
            return result;
        },
        
        getHistory: function() {
            return history.slice(); // 返回副本
        },
        
        clearHistory: function() {
            history = [];
        }
    };
})();

console.log(Calculator.add(5, 3)); // 8
console.log(Calculator.subtract(10, 4)); // 6
console.log(Calculator.getHistory()); // ["5 + 3 = 8", "10 - 4 = 6"]
```

### 闭包与循环的常见问题

```javascript
// 经典闭包问题：循环中的闭包
function createFunctionsProblem() {
    const functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions[i] = function() {
            console.log(i); // 都会输出3
        };
    }
    
    return functions;
}

const funcs = createFunctionsProblem();
funcs[0](); // 3 (不是期望的0)
funcs[1](); // 3 (不是期望的1)
funcs[2](); // 3 (不是期望的2)

// 解决方案1：使用立即执行函数（IIFE）
function createFunctionsSolution1() {
    const functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions[i] = (function(index) {
            return function() {
                console.log(index);
            };
        })(i);
    }
    
    return functions;
}

const funcs1 = createFunctionsSolution1();
funcs1[0](); // 0
funcs1[1](); // 1
funcs1[2](); // 2

// 解决方案2：使用let关键字
function createFunctionsSolution2() {
    const functions = [];
    
    for (let i = 0; i < 3; i++) {
        functions[i] = function() {
            console.log(i); // 每次循环都有新的块级作用域
        };
    }
    
    return functions;
}

const funcs2 = createFunctionsSolution2();
funcs2[0](); // 0
funcs2[1](); // 1
funcs2[2](); // 2
```

### 闭包的性能考虑

```javascript
// 闭包的性能影响
function createLargeClosure() {
    const largeData = new Array(1000000).fill('data'); // 大量数据
    
    return function() {
        // 即使不使用largeData，它也会被保留在内存中
        return 'Hello';
    };
}

// 闭包保持对外部变量的引用，可能导致内存泄漏
function potentialMemoryLeak() {
    const hugeData = new Array(1000000).fill('data');
    
    document.getElementById('button').addEventListener('click', function() {
        console.log('Button clicked'); // 不需要hugeData，但它仍被引用
    });
    
    // hugeData仍然被事件处理函数引用，无法被垃圾回收
}

// 解决方案：避免不必要的引用
function avoidMemoryLeak() {
    const hugeData = new Array(1000000).fill('data');
    
    // 只在需要时使用数据
    document.getElementById('button').addEventListener('click', function() {
        // 这里不引用hugeData
        console.log('Button clicked');
    });
    
    // 在适当时候清理引用
    hugeData.length = 0; // 清空数组
}
```

### 高级闭包应用

```javascript
// 记忆化（Memoization）- 使用闭包缓存计算结果
function memoize(fn) {
    const cache = {}; // 私有缓存
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (key in cache) {
            console.log('从缓存获取结果');
            return cache[key];
        }
        
        console.log('计算新结果');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// 使用记忆化的斐波那契函数
const memoizedFib = memoize(function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
});

console.log(memoizedFib(10)); // 计算新结果
console.log(memoizedFib(10)); // 从缓存获取结果
```

### 闭包的优缺点

**优点：**
- 实现数据封装和私有变量
- 维持变量状态
- 创建特定作用域的函数
- 支持函数式编程模式

**缺点：**
- 可能导致内存泄漏（变量被持续引用）
- 增加内存使用（变量在闭包存在期间不会被回收）
- 可能影响性能（额外的作用域查找）

闭包是JavaScript中强大而重要的特性，正确理解和使用闭包对于编写高质量的JavaScript代码至关重要。
