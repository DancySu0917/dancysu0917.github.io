# 怎么判断两个对象相等？（必会）

**题目**: 怎么判断两个对象相等？（必会）

**答案**:

在 JavaScript 中，判断两个对象是否相等有多种方法，需要区分浅比较和深比较：

## 1. 基本比较概念

JavaScript 中的对象是引用类型，直接使用 `==` 或 `===` 比较的是引用地址，而不是对象内容：

```javascript
const obj1 = { name: 'John', age: 30 };
const obj2 = { name: 'John', age: 30 };
const obj3 = obj1;

console.log(obj1 == obj2);  // false - 不同对象引用
console.log(obj1 === obj2); // false - 不同对象引用
console.log(obj1 === obj3); // true - 同一对象引用
```

## 2. 浅比较（Shallow Comparison）

浅比较只比较对象的第一层属性：

```javascript
function shallowEqual(obj1, obj2) {
    // 检查引用是否相同
    if (obj1 === obj2) return true;
    
    // 检查类型
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || 
        obj1 === null || obj2 === null) {
        return obj1 === obj2;
    }
    
    // 获取对象的键
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    // 检查键的数量
    if (keys1.length !== keys2.length) return false;
    
    // 检查每个键的值
    for (let key of keys1) {
        if (!keys2.includes(key) || obj1[key] !== obj2[key]) {
            return false;
        }
    }
    
    return true;
}

// 使用示例
const obj1 = { name: 'John', age: 30 };
const obj2 = { name: 'John', age: 30 };
const obj3 = { name: 'John', age: 31 };

console.log(shallowEqual(obj1, obj2)); // true
console.log(shallowEqual(obj1, obj3)); // false
```

## 3. 深比较（Deep Comparison）

深比较会递归比较对象的所有层级：

```javascript
function deepEqual(obj1, obj2) {
    // 严格相等检查
    if (obj1 === obj2) return true;
    
    // 检查类型和 null
    if (typeof obj1 !== typeof obj2 || obj1 === null || obj2 === null) {
        return false;
    }
    
    // 检查是否都是对象或数组
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    // 检查构造函数是否相同（区分数组和对象）
    if (obj1.constructor !== obj2.constructor) return false;
    
    // 获取所有键
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    // 检查键的数量
    if (keys1.length !== keys2.length) return false;
    
    // 递归比较每个键的值
    for (let key of keys1) {
        if (!obj2.hasOwnProperty(key)) return false;
        if (!deepEqual(obj1[key], obj2[key])) return false;
    }
    
    return true;
}

// 使用示例
const obj1 = { 
    name: 'John', 
    age: 30, 
    address: { city: 'Beijing', zip: '100000' },
    hobbies: ['reading', 'swimming']
};
const obj2 = { 
    name: 'John', 
    age: 30, 
    address: { city: 'Beijing', zip: '100000' },
    hobbies: ['reading', 'swimming']
};
const obj3 = { 
    name: 'John', 
    age: 30, 
    address: { city: 'Shanghai', zip: '200000' },
    hobbies: ['reading', 'swimming']
};

console.log(deepEqual(obj1, obj2)); // true
console.log(deepEqual(obj1, obj3)); // false
```

## 4. 使用 JSON.stringify（局限性）

这种方法将对象转换为字符串进行比较，但有局限性：

```javascript
function jsonEqual(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
}

// 注意：这种方法有局限性
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 2, a: 1 }; // 属性顺序不同
console.log(jsonEqual(obj1, obj2)); // true

// 但对函数、undefined、Symbol 等会失效
const obj3 = { a: 1, fn: function() {} };
const obj4 = { a: 1, fn: function() {} };
console.log(jsonEqual(obj3, obj4)); // false - 函数被忽略
```

## 5. 使用第三方库

### Lodash
```javascript
const _ = require('lodash');

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

console.log(_.isEqual(obj1, obj2)); // true
```

### Underscore
```javascript
const _ = require('underscore');

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

console.log(_.isEqual(obj1, obj2)); // true
```

## 6. 特殊情况处理

```javascript
function advancedDeepEqual(obj1, obj2) {
    // 处理 NaN 的特殊情况
    if (Number.isNaN(obj1) && Number.isNaN(obj2)) return true;
    
    // 处理 Date 对象
    if (obj1 instanceof Date && obj2 instanceof Date) {
        return obj1.getTime() === obj2.getTime();
    }
    
    // 处理 RegExp 对象
    if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
        return obj1.toString() === obj2.toString();
    }
    
    // 其他情况使用深比较
    return deepEqual(obj1, obj2);
}
```

## 7. 性能考虑

- **浅比较**：时间复杂度 O(n)，适用于简单的对象比较
- **深比较**：时间复杂度 O(n)，但常数因子较大，适用于嵌套对象
- **JSON.stringify**：可能比深比较快，但有类型限制
- **第三方库**：通常经过优化，但在小型项目中可能引入不必要的依赖

## 8. 实际应用场景

1. **React 性能优化**：在 `React.memo`、`useMemo`、`useCallback` 中比较 props
2. **状态管理**：Redux、Vuex 等状态库中的状态变化检测
3. **缓存策略**：判断缓存是否有效
4. **测试断言**：单元测试中的对象相等性验证

## 9. 最佳实践

1. **选择合适的比较方法**：根据对象复杂度和性能要求选择
2. **避免不必要的深比较**：在循环或高频调用中谨慎使用
3. **考虑不可变数据结构**：使用如 Immutable.js 可以简化比较
4. **使用引用比较优化**：在可能的情况下使用引用比较来快速判断

在实际开发中，深比较函数需要根据具体需求进行调整，以处理各种边界情况和特殊类型的对象。
