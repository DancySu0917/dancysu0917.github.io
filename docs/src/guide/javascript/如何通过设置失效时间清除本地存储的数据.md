# 如何通过设置失效时间清除本地存储的数据？（了解）

**题目**: 如何通过设置失效时间清除本地存储的数据？（了解）

## 答案

浏览器的本地存储（localStorage、sessionStorage）本身不支持设置过期时间，但可以通过以下几种方法来实现带过期时间的数据存储和自动清除功能：

### 1. 封装 localStorage 类

```javascript
class ExpiringStorage {
  constructor(storage = localStorage) {
    this.storage = storage;
  }

  // 设置带过期时间的数据
  setItem(key, value, ttl = null) {
    const data = {
      value: value,
      timestamp: Date.now(),
      ttl: ttl // Time To Live in milliseconds
    };
    
    try {
      this.storage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.error('Storage quota exceeded:', error);
    }
  }

  // 获取数据，如果过期则返回 null 并删除
  getItem(key) {
    try {
      const item = this.storage.getItem(key);
      if (!item) return null;

      const data = JSON.parse(item);
      
      // 如果没有设置过期时间，直接返回值
      if (data.ttl === null) {
        return data.value;
      }
      
      // 检查是否过期
      const now = Date.now();
      if (now - data.timestamp > data.ttl) {
        this.removeItem(key); // 自动删除过期数据
        return null;
      }
      
      return data.value;
    } catch (error) {
      console.error('Error parsing stored data:', error);
      return null;
    }
  }

  // 删除指定键的数据
  removeItem(key) {
    this.storage.removeItem(key);
  }

  // 检查数据是否过期但不删除
  isExpired(key) {
    try {
      const item = this.storage.getItem(key);
      if (!item) return true;

      const data = JSON.parse(item);
      if (data.ttl === null) return false; // 永不过期
      
      const now = Date.now();
      return now - data.timestamp > data.ttl;
    } catch (error) {
      return true; // 解析错误视为已过期
    }
  }

  // 清除所有过期数据
  clearExpired() {
    const keysToRemove = [];
    
    for (let i = 0; i < this.storage.length; i++) {
      const key = this.storage.key(i);
      if (this.isExpired(key)) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => this.removeItem(key));
  }
}

// 使用示例
const expiringStorage = new ExpiringStorage();

// 设置数据，5分钟后过期
expiringStorage.setItem('sessionToken', 'abc123', 5 * 60 * 1000); // 5分钟

// 设置数据，永不过期
expiringStorage.setItem('userId', '12345', null);

// 获取数据
const token = expiringStorage.getItem('sessionToken');
if (token) {
  console.log('Token is valid:', token);
} else {
  console.log('Token has expired or does not exist');
}
```

### 2. 使用日期时间作为过期时间

```javascript
class TimeBasedStorage {
  constructor(storage = localStorage) {
    this.storage = storage;
  }

  // 设置数据，指定过期时间
  setItem(key, value, expiresAt) {
    const data = {
      value: value,
      expiresAt: expiresAt // Date 对象或时间戳
    };
    
    try {
      this.storage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.error('Storage quota exceeded:', error);
    }
  }

  // 设置数据，指定过期时长（秒）
  setItemWithExpiry(key, value, seconds) {
    const expiresAt = new Date(Date.now() + seconds * 1000);
    this.setItem(key, value, expiresAt.getTime());
  }

  // 获取数据，检查是否过期
  getItem(key) {
    try {
      const item = this.storage.getItem(key);
      if (!item) return null;

      const data = JSON.parse(item);
      
      // 如果没有过期时间，直接返回
      if (!data.expiresAt) {
        return data.value;
      }
      
      // 检查是否过期
      if (Date.now() > data.expiresAt) {
        this.removeItem(key); // 自动删除过期数据
        return null;
      }
      
      return data.value;
    } catch (error) {
      console.error('Error parsing stored data:', error);
      return null;
    }
  }

  removeItem(key) {
    this.storage.removeItem(key);
  }

  // 获取剩余过期时间（秒）
  getExpiryTime(key) {
    try {
      const item = this.storage.getItem(key);
      if (!item) return null;

      const data = JSON.parse(item);
      if (!data.expiresAt) return null;

      const remainingTime = (data.expiresAt - Date.now()) / 1000;
      return Math.max(0, remainingTime); // 确保不返回负数
    } catch (error) {
      return null;
    }
  }
}

// 使用示例
const timeStorage = new TimeBasedStorage();

// 设置1小时后过期的数据
timeStorage.setItemWithExpiry('userPreferences', { theme: 'dark' }, 3600); // 1小时

// 设置指定时间过期的数据
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);
tomorrow.setHours(0, 0, 0, 0);
timeStorage.setItem('dailyTip', 'Remember to drink water', tomorrow.getTime());
```

### 3. 使用 IndexedDB 实现更复杂的过期管理

```javascript
class ExpiringIndexedDB {
  constructor(dbName = 'ExpiringDB', version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = (event) => reject(event.target.error);
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // 创建带过期时间的对象存储
        if (!db.objectStoreNames.contains('data')) {
          const store = db.createObjectStore('data', { keyPath: 'key' });
          store.createIndex('expiresAt', 'expiresAt', { unique: false });
        }
      };
    });
  }

  async setItem(key, value, ttl) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['data'], 'readwrite');
    const store = transaction.objectStore('data');
    
    const expiresAt = Date.now() + ttl;
    const data = { key, value, expiresAt };
    
    return new Promise((resolve, reject) => {
      const request = store.put(data);
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event.target.error);
    });
  }

  async getItem(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['data'], 'readonly');
    const store = transaction.objectStore('data');
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = (event) => {
        const data = event.target.result;
        
        if (!data) {
          resolve(null);
          return;
        }
        
        // 检查是否过期
        if (Date.now() > data.expiresAt) {
          this.removeItem(key); // 异步删除过期数据
          resolve(null);
          return;
        }
        
        resolve(data.value);
      };
      request.onerror = (event) => reject(event.target.error);
    });
  }

  async removeItem(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['data'], 'readwrite');
    const store = transaction.objectStore('data');
    
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event.target.error);
    });
  }

  // 清理过期数据
  async cleanupExpired() {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['data'], 'readwrite');
    const store = transaction.objectStore('data');
    const index = store.index('expiresAt');
    
    const now = Date.now();
    const range = IDBKeyRange.upperBound(now);
    
    return new Promise((resolve, reject) => {
      const request = index.openCursor(range);
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          cursor.delete(); // 删除过期数据
          cursor.continue();
        } else {
          resolve();
        }
      };
      
      request.onerror = (event) => reject(event.target.error);
    });
  }
}
```

### 4. 定期清理过期数据

```javascript
class StorageManager {
  constructor() {
    this.storage = new ExpiringStorage();
    this.cleanupInterval = null;
    this.startCleanupScheduler();
  }

  // 启动清理计划任务
  startCleanupScheduler() {
    // 每10分钟清理一次过期数据
    this.cleanupInterval = setInterval(() => {
      this.storage.clearExpired();
    }, 10 * 60 * 1000); // 10分钟

    // 页面卸载前清理
    window.addEventListener('beforeunload', () => {
      this.storage.clearExpired();
    });
  }

  // 手动清理过期数据
  cleanup() {
    this.storage.clearExpired();
  }

  // 停止清理计划
  stopCleanupScheduler() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
}

// 使用示例
const storageManager = new StorageManager();

// 设置带过期时间的数据
storageManager.storage.setItem('tempData', 'some value', 5 * 60 * 1000); // 5分钟后过期
```

### 5. 实用工具函数

```javascript
// 便捷的存储工具
const StorageUtil = {
  // 设置带过期时间的 localStorage
  setWithExpiry(key, value, ttl) {
    const item = {
      value: value,
      expiry: Date.now() + ttl,
    };
    localStorage.setItem(key, JSON.stringify(item));
  },

  // 获取带过期时间的 localStorage
  getWithExpiry(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;

    try {
      const item = JSON.parse(itemStr);
      if (Date.now() > item.expiry) {
        localStorage.removeItem(key); // 自动删除过期数据
        return null;
      }
      return item.value;
    } catch (error) {
      localStorage.removeItem(key); // 解析错误时删除数据
      return null;
    }
  },

  // 移除过期数据
  removeExpired() {
    Object.keys(localStorage).forEach(key => {
      this.getWithExpiry(key); // 调用时会自动删除过期数据
    });
  },

  // 获取所有存储的键值对（包含过期检查）
  getAllValid() {
    const validItems = {};
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      const value = this.getWithExpiry(key);
      if (value !== null) {
        validItems[key] = value;
      }
    }
    return validItems;
  }
};

// 使用示例
StorageUtil.setWithExpiry('authToken', 'token123', 24 * 60 * 60 * 1000); // 24小时后过期
const token = StorageUtil.getWithExpiry('authToken');
```

### 6. 最佳实践

1. **错误处理**: 始终处理存储配额超出和解析错误
2. **性能考虑**: 定期清理过期数据，避免频繁的过期检查
3. **安全性**: 敏感数据应加密存储
4. **兼容性**: 考虑旧版浏览器的兼容性
5. **用户体验**: 提供清晰的过期提示和数据恢复机制

通过以上方法，可以有效地实现本地存储数据的自动过期和清除功能，确保数据的新鲜性和存储空间的有效利用。
