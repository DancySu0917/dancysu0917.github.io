# H5 页面嵌入小游戏时，遇到过页面内存持续上涨吗？怎么解决的？（了解）

**题目**: H5 页面嵌入小游戏时，遇到过页面内存持续上涨吗？怎么解决的？（了解）

**答案**:

H5页面嵌入小游戏时内存持续上涨是一个常见问题，主要原因和解决方案如下：

## 常见原因

1. **资源未及时释放**：
   - 图片、音频、视频等资源加载后未及时销毁
   - 游戏对象实例未及时清理
   - 定时器未清除

2. **事件监听器泄露**：
   - DOM事件监听器未移除
   - 自定义事件监听器累积
   - 全局事件监听器未清理

3. **闭包引用**：
   - 闭包持有对大对象的引用
   - 变量作用域管理不当

4. **Canvas内存管理**：
   - 频繁创建Canvas对象
   - 图像数据未释放
   - WebGL纹理未清理

## 解决方案

### 1. 资源管理
```javascript
// 游戏资源管理示例
class ResourceManager {
  constructor() {
    this.resources = new Map();
  }
  
  add(key, resource) {
    this.resources.set(key, resource);
  }
  
  remove(key) {
    const resource = this.resources.get(key);
    if (resource && typeof resource.destroy === 'function') {
      resource.destroy();
    }
    this.resources.delete(key);
  }
  
  clearAll() {
    for (const [key, resource] of this.resources) {
      if (resource && typeof resource.destroy === 'function') {
        resource.destroy();
      }
    }
    this.resources.clear();
  }
}

// 使用示例
const resourceManager = new ResourceManager();
resourceManager.add('bgMusic', new Audio('bg.mp3'));
resourceManager.add('sprite', new Image());

// 页面卸载时清理
window.addEventListener('beforeunload', () => {
  resourceManager.clearAll();
});
```

### 2. 定时器和动画帧管理
```javascript
class GameLoop {
  constructor() {
    this.animationId = null;
    this.timers = [];
  }
  
  start() {
    const update = () => {
      // 游戏逻辑更新
      this.render();
      this.animationId = requestAnimationFrame(update);
    };
    this.animationId = requestAnimationFrame(update);
  }
  
  stop() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    
    // 清理所有定时器
    this.timers.forEach(clearInterval);
    this.timers = [];
  }
}
```

### 3. 事件监听器管理
```javascript
class EventManager {
  constructor() {
    this.events = [];
  }
  
  add(element, event, handler) {
    element.addEventListener(event, handler);
    this.events.push({ element, event, handler });
  }
  
  removeAll() {
    this.events.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this.events = [];
  }
}

// 使用WeakMap管理私有事件处理器
const eventHandlers = new WeakMap();

function attachGameEvents(gameElement) {
  const handlers = {
    click: (e) => handleClick(e),
    touchstart: (e) => handleTouch(e)
  };
  
  eventHandlers.set(gameElement, handlers);
  
  Object.entries(handlers).forEach(([event, handler]) => {
    gameElement.addEventListener(event, handler);
  });
}

function detachGameEvents(gameElement) {
  const handlers = eventHandlers.get(gameElement);
  if (handlers) {
    Object.entries(handlers).forEach(([event, handler]) => {
      gameElement.removeEventListener(event, handler);
    });
    eventHandlers.delete(gameElement);
  }
}
```

### 4. Canvas内存优化
```javascript
class CanvasManager {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.images = new Set();
  }
  
  drawImage(src) {
    const img = new Image();
    img.onload = () => {
      this.ctx.drawImage(img, 0, 0);
      this.images.add(img); // 记录引用以便清理
    };
    img.src = src;
  }
  
  clear() {
    // 清空画布
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // 清理图片引用
    this.images.forEach(img => {
      img.onload = null;
      img.onerror = null;
    });
    this.images.clear();
  }
  
  destroy() {
    this.clear();
    this.canvas.width = 1;
    this.canvas.height = 1;
  }
}
```

### 5. 内存监控
```javascript
// 内存使用情况监控
function monitorMemory() {
  if (performance.memory) {
    console.log('Used:', performance.memory.usedJSHeapSize);
    console.log('Total:', performance.memory.totalJSHeapSize);
    console.log('Limit:', performance.memory.jsHeapSizeLimit);
  }
}

// 定期检查内存使用
setInterval(() => {
  monitorMemory();
}, 30000); // 每30秒检查一次
```

### 6. 游戏生命周期管理
```javascript
class GameInstance {
  constructor(container) {
    this.container = container;
    this.isRunning = false;
    this.eventManager = new EventManager();
    this.resourceManager = new ResourceManager();
  }
  
  async init() {
    // 初始化游戏资源
    await this.loadResources();
    this.setupEventListeners();
    this.startGameLoop();
  }
  
  loadResources() {
    // 预加载游戏资源
    return new Promise(resolve => {
      // 加载资源逻辑
      resolve();
    });
  }
  
  setupEventListeners() {
    // 设置事件监听器
    this.eventManager.add(this.container, 'click', this.handleClick.bind(this));
  }
  
  startGameLoop() {
    this.isRunning = true;
    // 启动游戏循环
  }
  
  destroy() {
    // 停止游戏循环
    this.isRunning = false;
    
    // 移除所有事件监听器
    this.eventManager.removeAll();
    
    // 清理所有资源
    this.resourceManager.clearAll();
    
    // 清空容器
    this.container.innerHTML = '';
  }
}

// 页面可见性变化时处理游戏状态
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // 页面隐藏时暂停游戏
    currentGame && currentGame.pause();
  } else {
    // 页面显示时恢复游戏
    currentGame && currentGame.resume();
  }
});
```

## 最佳实践

1. **建立资源生命周期管理机制**，确保所有资源在不需要时被正确释放
2. **使用弱引用（WeakMap、WeakSet）**来存储临时引用
3. **定期进行内存分析**，使用浏览器开发者工具的Memory面板
4. **实现游戏暂停/恢复机制**，在页面不可见时暂停游戏
5. **控制游戏帧率**，避免不必要的渲染

通过以上方法可以有效控制H5页面嵌入小游戏时的内存增长问题。
