# 做骨架屏时，怎么判断骨架内容和真实内容之间的切换时机？（了解）

**题目**: 做骨架屏时，怎么判断骨架内容和真实内容之间的切换时机？（了解）

**答案**:

骨架屏（Skeleton Screen）是一种优化用户体验的加载策略，通过在真实内容加载完成前展示页面结构的简化版本，让用户感知到页面正在加载。判断骨架内容和真实内容之间的切换时机是实现骨架屏的关键。

## 1. 基于数据加载状态的切换

最常见的方法是根据数据加载状态来切换：

```jsx
import React, { useState, useEffect } from 'react';

const ArticlePage = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // 模拟数据加载
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/article');
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('数据加载失败:', error);
      } finally {
        setLoading(false); // 数据加载完成，切换到真实内容
      }
    };
    
    fetchData();
  }, []);
  
  return (
    <div>
      {loading ? (
        <SkeletonArticle />
      ) : (
        <ArticleContent data={data} />
      )}
    </div>
  );
};

// 骨架屏组件
const SkeletonArticle = () => (
  <div className="skeleton-container">
    <div className="skeleton-header"></div>
    <div className="skeleton-subtitle"></div>
    <div className="skeleton-content"></div>
    <div className="skeleton-content"></div>
    <div className="skeleton-content"></div>
  </div>
);

// 真实内容组件
const ArticleContent = ({ data }) => (
  <div className="article-container">
    <h1>{data.title}</h1>
    <p>{data.subtitle}</p>
    <div>{data.content}</div>
  </div>
);
```

## 2. 使用 Promise.all 等待多个数据源

当需要等待多个数据源时：

```jsx
import React, { useState, useEffect } from 'react';

const Dashboard = () => {
  const [loading, setLoading] = useState(true);
  const [dashboardData, setDashboardData] = useState({
    userInfo: null,
    stats: null,
    recentActivity: null
  });
  
  useEffect(() => {
    const fetchAllData = async () => {
      try {
        setLoading(true);
        
        // 等待所有数据加载完成
        const [userInfo, stats, recentActivity] = await Promise.all([
          fetch('/api/user').then(res => res.json()),
          fetch('/api/stats').then(res => res.json()),
          fetch('/api/activity').then(res => res.json())
        ]);
        
        setDashboardData({
          userInfo,
          stats,
          recentActivity
        });
      } catch (error) {
        console.error('数据加载失败:', error);
      } finally {
        setLoading(false); // 所有数据加载完成
      }
    };
    
    fetchAllData();
  }, []);
  
  return (
    <div>
      {loading ? (
        <SkeletonDashboard />
      ) : (
        <DashboardContent data={dashboardData} />
      )}
    </div>
  );
};
```

## 3. 基于 DOM 渲染完成的切换

使用 Intersection Observer 或其他方式检测内容是否渲染完成：

```javascript
// 检测特定元素是否渲染完成
function waitForElementRender(elementSelector, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const element = document.querySelector(elementSelector);
    
    if (element) {
      // 如果元素已存在，检查是否渲染完成
      const checkRender = () => {
        if (element.children.length > 0 || element.textContent.trim() !== '') {
          resolve();
        } else {
          setTimeout(checkRender, 100);
        }
      };
      checkRender();
    } else {
      // 使用 MutationObserver 监听元素出现
      const observer = new MutationObserver((mutations) => {
        const targetElement = document.querySelector(elementSelector);
        if (targetElement) {
          const checkRender = () => {
            if (targetElement.children.length > 0 || targetElement.textContent.trim() !== '') {
              resolve();
              observer.disconnect();
            } else {
              setTimeout(checkRender, 100);
            }
          };
          checkRender();
        }
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      
      // 设置超时
      setTimeout(() => {
        observer.disconnect();
        reject(new Error('元素渲染超时'));
      }, timeout);
    }
  });
}
```

## 4. 结合加载时间的策略

避免骨架屏闪烁，设置最小显示时间：

```jsx
import React, { useState, useEffect } from 'react';

const ContentWithSkeleton = ({ dataLoader }) => {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState(null);
  const [showSkeleton, setShowSkeleton] = useState(true);
  
  useEffect(() => {
    const startTime = Date.now();
    const minSkeletonTime = 800; // 最小骨架屏显示时间，避免闪烁
    
    const loadData = async () => {
      try {
        const result = await dataLoader();
        setData(result);
      } catch (error) {
        console.error('数据加载失败:', error);
      } finally {
        const elapsedTime = Date.now() - startTime;
        const remainingTime = Math.max(0, minSkeletonTime - elapsedTime);
        
        // 确保骨架屏至少显示最小时间
        setTimeout(() => {
          setLoading(false);
          setShowSkeleton(false);
        }, remainingTime);
      }
    };
    
    loadData();
  }, [dataLoader]);
  
  return (
    <div>
      {showSkeleton && <SkeletonComponent />}
      {!showSkeleton && <RealContent data={data} />}
    </div>
  );
};
```

## 5. 使用 React Suspense 和 Lazy Loading

React 18 提供了更好的骨架屏实现方式：

```jsx
import React, { Suspense, lazy } from 'react';

// 懒加载组件
const LazyComponent = lazy(() => import('./RealComponent'));

const App = () => {
  return (
    <div>
      <Suspense fallback={<SkeletonComponent />}>
        <LazyComponent />
      </Suspense>
    </div>
  );
};

// 自定义 Suspense 组件，支持更精细的控制
const CustomSuspense = ({ fallback, children, delay = 0 }) => {
  const [showFallback, setShowFallback] = useState(false);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowFallback(true);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [delay]);
  
  return (
    <React.Suspense fallback={showFallback ? fallback : null}>
      {children}
    </React.Suspense>
  );
};
```

## 6. 基于性能指标的切换

使用 Performance API 监控关键渲染时间：

```javascript
// 监听关键渲染指标
function monitorRenderMetrics() {
  // 监听 DOMContentLoaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM 内容加载完成');
    });
  } else {
    console.log('DOM 内容已加载');
  }
  
  // 使用 PerformanceObserver 监听绘制事件
  if ('PerformanceObserver' in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'paint') {
          console.log(`${entry.name} 绘制完成: ${entry.startTime}ms`);
          // 可以根据绘制完成时间来决定切换时机
          if (entry.name === 'first-contentful-paint') {
            // 首次内容绘制完成，可以考虑隐藏骨架屏
          }
        }
      });
    });
    
    observer.observe({ entryTypes: ['paint'] });
  }
}
```

## 7. 综合策略

实际项目中通常结合多种策略：

```jsx
import React, { useState, useEffect, useCallback } from 'react';

const SmartSkeleton = ({ children, loader, minDisplayTime = 800 }) => {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState(null);
  const [startTime, setStartTime] = useState(null);
  
  const loadData = useCallback(async () => {
    setStartTime(Date.now());
    
    try {
      const result = await loader();
      setData(result);
    } catch (error) {
      console.error('数据加载失败:', error);
    }
  }, [loader]);
  
  useEffect(() => {
    loadData();
  }, [loadData]);
  
  useEffect(() => {
    if (data !== null && startTime) {
      const elapsed = Date.now() - startTime;
      const remainingTime = Math.max(0, minDisplayTime - elapsed);
      
      const timer = setTimeout(() => {
        setLoading(false);
      }, remainingTime);
      
      return () => clearTimeout(timer);
    }
  }, [data, startTime, minDisplayTime]);
  
  // 同时满足数据加载完成和最小显示时间后才切换
  return loading ? <SkeletonComponent /> : children({ data });
};

// 使用示例
const MyComponent = () => {
  const dataLoader = () => fetch('/api/data').then(res => res.json());
  
  return (
    <SmartSkeleton loader={dataLoader}>
      {({ data }) => <RealContent data={data} />}
    </SmartSkeleton>
  );
};
```

## 总结

选择合适的切换时机策略取决于具体场景：

1. **简单数据加载**：基于加载状态切换
2. **复杂页面**：结合多个数据源的状态
3. **避免闪烁**：设置最小显示时间
4. **React 应用**：使用 Suspense 和 lazy
5. **性能敏感**：结合 Performance API

关键是在用户体验和性能之间找到平衡，既不能让用户等待太久，也不能让骨架屏一闪而过。
