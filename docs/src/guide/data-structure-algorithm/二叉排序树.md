# 二叉排序树？（高薪常问）

## 标准答案

### 定义
二叉排序树（Binary Search Tree，BST），也称为二叉搜索树或二叉查找树，是一种特殊的二叉树，具有以下性质：
- 左子树上所有节点的值均小于根节点的值
- 右子树上所有节点的值均大于根节点的值
- 左右子树也分别为二叉排序树

### 主要操作
1. **查找操作**：从根节点开始，若目标值等于节点值则找到；若目标值小于节点值则在左子树查找；否则在右子树查找
2. **插入操作**：从根节点开始查找插入位置，若值小于当前节点则插入左子树，否则插入右子树
3. **删除操作**：分三种情况处理：
   - 删除叶子节点：直接删除
   - 删除只有一个子节点的节点：用子节点替换该节点
   - 删除有两个子节点的节点：用中序前驱或后继替换该节点

### 时间复杂度
- 平均情况：查找、插入、删除均为O(log n)
- 最坏情况：当树退化为链表时，时间复杂度为O(n)

### 优缺点
**优点**：
- 中序遍历可得到有序序列
- 平均性能良好
- 实现相对简单

**缺点**：
- 最坏情况下性能退化为O(n)
- 不保证平衡性

## 深入理解

### 二叉排序树的实现
```javascript
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  // 插入节点
  insert(val) {
    this.root = this._insertNode(this.root, val);
  }

  _insertNode(node, val) {
    if (!node) return new TreeNode(val);

    if (val < node.val) {
      node.left = this._insertNode(node.left, val);
    } else if (val > node.val) {
      node.right = this._insertNode(node.right, val);
    }
    // 如果val === node.val，不插入重复值

    return node;
  }

  // 查找节点
  search(val) {
    return this._searchNode(this.root, val);
  }

  _searchNode(node, val) {
    if (!node || node.val === val) return node;

    if (val < node.val) {
      return this._searchNode(node.left, val);
    } else {
      return this._searchNode(node.right, val);
    }
  }

  // 中序遍历（得到有序序列）
  inorder() {
    const result = [];
    this._inorderTraversal(this.root, result);
    return result;
  }

  _inorderTraversal(node, result) {
    if (node) {
      this._inorderTraversal(node.left, result);
      result.push(node.val);
      this._inorderTraversal(node.right, result);
    }
  }

  // 删除节点
  delete(val) {
    this.root = this._deleteNode(this.root, val);
  }

  _deleteNode(node, val) {
    if (!node) return null;

    if (val < node.val) {
      node.left = this._deleteNode(node.left, val);
    } else if (val > node.val) {
      node.right = this._deleteNode(node.right, val);
    } else {
      // 找到要删除的节点
      if (!node.left) return node.right;  // 没有左子树或叶子节点
      if (!node.right) return node.left;  // 没有右子树

      // 有两个子节点，找到中序后继
      const minNode = this._findMin(node.right);
      node.val = minNode.val;
      node.right = this._deleteNode(node.right, minNode.val);
    }

    return node;
  }

  _findMin(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
}

// 使用示例
const bst = new BST();
[5, 3, 7, 2, 4, 6, 8].forEach(val => bst.insert(val));
console.log(bst.inorder()); // [2, 3, 4, 5, 6, 7, 8]
```

### 二叉排序树的变种
为了解决BST在最坏情况下的性能问题，出现了多种改进版本：
- **AVL树**：严格平衡的二叉搜索树，任意节点的左右子树高度差不超过1
- **红黑树**：通过颜色属性保证平衡性，插入删除操作最多需要O(1)次旋转
- **B树/B+树**：多路平衡搜索树，常用于数据库和文件系统

### 实际应用
二叉排序树广泛应用于：
1. 数据库索引结构
2. C++ STL中的set、map容器
3. Java中的TreeSet、TreeMap
4. 文件系统目录结构
5. 编译器符号表

二叉排序树是数据结构中的重要概念，理解其原理对掌握更复杂的平衡树结构有重要意义。
