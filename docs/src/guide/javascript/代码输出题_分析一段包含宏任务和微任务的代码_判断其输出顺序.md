# 代码输出题：分析一段包含宏任务和微任务的代码，判断其输出顺序（高薪常问）

**题目**: 代码输出题：分析一段包含宏任务和微任务的代码，判断其输出顺序（高薪常问）

## 标准答案

### 事件循环机制
JavaScript是单线程语言，通过事件循环（Event Loop）机制实现异步操作：
1. 执行栈（Call Stack）：执行同步代码
2. 宏任务队列（Macro Task Queue）：setTimeout、setInterval、I/O、UI渲染等
3. 微任务队列（Micro Task Queue）：Promise.then、MutationObserver、queueMicrotask等

### 执行顺序规则
1. 执行当前执行栈中的同步代码
2. 检查微任务队列，执行所有微任务
3. 执行一个宏任务
4. 再次检查微任务队列，执行所有微任务
5. 重复步骤3-4

### 常见宏任务和微任务
```javascript
// 宏任务（Macro Task）
setTimeout(() => console.log('setTimeout'));
setInterval(() => console.log('setInterval'));
setImmediate(() => console.log('setImmediate')); // Node.js
requestAnimationFrame(() => console.log('requestAnimationFrame'));

// 微任务（Micro Task）
Promise.resolve().then(() => console.log('Promise'));
queueMicrotask(() => console.log('queueMicrotask'));
MutationObserver(() => console.log('MutationObserver'));
```

## 深入理解

### 经典示例分析
```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

// 输出顺序：1 4 3 2
```

### 复杂示例分析
```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});

console.log('script end');

// 输出顺序：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

### 详细执行流程
1. 执行同步代码：`console.log('script start')`
2. 遇到setTimeout，加入宏任务队列
3. 执行async1：输出'async1 start'，执行async2：输出'async2'
4. await后的内容被放入微任务队列
5. 遇到Promise，输出'promise1'，then加入微任务队列
6. 执行同步代码：输出'script end'
7. 执行所有微任务：'async1 end'、'promise2'
8. 执行一个宏任务：'setTimeout'

### 宏任务与微任务的嵌套
```javascript
setTimeout(() => {
  console.log('timeout1');
  Promise.resolve().then(() => console.log('promise1'));
}, 0);

Promise.resolve().then(() => {
  console.log('promise2');
  setTimeout(() => console.log('timeout2'), 0);
});

// 输出顺序：promise2 -> timeout1 -> promise1 -> timeout2
```

## 实际面试问题及答案

### Q: 宏任务和微任务的区别是什么？
A:
1. **执行时机**：宏任务执行完后，会清空所有微任务；微任务执行完后，才执行下一个宏任务
2. **优先级**：微任务优先级高于宏任务
3. **类型**：宏任务包括setTimeout、setInterval等；微任务包括Promise.then、queueMicrotask等
4. **执行次数**：每次循环执行一个宏任务，但会执行完所有微任务

### Q: 为什么微任务优先级高于宏任务？
A:
微任务的设计目的是为了在当前任务执行完毕后，但在渲染之前，处理一些紧急的回调。这样可以确保在一次事件循环中，相关的回调能够被及时处理，避免出现中间状态。

### Q: async/await 与 Promise 的执行顺序有什么关系？
A:
1. async函数中的await前的代码是同步执行的
2. await表达式会暂停async函数的执行，等待Promise解决
3. await后面的代码会被放入微任务队列
4. async函数的返回值总是Promise对象

### Q: 请分析以下代码的输出顺序：
```javascript
console.log('start');
setTimeout(() => console.log('timeout1'), 0);
Promise.resolve().then(() => {
  console.log('promise1');
  setTimeout(() => console.log('timeout2'), 0);
});
Promise.resolve().then(() => console.log('promise2'));
console.log('end');
```
A:
输出顺序：start -> end -> promise1 -> promise2 -> timeout1 -> timeout2

### Q: 如何在宏任务之间插入微任务？
A:
可以使用Promise.resolve().then()或queueMicrotask()来创建微任务。微任务会在当前宏任务结束后、下一个宏任务开始前执行。

### Q: 事件循环在浏览器和Node.js中的区别？
A:
1. **浏览器**：宏任务队列单一，执行一个宏任务后清空微任务
2. **Node.js**：有多个宏任务队列（timers、I/O、check等），执行策略更复杂
3. **微任务执行时机**：Node.js在每个阶段结束后都会执行微任务，浏览器只在宏任务后执行

理解事件循环机制是JavaScript异步编程的核心，对于编写高性能的异步代码至关重要。
