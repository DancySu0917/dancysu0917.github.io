# 设计一套全站请求耗时统计工具？（了解）

**题目**: 设计一套全站请求耗时统计工具？（了解）

**答案**:

设计一套全站请求耗时统计工具需要考虑以下几个方面：

## 1. 拦截请求

### XMLHttpRequest 拦截
```javascript
// 保存原始的open和send方法
const originalOpen = XMLHttpRequest.prototype.open;
const originalSend = XMLHttpRequest.prototype.send;

// 重写open方法
XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
  this._requestStart = Date.now();
  this._method = method;
  this._url = url;
  return originalOpen.apply(this, arguments);
};

// 重写send方法
XMLHttpRequest.prototype.send = function(body) {
  const originalOnReadyStateChange = this.onreadystatechange;
  
  this.onreadystatechange = function() {
    if (this.readyState === 4) { // 请求完成
      const duration = Date.now() - this._requestStart;
      collectRequestMetrics(this._method, this._url, this.status, duration);
    }
    
    if (originalOnReadyStateChange) {
      originalOnReadyStateChange.apply(this, arguments);
    }
  };
  
  return originalSend.apply(this, arguments);
};
```

### Fetch API 拦截
```javascript
const originalFetch = window.fetch;

window.fetch = function(input, init) {
  const startTime = Date.now();
  const url = typeof input === 'string' ? input : input.url;
  const method = (init && init.method) || 'GET';
  
  return originalFetch(input, init)
    .then(response => {
      const duration = Date.now() - startTime;
      collectRequestMetrics(method, url, response.status, duration);
      return response;
    })
    .catch(error => {
      const duration = Date.now() - startTime;
      collectRequestMetrics(method, url, 0, duration, error.message); // 0表示网络错误
      throw error;
    });
};
```

## 2. 数据收集与处理

```javascript
// 请求指标收集函数
function collectRequestMetrics(method, url, status, duration, error = null) {
  const metric = {
    timestamp: Date.now(),
    method,
    url,
    status,
    duration,
    error,
    // 可以添加更多指标，如用户ID、页面URL等
    pageUrl: window.location.href,
    userAgent: navigator.userAgent
  };
  
  // 发送到统计服务器或存储到本地
  sendMetricsToServer(metric);
}

// 发送指标到服务器
function sendMetricsToServer(metric) {
  // 使用navigator.sendBeacon确保即使页面关闭也能发送数据
  if (navigator.sendBeacon) {
    navigator.sendBeacon('/api/metrics', JSON.stringify(metric));
  } else {
    // 降级方案
    fetch('/api/metrics', {
      method: 'POST',
      body: JSON.stringify(metric),
      headers: { 'Content-Type': 'application/json' },
      keepalive: true // 如果支持的话
    }).catch(() => {
      // 忽略发送失败
    });
  }
}
```

## 3. 指标分析

```javascript
// 请求性能分析类
class RequestAnalyzer {
  constructor() {
    this.metrics = [];
    this.config = {
      slowRequestThreshold: 1000, // 慢请求阈值（毫秒）
      errorRateThreshold: 0.05,   // 错误率阈值（5%）
      timeoutThreshold: 5000      // 超时阈值（毫秒）
    };
  }
  
  addMetric(metric) {
    this.metrics.push(metric);
    this.analyzeMetric(metric);
  }
  
  analyzeMetric(metric) {
    // 检查慢请求
    if (metric.duration > this.config.slowRequestThreshold) {
      console.warn(`慢请求警告: ${metric.url}, 耗时: ${metric.duration}ms`);
    }
    
    // 检查错误
    if (metric.status >= 400 || metric.error) {
      console.error(`请求错误: ${metric.url}, 状态码: ${metric.status}, 错误: ${metric.error}`);
    }
    
    // 检查超时
    if (metric.duration > this.config.timeoutThreshold) {
      console.warn(`超时请求: ${metric.url}, 耗时: ${metric.duration}ms`);
    }
  }
  
  getStats() {
    if (this.metrics.length === 0) return null;
    
    const durations = this.metrics.map(m => m.duration);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);
    const minDuration = Math.min(...durations);
    
    const errors = this.metrics.filter(m => m.status >= 400 || m.error).length;
    const errorRate = errors / this.metrics.length;
    
    return {
      totalRequests: this.metrics.length,
      avgDuration,
      maxDuration,
      minDuration,
      errorRate,
      successRate: 1 - errorRate
    };
  }
}
```

## 4. 完整实现示例

```javascript
class RequestMetricsCollector {
  constructor(options = {}) {
    this.analyzer = new RequestAnalyzer();
    this.enabled = options.enabled !== false;
    this.apiUrl = options.apiUrl || '/api/metrics';
    
    if (this.enabled) {
      this.interceptRequests();
    }
  }
  
  interceptRequests() {
    this.interceptXHR();
    this.interceptFetch();
  }
  
  interceptXHR() {
    const originalOpen = XMLHttpRequest.prototype.open;
    const originalSend = XMLHttpRequest.prototype.send;
    
    const self = this;
    
    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      if (self.shouldCollect(url)) {
        this._requestStart = Date.now();
        this._method = method;
        this._url = url;
      }
      return originalOpen.apply(this, arguments);
    };
    
    XMLHttpRequest.prototype.send = function(body) {
      if (this._requestStart) {
        const originalOnReadyStateChange = this.onreadystatechange;
        
        this.onreadystatechange = function() {
          if (this.readyState === 4) {
            const duration = Date.now() - this._requestStart;
            const metric = {
              timestamp: Date.now(),
              method: this._method,
              url: this._url,
              status: this.status,
              duration,
              type: 'xhr'
            };
            
            self.collectMetric(metric);
          }
          
          if (originalOnReadyStateChange) {
            originalOnReadyStateChange.apply(this, arguments);
          }
        };
      }
      
      return originalSend.apply(this, arguments);
    };
  }
  
  interceptFetch() {
    const originalFetch = window.fetch;
    const self = this;
    
    window.fetch = function(input, init) {
      const url = typeof input === 'string' ? input : input.url;
      const method = (init && init.method) || 'GET';
      
      if (!self.shouldCollect(url)) {
        return originalFetch(input, init);
      }
      
      const startTime = Date.now();
      
      return originalFetch(input, init)
        .then(response => {
          const duration = Date.now() - startTime;
          const metric = {
            timestamp: Date.now(),
            method,
            url,
            status: response.status,
            duration,
            type: 'fetch'
          };
          
          self.collectMetric(metric);
          return response;
        })
        .catch(error => {
          const duration = Date.now() - startTime;
          const metric = {
            timestamp: Date.now(),
            method,
            url,
            status: 0,
            duration,
            error: error.message,
            type: 'fetch'
          };
          
          self.collectMetric(metric);
          throw error;
        });
    };
  }
  
  shouldCollect(url) {
    // 排除静态资源和统计接口本身
    const excludePatterns = [
      /\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf)$/,
      this.apiUrl
    ];
    
    return !excludePatterns.some(pattern => {
      if (typeof pattern === 'string') {
        return url.includes(pattern);
      } else {
        return pattern.test(url);
      }
    });
  }
  
  collectMetric(metric) {
    this.analyzer.addMetric(metric);
    
    // 可以根据需要决定何时发送数据
    // 例如：批量发送、定时发送等
    this.sendMetric(metric);
  }
  
  sendMetric(metric) {
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.apiUrl, JSON.stringify(metric));
    } else {
      fetch(this.apiUrl, {
        method: 'POST',
        body: JSON.stringify(metric),
        headers: { 'Content-Type': 'application/json' },
        keepalive: true
      }).catch(() => {
        // 忽略发送失败
      });
    }
  }
}

// 使用示例
const metricsCollector = new RequestMetricsCollector({
  enabled: true,
  apiUrl: '/api/request-metrics'
});
```

这套工具可以全面监控全站请求性能，帮助识别慢请求、错误请求等问题，为性能优化提供数据支持。
