# 简述创建函数的几种方式？（必会）

**题目**: 简述创建函数的几种方式？（必会）

**答案**:

在 JavaScript 中，有多种方式可以创建函数，每种方式都有其特点和适用场景。以下是主要的函数创建方式：

### 1. 函数声明（Function Declaration）

函数声明是使用 `function` 关键字直接声明函数的方式，会被提升（hoisted）到作用域顶部。

```javascript
// 基本语法
function functionName(parameters) {
    // 函数体
    return result;
}

// 示例
function add(a, b) {
    return a + b;
}

console.log(add(2, 3));  // 5

// 函数声明会被提升，可以在声明前调用
console.log(greet("张三"));  // "你好，张三"

function greet(name) {
    return "你好，" + name;
}
```

**特点**：
- 函数声明会被提升到作用域顶部
- 可以在声明之前调用
- 语法清晰，易于理解

### 2. 函数表达式（Function Expression）

函数表达式是将函数赋值给一个变量的方式。

```javascript
// 基本语法
const functionName = function(parameters) {
    // 函数体
    return result;
};

// 示例
const multiply = function(a, b) {
    return a * b;
};

console.log(multiply(3, 4));  // 12

// 匿名函数表达式
const subtract = function(a, b) {
    return a - b;
};

// 具名函数表达式（命名函数表达式）
const divide = function division(a, b) {
    if (b === 0) {
        console.error("除数不能为零");
        return NaN;
    }
    return a / b;
};

console.log(divide(10, 2));  // 5
console.log(divide.name);    // "division"（函数名属性）
```

**特点**：
- 不会被提升，必须在定义后才能调用
- 可以是匿名函数或具名函数
- 更灵活，可作为参数传递

### 3. 箭头函数（Arrow Function）- ES6+

ES6 引入的箭头函数提供了更简洁的函数语法。

```javascript
// 基本语法
const functionName = (parameters) => {
    // 函数体
    return result;
};

// 单参数可以省略括号
const square = x => x * x;

// 多参数需要括号
const power = (base, exponent) => Math.pow(base, exponent);

// 单表达式可以省略大括号和 return
const add = (a, b) => a + b;

// 多行需要大括号和 return
const complexFunction = (x, y) => {
    const result = x * 2 + y * 3;
    return result > 10 ? result : 0;
};

// 返回对象需要括号包围
const createUser = (name, age) => ({ name, age });

console.log(square(5));           // 25
console.log(power(2, 3));         // 8
console.log(add(3, 4));           // 7
console.log(complexFunction(3, 4)); // 18
console.log(createUser("李四", 25)); // {name: "李四", age: 25}
```

**特点**：
- 语法简洁
- 不绑定自己的 `this`、`arguments`、`super` 或 `new.target`
- 不能用作构造函数
- 没有 `prototype` 属性

### 4. 构造函数（Constructor Function）

使用 `Function` 构造函数动态创建函数。

```javascript
// 基本语法
const functionName = new Function('param1', 'param2', 'functionBody');

// 示例
const add = new Function('a', 'b', 'return a + b');
console.log(add(2, 3));  // 5

// 多个参数
const calculator = new Function(
    'operation', 
    'a', 
    'b', 
    `
        switch(operation) {
            case 'add': return a + b;
            case 'subtract': return a - b;
            case 'multiply': return a * b;
            case 'divide': return b !== 0 ? a / b : NaN;
            default: return NaN;
        }
    `
);

console.log(calculator('multiply', 4, 5));  // 20
```

**特点**：
- 动态创建函数
- 性能较差（每次调用都会解析函数体）
- 安全风险（类似 eval）
- 一般不推荐使用

### 5. 方法定义（Method Definition）

在对象中定义方法。

```javascript
// ES5 风格
const obj = {
    name: "对象",
    greet: function() {
        return "你好，我是" + this.name;
    },
    calculate: function(a, b) {
        return a + b;
    }
};

// ES6 简写方法
const person = {
    name: "张三",
    // 简写方法定义
    greet() {
        return `你好，我是${this.name}`;
    },
    // 计算属性名方法
    ['say' + 'Hello']() {
        return "Hello!";
    }
};

console.log(person.greet());      // "你好，我是张三"
console.log(person.sayHello());   // "Hello!"

// 类中的方法
class Calculator {
    constructor() {
        this.result = 0;
    }
    
    add(value) {
        this.result += value;
        return this;
    }
    
    multiply(value) {
        this.result *= value;
        return this;
    }
    
    getResult() {
        return this.result;
    }
}

const calc = new Calculator();
console.log(calc.add(5).multiply(2).getResult());  // 10
```

### 6. 立即执行函数表达式（IIFE - Immediately Invoked Function Expression）

定义后立即执行的函数。

```javascript
// 基本语法
(function() {
    // 函数体
})();

// 或者
(function() {
    // 函数体
}());

// 带参数的 IIFE
(function(name) {
    console.log("Hello, " + name);
})("World");  // 输出: Hello, World

// IIFE 创建私有作用域
const module = (function() {
    let privateVariable = "私有变量";
    
    return {
        publicMethod: function() {
            return privateVariable;
        },
        setPrivateVariable: function(value) {
            privateVariable = value;
        }
    };
})();

console.log(module.publicMethod());  // "私有变量"
module.setPrivateVariable("新值");
console.log(module.publicMethod());  // "新值"
```

### 7. Generator 函数

ES6 引入的生成器函数，可以暂停和恢复执行。

```javascript
// 基本语法
function* generatorFunction() {
    yield 1;
    yield 2;
    yield 3;
}

// 示例
function* countGenerator(max) {
    let count = 0;
    while(count < max) {
        yield count++;
    }
}

const counter = countGenerator(3);
console.log(counter.next());  // {value: 0, done: false}
console.log(counter.next());  // {value: 1, done: false}
console.log(counter.next());  // {value: 2, done: false}
console.log(counter.next());  // {value: undefined, done: true}

// 使用 for...of 遍历
function* fibonacci() {
    let a = 0, b = 1;
    while(true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

const fib = fibonacci();
for(let i = 0; i < 5; i++) {
    console.log(fib.next().value);  // 0, 1, 1, 2, 3
}
```

### 8. 各种方式对比

| 方式 | 语法 | 提升 | this 绑定 | 构造函数 | 适用场景 |
|------|------|------|-----------|----------|----------|
| 函数声明 | `function name() {}` | 是 | 动态 | 是 | 通用函数定义 |
| 函数表达式 | `const name = function() {}` | 否 | 动态 | 是 | 回调、闭包 |
| 箭头函数 | `() => {}` | 否 | 词法 | 否 | 简化回调、保持 this |
| 构造函数 | `new Function()` | 否 | 动态 | 是 | 动态创建（不推荐） |
| 方法定义 | `obj: { method() {} }` | 否 | 对象 | 否 | 对象方法 |
| IIFE | `(function() {})()` | 否 | 动态 | 否 | 私有作用域 |
| Generator | `function* name() {}` | 是 | 动态 | 否 | 异步流程控制 |

### 9. 实际应用示例

```javascript
// 1. 事件处理中使用箭头函数保持 this
class Component {
    constructor() {
        this.name = "组件";
    }
    
    bindEvents() {
        // 使用箭头函数确保 this 指向组件实例
        document.addEventListener('click', () => {
            console.log(this.name);  // "组件"
        });
    }
}

// 2. 函数表达式用于回调
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(function(num) {
    return num * 2;
});

// 3. 高阶函数
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5));  // 10
console.log(triple(5));  // 15

// 4. 模块模式
const MathUtils = (function() {
    // 私有方法
    function isEven(num) {
        return num % 2 === 0;
    }
    
    // 公共接口
    return {
        add: (a, b) => a + b,
        subtract: (a, b) => a - b,
        isEven: isEven
    };
})();
```

### 10. 最佳实践

1. **优先使用函数声明**：对于独立的、可复用的函数
2. **使用箭头函数**：在需要保持词法 this 的场景
3. **使用函数表达式**：当函数需要作为参数传递时
4. **避免使用 Function 构造函数**：存在安全和性能问题
5. **合理使用 IIFE**：创建私有作用域，避免全局污染

在实际开发中，应根据具体需求和场景选择合适的函数创建方式。
