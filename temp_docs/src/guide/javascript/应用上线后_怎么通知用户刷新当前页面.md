# åº”ç”¨ä¸Šçº¿åï¼Œæ€ä¹ˆé€šçŸ¥ç”¨æˆ·åˆ·æ–°å½“å‰é¡µé¢ï¼Ÿï¼ˆäº†è§£ï¼‰

**é¢˜ç›®**: åº”ç”¨ä¸Šçº¿åï¼Œæ€ä¹ˆé€šçŸ¥ç”¨æˆ·åˆ·æ–°å½“å‰é¡µé¢ï¼Ÿï¼ˆäº†è§£ï¼‰

## é—®é¢˜åˆ†æ

è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„å‰ç«¯è¿ç»´é—®é¢˜ã€‚å½“åº”ç”¨æ›´æ–°éƒ¨ç½²åï¼Œç”¨æˆ·å¯èƒ½ä»åœ¨ä½¿ç”¨æ—§ç‰ˆæœ¬çš„ç¼“å­˜èµ„æºï¼Œå¯¼è‡´åŠŸèƒ½å¼‚å¸¸æˆ–ç”¨æˆ·ä½“éªŒé—®é¢˜ã€‚éœ€è¦åœ¨åº”ç”¨æ›´æ–°åé€šçŸ¥ç”¨æˆ·åˆ·æ–°é¡µé¢ä»¥è·å–æœ€æ–°ç‰ˆæœ¬ã€‚

## è§£å†³æ–¹æ¡ˆ

### 1. ç‰ˆæœ¬æ£€æŸ¥æœºåˆ¶

```javascript
// ç‰ˆæœ¬æ£€æŸ¥æœåŠ¡
class VersionChecker {
  constructor(checkInterval = 30000) { // 30ç§’æ£€æŸ¥ä¸€æ¬¡
    this.checkInterval = checkInterval;
    this.currentVersion = this.getCurrentVersion();
    this.init();
  }

  init() {
    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥ç‰ˆæœ¬
    this.checkVersion();
    
    // å®šæœŸæ£€æŸ¥ç‰ˆæœ¬
    setInterval(() => {
      this.checkVersion();
    }, this.checkInterval);
    
    // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶æ£€æŸ¥
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        this.checkVersion();
      }
    });
  }

  async checkVersion() {
    try {
      const response = await fetch('/api/version', {
        method: 'GET',
        cache: 'no-cache' // ç¡®ä¿è·å–æœ€æ–°ç‰ˆæœ¬ä¿¡æ¯
      });
      
      const { version } = await response.json();
      
      if (version !== this.currentVersion) {
        this.handleVersionUpdate(version);
      }
    } catch (error) {
      console.error('Version check failed:', error);
    }
  }

  handleVersionUpdate(newVersion) {
    console.log(`New version available: ${newVersion}`);
    
    // æ˜¾ç¤ºæ›´æ–°æç¤º
    this.showUpdateNotification(newVersion);
  }

  showUpdateNotification(newVersion) {
    // åˆ›å»ºæ›´æ–°æç¤ºUI
    const notification = document.createElement('div');
    notification.className = 'app-update-notification';
    notification.innerHTML = `
      <div class="update-content">
        <h3>åº”ç”¨æœ‰æ–°ç‰ˆæœ¬å¯ç”¨</h3>
        <p>æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬: ${newVersion}</p>
        <div class="update-actions">
          <button id="refresh-btn">ç«‹å³åˆ·æ–°</button>
          <button id="dismiss-btn">ç¨åæé†’</button>
        </div>
      </div>
    `;

    document.body.appendChild(notification);

    // ç»‘å®šäº‹ä»¶
    document.getElementById('refresh-btn').addEventListener('click', () => {
      this.refreshPage();
    });

    document.getElementById('dismiss-btn').addEventListener('click', () => {
      notification.remove();
    });
  }

  refreshPage() {
    // æ¸…é™¤ç¼“å­˜ååˆ·æ–°
    if ('caches' in window) {
      caches.keys().then(names => {
        names.map(name => caches.delete(name));
      }).then(() => {
        window.location.reload(true);
      });
    } else {
      window.location.reload(true);
    }
  }

  getCurrentVersion() {
    // ä»metaæ ‡ç­¾æˆ–å…¶ä»–åœ°æ–¹è·å–å½“å‰ç‰ˆæœ¬
    const versionMeta = document.querySelector('meta[name="version"]');
    return versionMeta ? versionMeta.getAttribute('content') : 'unknown';
  }
}

// åˆå§‹åŒ–ç‰ˆæœ¬æ£€æŸ¥å™¨
const versionChecker = new VersionChecker();
```

### 2. Service Worker ç‰ˆæœ¬æ§åˆ¶

```javascript
// sw.js - Service Worker æ–‡ä»¶
const CACHE_NAME = 'app-v1.2.3'; // ç‰ˆæœ¬å·
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/app.js',
  '/images/logo.png'
];

// å®‰è£… Service Worker
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        return cache.addAll(urlsToCache);
      })
  );
});

// æ‹¦æˆªç½‘ç»œè¯·æ±‚
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // å¦‚æœç¼“å­˜ä¸­æœ‰åˆ™è¿”å›ç¼“å­˜ï¼Œå¦åˆ™å‘èµ·ç½‘ç»œè¯·æ±‚
        return response || fetch(event.request);
      })
  );
});

// æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬ SW æ—¶æ›´æ–°
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// ç›‘å¬ SW æ›´æ–°
self.addEventListener('controllerchange', () => {
  if (location.reload) {
    location.reload();
  }
});
```

```javascript
// ä¸»åº”ç”¨ä¸­æ³¨å†Œå’Œç®¡ç† Service Worker
class SWManager {
  constructor() {
    this.swRegistration = null;
    this.init();
  }

  async init() {
    if ('serviceWorker' in navigator) {
      try {
        this.swRegistration = await navigator.serviceWorker.register('/sw.js');
        
        // ç›‘å¬ SW æ›´æ–°
        this.swRegistration.addEventListener('updatefound', () => {
          const newSW = this.swRegistration.installing;
          
          newSW.addEventListener('statechange', () => {
            if (newSW.state === 'installed' && navigator.serviceWorker.controller) {
              // æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œé€šçŸ¥ç”¨æˆ·
              this.showUpdateNotification();
            }
          });
        });

        // æ£€æŸ¥æ§åˆ¶å™¨å˜åŒ–
        let refreshing = false;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          if (!refreshing) {
            window.location.reload();
            refreshing = true;
          }
        });
      } catch (error) {
        console.error('SW registration failed:', error);
      }
    }
  }

  showUpdateNotification() {
    const notification = document.createElement('div');
    notification.className = 'sw-update-notification';
    notification.innerHTML = `
      <div class="update-content">
        <p>åº”ç”¨æœ‰æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œæ˜¯å¦ç«‹å³æ›´æ–°ï¼Ÿ</p>
        <button onclick="SWManager.refreshApp()">ç«‹å³æ›´æ–°</button>
      </div>
    `;
    
    document.body.appendChild(notification);
  }

  static refreshApp() {
    // è·³è¿‡ç­‰å¾…å¹¶å¼ºåˆ¶æ›´æ–°
    navigator.serviceWorker.getRegistrations().then(registrations => {
      for (let registration of registrations) {
        registration.unregister();
      }
      
      // æ¸…é™¤ç¼“å­˜
      caches.keys().then(names => {
        for (let name of names) {
          caches.delete(name);
        }
      }).then(() => {
        window.location.reload();
      });
    });
  }
}

// åˆå§‹åŒ– SW ç®¡ç†å™¨
const swManager = new SWManager();
```

### 3. WebSocket å®æ—¶é€šçŸ¥

```javascript
// WebSocket ç‰ˆæœ¬æ›´æ–°é€šçŸ¥
class WebSocketVersionNotifier {
  constructor(url) {
    this.url = url;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.connect();
  }

  connect() {
    try {
      this.ws = new WebSocket(this.url);
      
      this.ws.onopen = () => {
        console.log('WebSocket connected for version updates');
        this.reconnectAttempts = 0;
      };

      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        
        if (data.type === 'VERSION_UPDATE') {
          this.handleVersionUpdate(data.payload);
        }
      };

      this.ws.onclose = () => {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
          setTimeout(() => {
            this.reconnectAttempts++;
            this.connect();
          }, 1000 * this.reconnectAttempts); // é€’å¢å»¶è¿Ÿé‡è¿
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
    } catch (error) {
      console.error('Failed to connect WebSocket:', error);
    }
  }

  handleVersionUpdate(payload) {
    const { version, forceUpdate, message } = payload;
    
    if (forceUpdate) {
      // å¼ºåˆ¶æ›´æ–°ï¼Œç›´æ¥åˆ·æ–°é¡µé¢
      setTimeout(() => {
        window.location.reload(true);
      }, 5000); // 5ç§’åè‡ªåŠ¨åˆ·æ–°
      
      this.showForcedUpdateNotification(version, message);
    } else {
      // å¯é€‰æ›´æ–°ï¼Œæç¤ºç”¨æˆ·
      this.showOptionalUpdateNotification(version, message);
    }
  }

  showForcedUpdateNotification(version, message) {
    const notification = document.createElement('div');
    notification.className = 'forced-update-notification';
    notification.innerHTML = `
      <div class="update-content">
        <h3>é‡è¦æ›´æ–°</h3>
        <p>${message || `ç‰ˆæœ¬ ${version} å·²å‘å¸ƒï¼Œéœ€è¦ç«‹å³æ›´æ–°`}</p>
        <p>é¡µé¢å°†åœ¨ <span id="countdown">5</span> ç§’åè‡ªåŠ¨åˆ·æ–°...</p>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    // å€’è®¡æ—¶
    let countdown = 5;
    const countdownElement = document.getElementById('countdown');
    const timer = setInterval(() => {
      countdown--;
      countdownElement.textContent = countdown;
      
      if (countdown <= 0) {
        clearInterval(timer);
      }
    }, 1000);
  }

  showOptionalUpdateNotification(version, message) {
    const notification = document.createElement('div');
    notification.className = 'optional-update-notification';
    notification.innerHTML = `
      <div class="update-content">
        <h3>æ–°ç‰ˆæœ¬å¯ç”¨</h3>
        <p>${message || `æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬: ${version}`}</p>
        <div class="update-actions">
          <button onclick="this.parentElement.parentElement.remove()">ç¨åæ›´æ–°</button>
          <button onclick="window.location.reload(true)">ç«‹å³æ›´æ–°</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(notification);
  }
}

// åˆå§‹åŒ– WebSocket ç‰ˆæœ¬é€šçŸ¥å™¨
const wsNotifier = new WebSocketVersionNotifier('ws://localhost:8080/version-updates');
```

### 4. æ„å»ºæ—¶ç‰ˆæœ¬æ³¨å…¥

```javascript
// webpack.config.js é…ç½®ç¤ºä¾‹
const webpack = require('webpack');
const package = require('./package.json');

module.exports = {
  // ... å…¶ä»–é…ç½®
  plugins: [
    // æ³¨å…¥ç‰ˆæœ¬ä¿¡æ¯åˆ°æ„å»ºä¸­
    new webpack.DefinePlugin({
      'process.env.APP_VERSION': JSON.stringify(package.version),
      'process.env.BUILD_TIME': JSON.stringify(new Date().toISOString())
    }),
    
    // æˆ–è€…ä½¿ç”¨è‡ªå®šä¹‰æ’ä»¶æ³¨å…¥ç‰ˆæœ¬ä¿¡æ¯
    {
      apply: (compiler) => {
        compiler.hooks.emit.tap('VersionInjector', (compilation) => {
          // åœ¨ HTML ä¸­æ³¨å…¥ç‰ˆæœ¬ä¿¡æ¯
          const indexHtml = compilation.assets['index.html'].source();
          const versionedHtml = indexHtml.replace(
            '</head>',
            `<meta name="version" content="${package.version}">
            <meta name="build-time" content="${new Date().toISOString()}">
            </head>`
          );
          
          compilation.assets['index.html'] = {
            source: () => versionedHtml,
            size: () => versionedHtml.length
          };
        });
      }
    }
  ]
};
```

### 5. å®ç”¨çš„ç»¼åˆè§£å†³æ–¹æ¡ˆ

```javascript
// ç»¼åˆç‰ˆæœ¬æ›´æ–°ç®¡ç†å™¨
class AppUpdateManager {
  constructor(options = {}) {
    this.options = {
      checkInterval: 30000,        // æ£€æŸ¥é—´éš” (ms)
      showNotification: true,      // æ˜¯å¦æ˜¾ç¤ºé€šçŸ¥
      autoRefresh: false,          // æ˜¯å¦è‡ªåŠ¨åˆ·æ–°
      refreshDelay: 30000,         // è‡ªåŠ¨åˆ·æ–°å»¶è¿Ÿ (ms)
      ...options
    };
    
    this.currentVersion = this.getVersionFromMeta();
    this.updateAvailable = false;
    this.init();
  }

  init() {
    // ä»å¤šä¸ªæ¥æºè·å–ç‰ˆæœ¬ä¿¡æ¯
    this.checkVersion();
    
    // å®šæœŸæ£€æŸ¥
    setInterval(() => {
      this.checkVersion();
    }, this.options.checkInterval);
    
    // é¡µé¢è·å¾—ç„¦ç‚¹æ—¶æ£€æŸ¥
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        this.checkVersion();
      }
    });
  }

  async checkVersion() {
    try {
      // é€šè¿‡ API è·å–æœ€æ–°ç‰ˆæœ¬
      const response = await fetch('/api/app-info', {
        method: 'GET',
        headers: {
          'Cache-Control': 'no-cache'
        }
      });
      
      const appInfo = await response.json();
      const latestVersion = appInfo.version;
      
      if (this.isNewerVersion(latestVersion)) {
        this.handleUpdateAvailable(latestVersion, appInfo);
      }
    } catch (error) {
      console.error('Version check failed:', error);
    }
  }

  isNewerVersion(newVersion) {
    if (!this.currentVersion) return true;
    
    // ç®€å•çš„ç‰ˆæœ¬æ¯”è¾ƒ (å¯æ‰©å±•ä¸ºè¯­ä¹‰åŒ–ç‰ˆæœ¬æ¯”è¾ƒ)
    return newVersion !== this.currentVersion;
  }

  handleUpdateAvailable(newVersion, appInfo) {
    this.updateAvailable = true;
    
    if (this.options.showNotification) {
      this.showUpdateNotification(newVersion, appInfo);
    }
    
    if (this.options.autoRefresh) {
      setTimeout(() => {
        this.refreshApp();
      }, this.options.refreshDelay);
    }
  }

  showUpdateNotification(newVersion, appInfo) {
    // åˆ›å»ºä¸æ‰“æ‰°ç”¨æˆ·çš„æ›´æ–°æç¤º
    const notification = this.createNotificationElement(newVersion, appInfo);
    document.body.appendChild(notification);
    
    // æ·»åŠ åŠ¨ç”»æ•ˆæœ
    setTimeout(() => {
      notification.classList.add('show');
    }, 100);
  }

  createNotificationElement(newVersion, appInfo) {
    const div = document.createElement('div');
    div.className = 'app-update-banner';
    div.innerHTML = `
      <div class="update-message">
        <span class="update-icon">ğŸ”„</span>
        <span class="update-text">
          åº”ç”¨æœ‰æ–°ç‰ˆæœ¬å¯ç”¨: <strong>v${newVersion}</strong>
          ${appInfo.changelog ? ` - ${appInfo.changelog}` : ''}
        </span>
      </div>
      <div class="update-actions">
        <button class="update-btn" onclick="AppUpdateManager.prototype.refreshApp.call(this)">
          ç«‹å³æ›´æ–°
        </button>
        <button class="dismiss-btn" onclick="this.closest('.app-update-banner').remove()">
          ç¨åæé†’
        </button>
      </div>
    `;
    
    return div;
  }

  refreshApp() {
    // æ¸…é™¤ç¼“å­˜å¹¶åˆ·æ–°
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(registrations => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
    
    // æ¸…é™¤æµè§ˆå™¨ç¼“å­˜
    if ('caches' in window) {
      caches.keys().then(names => {
        return Promise.all(names.map(name => caches.delete(name)));
      }).then(() => {
        window.location.href = window.location.href; // å¼ºåˆ¶åˆ·æ–°
      });
    } else {
      window.location.reload(true);
    }
  }

  getVersionFromMeta() {
    const meta = document.querySelector('meta[name="version"]');
    return meta ? meta.getAttribute('content') : null;
  }
}

// å¯åŠ¨åº”ç”¨æ›´æ–°ç®¡ç†å™¨
const updateManager = new AppUpdateManager({
  checkInterval: 60000,  // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  showNotification: true,
  autoRefresh: false     // ä¸è‡ªåŠ¨åˆ·æ–°ï¼Œè®©ç”¨æˆ·é€‰æ‹©
});
```

### 6. CSS æ ·å¼

```css
/* æ›´æ–°é€šçŸ¥æ ·å¼ */
.app-update-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 12px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 10000;
  transform: translateY(-100%);
  transition: transform 0.3s ease;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.app-update-banner.show {
  transform: translateY(0);
}

.update-message {
  display: flex;
  align-items: center;
  gap: 8px;
}

.update-icon {
  font-size: 18px;
}

.update-actions {
  display: flex;
  gap: 8px;
}

.update-btn, .dismiss-btn {
  padding: 6px 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.update-btn {
  background: white;
  color: #667eea;
  font-weight: bold;
}

.dismiss-btn {
  background: rgba(255,255,255,0.2);
  color: white;
}

.update-btn:hover {
  background: #f0f0f0;
}

.dismiss-btn:hover {
  background: rgba(255,255,255,0.3);
}
```

## æœ€ä½³å®è·µ

1. **æ¸è¿›å¼æ›´æ–°**ï¼šä¼˜å…ˆæ˜¾ç¤ºé€šçŸ¥ï¼Œè®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦æ›´æ–°
2. **æ™ºèƒ½æç¤º**ï¼šåœ¨ç”¨æˆ·å®Œæˆé‡è¦æ“ä½œåæç¤ºæ›´æ–°
3. **ç¼“å­˜æ¸…ç†**ï¼šæ›´æ–°æ—¶æ¸…é™¤æµè§ˆå™¨ç¼“å­˜
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†ç½‘ç»œè¯·æ±‚å¤±è´¥ç­‰å¼‚å¸¸æƒ…å†µ
5. **ç”¨æˆ·ä½“éªŒ**ï¼šé¿å…é¢‘ç¹æ‰“æ‰°ç”¨æˆ·ï¼Œæä¾›"ç¨åæé†’"é€‰é¡¹

## æ€»ç»“

åº”ç”¨ä¸Šçº¿åé€šçŸ¥ç”¨æˆ·åˆ·æ–°é¡µé¢çš„æ–¹æ¡ˆåŒ…æ‹¬ï¼š
- ç‰ˆæœ¬æ£€æŸ¥æœºåˆ¶ï¼šå®šæœŸæ£€æŸ¥æœåŠ¡å™¨ç‰ˆæœ¬ä¿¡æ¯
- Service Workerï¼šåˆ©ç”¨ç¼“å­˜æ§åˆ¶å®ç°æ›´æ–°
- WebSocketï¼šå®æ—¶æ¥æ”¶æ›´æ–°é€šçŸ¥
- æ„å»ºæ—¶æ³¨å…¥ï¼šåœ¨æ„å»ºè¿‡ç¨‹ä¸­æ³¨å…¥ç‰ˆæœ¬ä¿¡æ¯
- ç»¼åˆæ–¹æ¡ˆï¼šç»“åˆå¤šç§æŠ€æœ¯æä¾›æœ€ä½³ç”¨æˆ·ä½“éªŒ

é€‰æ‹©åˆé€‚çš„æ–¹æ¡ˆéœ€è¦æ ¹æ®åº”ç”¨ç±»å‹ã€ç”¨æˆ·ä½¿ç”¨åœºæ™¯å’ŒæŠ€æœ¯æ¶æ„æ¥å†³å®šã€‚
