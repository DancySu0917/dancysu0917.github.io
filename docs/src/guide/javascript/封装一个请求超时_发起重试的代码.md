# 封装一个请求超时，发起重试的代码（了解）
### 标准答案

封装请求超时和重试的代码可以使用Promise和async/await实现。基本思路是：1) 使用Promise.race()比较请求和超时时间，哪个先完成就返回哪个结果；2) 在catch中捕获超时或请求失败的情况；3) 使用递归或循环实现重试机制，设置最大重试次数和重试间隔。常见的实现方式包括使用fetch API配合AbortController控制请求超时，或使用axios等HTTP库的超时配置。

### 深入理解

请求超时和重试机制是前端网络请求的重要组成部分，能够提高应用的健壮性和用户体验。以下是几种实现方式：

**1. 基础超时控制实现：**
```javascript
// 基础超时控制函数
function timeoutPromise(promise, timeoutMs) {
    return new Promise((resolve, reject) => {
        // 设置超时定时器
        const timeoutId = setTimeout(() => {
            reject(new Error(`请求超时 (${timeoutMs}ms)`));
        }, timeoutMs);
        
        // 执行原始请求
        promise
            .then(result => {
                clearTimeout(timeoutId);
                resolve(result);
            })
            .catch(error => {
                clearTimeout(timeoutId);
                reject(error);
            });
    });
}

// 使用示例
async function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        
        if (error.name === 'AbortError') {
            throw new Error(`请求超时 (${timeoutMs}ms)`);
        }
        
        throw error;
    }
}
```

**2. 基础重试机制实现：**
```javascript
// 基础重试函数
async function retryPromise(promiseFn, maxRetries = 3, delay = 1000) {
    let lastError;
    
    for (let i = 0; i <= maxRetries; i++) {
        try {
            return await promiseFn();
        } catch (error) {
            lastError = error;
            
            // 如果是最后一次重试，抛出错误
            if (i === maxRetries) {
                throw lastError;
            }
            
            console.warn(`请求失败，第${i + 1}次重试:`, error.message);
            
            // 等待指定时间后重试
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    
    throw lastError; // 这行代码理论上不会执行
}

// 使用示例
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    return retryPromise(() => fetch(url, options), maxRetries);
}
```

**3. 完整的超时重试封装：**
```javascript
class RequestManager {
    constructor(defaultOptions = {}) {
        this.defaultOptions = {
            timeout: 10000,
            maxRetries: 3,
            retryDelay: 1000,
            exponentialBackoff: true, // 指数退避
            ...defaultOptions
        };
    }
    
    // 创建超时Promise
    createTimeoutPromise(timeoutMs) {
        return new Promise((_, reject) => {
            setTimeout(() => {
                reject(new Error(`请求超时 (${timeoutMs}ms)`));
            }, timeoutMs);
        });
    }
    
    // 指数退避延迟
    exponentialDelay(attempt, baseDelay) {
        return Math.pow(2, attempt) * baseDelay + Math.random() * 100;
    }
    
    // 判断是否应该重试
    shouldRetry(error, attempt, maxRetries) {
        // 只对网络错误和超时错误进行重试
        const retryableErrors = [
            'Failed to fetch',
            'Network Error',
            '请求超时',
            '502', '503', '504' // 服务端临时错误
        ];
        
        const errorMessage = error.message || '';
        const isRetryable = retryableErrors.some(msg => 
            errorMessage.includes(msg)
        );
        
        return isRetryable && attempt < maxRetries;
    }
    
    // 主请求方法
    async request(url, options = {}) {
        const {
            timeout = this.defaultOptions.timeout,
            maxRetries = this.defaultOptions.maxRetries,
            retryDelay = this.defaultOptions.retryDelay,
            exponentialBackoff = this.defaultOptions.exponentialBackoff
        } = options;
        
        let lastError;
        
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                // 创建AbortController用于取消请求
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                
                // 创建请求Promise
                const requestPromise = fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                
                // 使用Promise.race进行超时控制
                const response = await Promise.race([
                    requestPromise,
                    this.createTimeoutPromise(timeout)
                ]);
                
                clearTimeout(timeoutId);
                
                // 检查响应状态
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
                }
                
                return response;
                
            } catch (error) {
                clearTimeout(timeoutId);
                lastError = error;
                
                // 检查是否应该重试
                if (!this.shouldRetry(error, attempt, maxRetries)) {
                    throw error;
                }
                
                console.warn(`请求失败，第${attempt + 1}次重试:`, error.message);
                
                // 计算重试延迟时间
                let delay = exponentialBackoff 
                    ? this.exponentialDelay(attempt, retryDelay)
                    : retryDelay;
                
                // 等待后重试
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        throw lastError;
    }
    
    // 便捷方法
    async get(url, options = {}) {
        return this.request(url, { ...options, method: 'GET' });
    }
    
    async post(url, options = {}) {
        return this.request(url, { ...options, method: 'POST' });
    }
    
    async put(url, options = {}) {
        return this.request(url, { ...options, method: 'PUT' });
    }
    
    async delete(url, options = {}) {
        return this.request(url, { ...options, method: 'DELETE' });
    }
}

// 使用示例
const requestManager = new RequestManager({
    timeout: 8000,
    maxRetries: 3,
    retryDelay: 1000,
    exponentialBackoff: true
});

// 使用封装的请求方法
async function fetchData() {
    try {
        const response = await requestManager.get('/api/data');
        const data = await response.json();
        console.log('请求成功:', data);
        return data;
    } catch (error) {
        console.error('请求失败:', error.message);
        throw error;
    }
}
```

**4. 使用axios的超时重试封装：**
```javascript
import axios from 'axios';

class AxiosRequestManager {
    constructor(defaultOptions = {}) {
        this.axiosInstance = axios.create({
            timeout: defaultOptions.timeout || 10000,
            retry: defaultOptions.maxRetries || 3,
            retryDelay: defaultOptions.retryDelay || 1000,
            ...defaultOptions
        });
        
        // 请求拦截器
        this.axiosInstance.interceptors.request.use(
            config => {
                // 添加请求开始时间
                config.metadata = { startTime: new Date() };
                return config;
            },
            error => Promise.reject(error)
        );
        
        // 响应拦截器
        this.axiosInstance.interceptors.response.use(
            response => {
                // 计算请求耗时
                response.config.metadata.endTime = new Date();
                response.duration = response.config.metadata.endTime - response.config.metadata.startTime;
                return response;
            },
            async error => {
                const config = error.config;
                
                // 检查是否已达到最大重试次数
                if (!config || !config.retry) return Promise.reject(error);
                
                config.retryCount = config.retryCount || 0;
                
                // 检查是否应该重试
                if (config.retryCount >= config.retry) {
                    return Promise.reject(error);
                }
                
                // 检查错误类型是否适合重试
                if (!this.isRetryableError(error)) {
                    return Promise.reject(error);
                }
                
                // 计算重试延迟
                const delay = this.exponentialDelay(config.retryCount, config.retryDelay);
                
                console.warn(`请求失败，${delay}ms后进行第${config.retryCount + 1}次重试`);
                
                // 等待后重试
                await this.delay(delay);
                config.retryCount++;
                
                return this.axiosInstance(config);
            }
        );
    }
    
    // 判断错误是否适合重试
    isRetryableError(error) {
        // 网络错误或服务端临时错误
        return !error.response || 
               (error.response.status >= 500 && error.response.status < 600) ||
               error.code === 'ECONNABORTED' || 
               error.message.includes('timeout') ||
               error.message.includes('Network Error');
    }
    
    // 指数退避延迟
    exponentialDelay(attempt, baseDelay) {
        return Math.pow(2, attempt) * baseDelay + Math.random() * 100;
    }
    
    // 延迟函数
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // 便捷方法
    get(url, config = {}) {
        return this.axiosInstance.get(url, config);
    }
    
    post(url, data, config = {}) {
        return this.axiosInstance.post(url, data, config);
    }
    
    put(url, data, config = {}) {
        return this.axiosInstance.put(url, data, config);
    }
    
    delete(url, config = {}) {
        return this.axiosInstance.delete(url, config);
    }
}

// 使用示例
const axiosManager = new AxiosRequestManager({
    timeout: 10000,
    maxRetries: 3,
    retryDelay: 1000
});

async function fetchUserData(userId) {
    try {
        const response = await axiosManager.get(`/api/users/${userId}`);
        console.log('用户数据:', response.data);
        return response.data;
    } catch (error) {
        console.error('获取用户数据失败:', error.message);
        throw error;
    }
}
```

**5. 高级重试策略：**
```javascript
// 支持多种重试策略的请求管理器
class AdvancedRequestManager {
    constructor() {
        this.strategies = {
            // 固定间隔重试
            fixed: (attempt, baseDelay) => baseDelay,
            
            // 线性增长重试
            linear: (attempt, baseDelay) => attempt * baseDelay,
            
            // 指数退避重试
            exponential: (attempt, baseDelay) => Math.pow(2, attempt) * baseDelay,
            
            // 带抖动的指数退避
            exponentialWithJitter: (attempt, baseDelay) => {
                const exponentialDelay = Math.pow(2, attempt) * baseDelay;
                const jitter = Math.random() * 0.1 * exponentialDelay; // 10%的随机抖动
                return exponentialDelay + jitter;
            }
        };
    }
    
    // 主请求方法，支持自定义重试策略
    async request(url, options = {}) {
        const {
            timeout = 10000,
            maxRetries = 3,
            retryStrategy = 'exponential', // 默认使用指数退避
            baseDelay = 1000,
            shouldRetry = this.defaultShouldRetry
        } = options;
        
        let lastError;
        
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                
                const response = await Promise.race([
                    fetch(url, {
                        ...options,
                        signal: controller.signal
                    }),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error(`请求超时 (${timeout}ms)`)), timeout)
                    )
                ]);
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
                }
                
                return response;
                
            } catch (error) {
                clearTimeout(timeoutId);
                lastError = error;
                
                // 检查是否应该重试
                if (attempt === maxRetries || !shouldRetry(error, attempt, maxRetries)) {
                    throw error;
                }
                
                // 计算重试延迟
                const delay = this.strategies[retryStrategy](attempt, baseDelay);
                
                console.warn(`请求失败 (状态: ${error.message})，${delay}ms后进行第${attempt + 1}次重试`);
                
                // 等待后重试
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        throw lastError;
    }
    
    // 默认重试判断逻辑
    defaultShouldRetry(error, attempt, maxRetries) {
        const retryableStatusCodes = [500, 502, 503, 504, 429]; // 服务端错误和限流
        const retryableErrorMessages = [
            'Failed to fetch',
            'Network Error',
            '请求超时'
        ];
        
        // 检查HTTP状态码
        if (error.status && retryableStatusCodes.includes(error.status)) {
            return true;
        }
        
        // 检查错误消息
        const errorMessage = error.message || '';
        return retryableErrorMessages.some(msg => errorMessage.includes(msg));
    }
}

// 使用不同重试策略的示例
const advancedManager = new AdvancedRequestManager();

// 使用指数退避策略
async function fetchWithExponentialBackoff() {
    try {
        const response = await advancedManager.request('/api/data', {
            method: 'GET',
            retryStrategy: 'exponential',
            maxRetries: 3,
            baseDelay: 1000
        });
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('请求失败:', error.message);
        throw error;
    }
}

// 使用带抖动的指数退避策略
async function fetchWithJitterBackoff() {
    try {
        const response = await advancedManager.request('/api/data', {
            method: 'GET',
            retryStrategy: 'exponentialWithJitter',
            maxRetries: 3,
            baseDelay: 1000
        });
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('请求失败:', error.message);
        throw error;
    }
}
```

**6. 实际应用中的完整封装：**
```javascript
// 生产环境可用的请求封装
class ProductionRequestManager {
    constructor(options = {}) {
        this.options = {
            timeout: options.timeout || 10000,
            maxRetries: options.maxRetries || 3,
            retryDelay: options.retryDelay || 1000,
            exponentialBackoff: options.exponentialBackoff !== false,
            maxRetryDelay: options.maxRetryDelay || 30000, // 最大重试延迟30秒
            retryOnTimeout: options.retryOnTimeout !== false,
            retryOnNetworkError: options.retryOnNetworkError !== false,
            retryOn5xx: options.retryOn5xx !== false,
            retryOn429: options.retryOn429 !== false, // 限流错误
            ...options
        };
        
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            retriedRequests: 0
        };
    }
    
    // 生成请求ID用于追踪
    generateRequestId() {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // 计算重试延迟时间
    calculateRetryDelay(attempt) {
        if (this.options.exponentialBackoff) {
            let delay = Math.pow(2, attempt) * this.options.retryDelay;
            // 添加随机抖动避免惊群效应
            delay = delay + Math.random() * 0.1 * delay;
            // 不超过最大延迟时间
            return Math.min(delay, this.options.maxRetryDelay);
        }
        return this.options.retryDelay;
    }
    
    // 判断是否应该重试
    shouldRetry(error, attempt) {
        if (attempt >= this.options.maxRetries) {
            return false;
        }
        
        const errorMessage = error.message || '';
        
        // 超时错误
        if (this.options.retryOnTimeout && errorMessage.includes('timeout')) {
            return true;
        }
        
        // 网络错误
        if (this.options.retryOnNetworkError && 
            (errorMessage.includes('Failed to fetch') || 
             errorMessage.includes('Network Error'))) {
            return true;
        }
        
        // HTTP状态码错误
        if (error.status) {
            // 5xx服务端错误
            if (this.options.retryOn5xx && error.status >= 500 && error.status < 600) {
                return true;
            }
            // 429限流错误
            if (this.options.retryOn429 && error.status === 429) {
                return true;
            }
        }
        
        return false;
    }
    
    async request(url, options = {}) {
        const requestId = this.generateRequestId();
        this.stats.totalRequests++;
        
        const {
            timeout = this.options.timeout,
            maxRetries = this.options.maxRetries
        } = options;
        
        let lastError;
        let attempt = 0;
        
        while (attempt <= maxRetries) {
            try {
                console.log(`[Request ${requestId}] 尝试第 ${attempt + 1} 次请求: ${url}`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                
                const fetchOptions = {
                    ...options,
                    signal: controller.signal
                };
                
                // 添加默认请求头
                fetchOptions.headers = {
                    'Content-Type': 'application/json',
                    ...fetchOptions.headers
                };
                
                const response = await Promise.race([
                    fetch(url, fetchOptions),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error(`请求超时 (${timeout}ms)`)), timeout)
                    )
                ]);
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    this.stats.successfulRequests++;
                    return response;
                } else {
                    // 创建带状态码的错误对象
                    const error = new Error(`HTTP Error: ${response.status} ${response.statusText}`);
                    error.status = response.status;
                    throw error;
                }
                
            } catch (error) {
                clearTimeout(timeoutId);
                lastError = error;
                
                console.warn(`[Request ${requestId}] 第 ${attempt + 1} 次请求失败:`, error.message);
                
                if (attempt < maxRetries && this.shouldRetry(error, attempt)) {
                    this.stats.retriedRequests++;
                    const delay = this.calculateRetryDelay(attempt);
                    
                    console.log(`[Request ${requestId}] ${delay}ms 后进行第 ${attempt + 2} 次重试`);
                    
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempt++;
                } else {
                    // 不再重试，跳出循环
                    break;
                }
            }
        }
        
        this.stats.failedRequests++;
        console.error(`[Request ${requestId}] 所有重试均失败:`, lastError.message);
        throw lastError;
    }
    
    // 获取统计信息
    getStats() {
        return { ...this.stats };
    }
    
    // 重置统计信息
    resetStats() {
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            retriedRequests: 0
        };
    }
    
    // 便捷方法
    get(url, options = {}) {
        return this.request(url, { ...options, method: 'GET' });
    }
    
    post(url, data, options = {}) {
        return this.request(url, {
            ...options,
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    put(url, data, options = {}) {
        return this.request(url, {
            ...options,
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    delete(url, options = {}) {
        return this.request(url, { ...options, method: 'DELETE' });
    }
}

// 使用示例
const prodRequestManager = new ProductionRequestManager({
    timeout: 10000,
    maxRetries: 3,
    retryDelay: 1000,
    exponentialBackoff: true,
    retryOnTimeout: true,
    retryOnNetworkError: true,
    retryOn5xx: true,
    retryOn429: true
});

// 使用封装的请求方法
async function fetchUserData(userId) {
    try {
        const response = await prodRequestManager.get(`/api/users/${userId}`);
        const userData = await response.json();
        console.log('用户数据获取成功:', userData);
        return userData;
    } catch (error) {
        console.error('获取用户数据失败:', error.message);
        throw error;
    }
}

// 监控请求统计
setInterval(() => {
    const stats = prodRequestManager.getStats();
    console.log('请求统计:', stats);
}, 30000); // 每30秒打印一次统计信息
```

**7. 使用场景和最佳实践：**
```javascript
// 不同场景的配置示例
const requestConfigs = {
    // API请求 - 适合重试
    api: {
        timeout: 10000,
        maxRetries: 3,
        retryDelay: 1000,
        retryOn5xx: true,
        retryOn429: true
    },
    
    // 实时性要求高的请求 - 减少重试
    realtime: {
        timeout: 3000,
        maxRetries: 1,
        retryDelay: 500,
        retryOnTimeout: false // 实时性要求高，不重试超时
    },
    
    // 文件上传 - 增加重试和超时时间
    upload: {
        timeout: 60000, // 上传可能需要更长时间
        maxRetries: 5,
        retryDelay: 2000,
        retryOnNetworkError: true
    },
    
    // 关键业务请求 - 保守重试策略
    critical: {
        timeout: 15000,
        maxRetries: 2,
        retryDelay: 3000,
        retryOn5xx: true
    }
};

// 根据请求类型选择配置
function createRequestManager(requestType = 'api') {
    const config = requestConfigs[requestType] || requestConfigs.api;
    return new ProductionRequestManager(config);
}

// 使用示例
const apiManager = createRequestManager('api');
const uploadManager = createRequestManager('upload');
const realtimeManager = createRequestManager('realtime');

// 并发请求控制
class ConcurrentRequestManager extends ProductionRequestManager {
    constructor(options = {}) {
        super(options);
        this.maxConcurrent = options.maxConcurrent || 6; // 默认最大并发数
        this.runningRequests = 0;
        this.requestQueue = [];
    }
    
    async request(url, options = {}) {
        return new Promise((resolve, reject) => {
            const requestTask = {
                url,
                options,
                resolve,
                reject
            };
            
            if (this.runningRequests < this.maxConcurrent) {
                this.executeRequest(requestTask);
            } else {
                this.requestQueue.push(requestTask);
            }
        });
    }
    
    async executeRequest(task) {
        this.runningRequests++;
        
        try {
            const result = await super.request(task.url, task.options);
            task.resolve(result);
        } catch (error) {
            task.reject(error);
        } finally {
            this.runningRequests--;
            
            // 执行队列中的下一个请求
            if (this.requestQueue.length > 0) {
                const nextTask = this.requestQueue.shift();
                this.executeRequest(nextTask);
            }
        }
    }
}
```

**总结：**
1. 超时控制：使用AbortController或Promise.race实现请求超时
2. 重试机制：根据错误类型决定是否重试，避免无限重试
3. 退避策略：使用指数退避避免服务器压力过大
4. 错误分类：区分网络错误、服务端错误和客户端错误
5. 统计监控：记录请求成功率、重试次数等指标
6. 并发控制：限制并发请求数量，避免资源耗尽
7. 配置灵活：根据不同场景调整超时和重试参数