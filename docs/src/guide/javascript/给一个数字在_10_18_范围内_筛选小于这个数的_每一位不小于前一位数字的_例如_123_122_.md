# 给一个数字在 10^18 范围内，筛选小于这个数的，每一位不小于前一位数字的（例如 123，122，111）？（了解）

**题目**: 给一个数字在 10^18 范围内，筛选小于这个数的，每一位不小于前一位数字的（例如 123，122，111）？（了解）

## 解题思路

这个问题属于数位动态规划（Digit DP）的经典问题。要求找到小于给定数字n的所有"单调不减"数字的个数。

单调不减数字的定义：从左到右每一位数字都不小于前一位数字，如123、111、122等。

## 解决方案

### 方法一：数位DP（推荐）

```javascript
function countMonotoneNumbers(n) {
    // 将数字转换为字符串便于处理每一位
    const strN = n.toString();
    const len = strN.length;
    
    // 记忆化搜索的缓存
    // dp[pos][last][isLimit][isNum] 表示：
    // pos: 当前处理的位置
    // last: 上一位的数字
    // isLimit: 是否受到上界限制
    // isNum: 之前是否填了数字（处理前导零）
    const memo = new Map();
    
    function dp(pos, last, isLimit, isNum) {
        // 递归终止条件
        if (pos === len) {
            return isNum ? 1 : 0; // 如果填了数字则返回1，否则返回0
        }
        
        // 生成记忆化搜索的key
        const key = `${pos}-${last}-${isLimit}-${isNum}`;
        if (memo.has(key)) {
            return memo.get(key);
        }
        
        let result = 0;
        
        // 如果之前没有填数字，可以选择跳过当前位置（前导零）
        if (!isNum) {
            result += dp(pos + 1, 0, false, false);
        }
        
        // 确定当前位可以填的数字范围
        const start = isNum ? 0 : 1; // 如果之前没填数字，可以从0开始；否则从1开始
        const end = isLimit ? parseInt(strN[pos]) : 9; // 如果受限制，则不能超过原数字对应位
        
        // 遍历可填的数字
        for (let digit = start; digit <= end; digit++) {
            // 单调不减的约束：当前位不能小于上一位
            if (isNum && digit < last) {
                continue; // 不满足单调不减条件，跳过
            }
            
            result += dp(
                pos + 1,
                digit,
                isLimit && (digit === end), // 如果当前位等于上限且之前受限制，则继续受限制
                true // 已经填了数字
            );
        }
        
        memo.set(key, result);
        return result;
    }
    
    return dp(0, 0, true, false);
}

// 测试示例
console.log(countMonotoneNumbers(123)); // 计算小于123的单调不减数字个数
```

### 方法二：数学方法

对于这种单调不减的数字，我们可以用组合数学的思想来解决：

```javascript
function countMonotoneNumbersByCombination(n) {
    // 将问题转换为：在0-9这10个数字中选择若干个数字组成单调不减数
    // 这等价于组合问题，可以用插板法解决
    
    // 对于k位数，我们需要从10个数字中选择k个数字，允许重复且要求非递减
    // 这等价于从10+k-1个位置中选择k个位置，即C(10+k-1, k)
    
    const strN = n.toString();
    let total = 0;
    
    // 计算位数小于n的所有单调不减数
    for (let digits = 1; digits < strN.length; digits++) {
        total += combination(9 + digits, digits); // C(9+digits, digits)
    }
    
    // 计算位数等于n但值小于n的单调不减数
    total += countMonotoneWithSameDigits(strN);
    
    return total;
}

function combination(n, r) {
    if (r > n || r < 0) return 0;
    if (r === 0 || r === n) return 1;
    
    // 优化计算，取较小的r
    r = Math.min(r, n - r);
    
    let result = 1;
    for (let i = 0; i < r; i++) {
        result = result * (n - i) / (i + 1);
    }
    
    return Math.round(result);
}

function countMonotoneWithSameDigits(targetStr) {
    // 计算与targetStr位数相同但值小于targetStr的单调不减数个数
    const n = targetStr.length;
    const target = targetStr.split('').map(Number);
    
    let count = 0;
    let lastDigit = 0;
    
    for (let i = 0; i < n; i++) {
        // 当前位可以填的数字范围
        const maxDigit = parseInt(targetStr[i]);
        
        // 计算当前位填小于maxDigit的数字时，后续位能组成的单调不减数个数
        for (let digit = lastDigit; digit < maxDigit; digit++) {
            // 后续i+1到n-1位需要形成单调不减序列，且位数为n-1-i
            count += countMonotoneRemaining(n - 1 - i, digit, 9);
        }
        
        // 如果当前位不能满足单调不减，提前结束
        if (target[i] < lastDigit) {
            break;
        }
        
        lastDigit = target[i];
    }
    
    return count;
}

function countMonotoneRemaining(remainingDigits, minDigit, maxDigit) {
    // 计算remainingDigits位，每位在[minDigit, maxDigit]范围内的单调不减数个数
    // 等价于在(maxDigit - minDigit + 1)种数字中选择remainingDigits个形成非递减序列
    return combination((maxDigit - minDigit + 1) + remainingDigits - 1, remainingDigits);
}
```

## 复杂度分析

- 时间复杂度：O(log n)，其中n是输入数字，因为我们需要处理数字的每一位
- 空间复杂度：O(log n)，用于记忆化搜索的存储

## 关键点总结

1. 这是一个典型的数位DP问题
2. 需要考虑前导零、上界限制和单调不减约束
3. 记忆化搜索是优化重复子问题的关键
4. 对于大数（10^18），暴力枚举是不可行的，必须使用高效的DP方法
