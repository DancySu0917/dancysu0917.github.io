# 什么是内存泄漏？（必会）

**题目**: 什么是内存泄漏？（必会）

## 答案

内存泄漏（Memory Leak）是指程序在运行过程中，已经不再使用的内存没有被释放，导致这部分内存无法被重新利用的现象。在JavaScript中，内存泄漏意味着浏览器无法回收某些本应被释放的内存，随着时间推移，这会导致应用程序的内存占用持续增长，最终可能造成浏览器卡顿、崩溃或性能下降。

### 内存泄漏的原因

1. **意外的全局变量**
   - 没有声明的变量会自动成为全局对象的属性
   - 已声明但忘记初始化的变量也可能成为全局变量

```javascript
function leakyFunction() {
    // 意外的全局变量 - 没有用var/let/const声明
    leakyVariable = "I'm a global variable now!";
}

// 正确写法
function properFunction() {
    let properVariable = "I'm a local variable";
}
```

2. **被遗忘的定时器和回调函数**
   - setInterval/setTimeout引用的回调函数持有外部作用域的引用
   - 事件监听器没有被移除

```javascript
// 问题代码 - 定时器未清理
let myObj = {
    name: 'My Object',
    method: function() {
        console.log(this.name);
    }
};

let intervalId = setInterval(myObj.method, 1000);

// 解决方案 - 记得清理
function setupTimer() {
    let intervalId = setInterval(myObj.method, 1000);
    return intervalId;
}

function cleanupTimer(intervalId) {
    clearInterval(intervalId);
}

// 事件监听器泄漏示例
function attachListener() {
    let element = document.getElementById('myElement');
    let handler = function() {
        // 处理事件
        console.log('Event occurred');
    };
    
    element.addEventListener('click', handler);
    // 如果不移除监听器，element和handler都会被保持在内存中
}

// 正确做法
function attachAndRemoveListener() {
    let element = document.getElementById('myElement');
    let handler = function() {
        console.log('Event occurred');
    };
    
    element.addEventListener('click', handler);
    
    // 在适当的时候移除
    return function() {
        element.removeEventListener('click', handler);
    };
}
```

3. **闭包导致的内存泄漏**
   - 闭包保持对外部函数变量的引用

```javascript
// 问题代码 - 闭包保持大对象引用
function problematicClosure() {
    let largeData = new Array(1000000).fill('data');
    
    return function() {
        // 即使不需要largeData，它也会被保持在内存中
        console.log('Closure function');
    };
}

// 解决方案 - 明确清理不需要的引用
function properClosure() {
    let largeData = new Array(1000000).fill('data');
    
    return function() {
        // 使用完后清理大对象
        largeData = null;
        console.log('Closure function');
    };
}
```

4. **DOM节点引用**
   - 保持对已从DOM中移除的节点的引用

```javascript
// 问题代码
let elements = [];
function addElements() {
    let div = document.createElement('div');
    div.innerHTML = 'Some content';
    document.body.appendChild(div);
    elements.push(div); // 即使div从DOM中移除，这里仍有引用
}

// 解决方案
function manageElements() {
    let elements = [];
    
    function addElement() {
        let div = document.createElement('div');
        div.innerHTML = 'Some content';
        document.body.appendChild(div);
        elements.push(div);
        
        return function removeElement() {
            let index = elements.indexOf(div);
            if (index > -1) {
                elements.splice(index, 1);
            }
            div.remove();
        };
    }
    
    return { addElement };
}
```

### 常见的内存泄漏场景

1. **控制台日志记录对象**
   - 浏览器开发者工具的控制台也会保持对象引用

```javascript
// 问题代码
let largeObject = {
    data: new Array(1000000).fill('data'),
    // ... 其他属性
};

console.log(largeObject); // 控制台会保持对largeObject的引用

// 解决方案 - 避免在生产环境中记录大对象
if (process.env.NODE_ENV === 'development') {
    console.log(largeObject);
}
```

2. **DOM节点移除但仍有JavaScript引用**
   - 从DOM中移除节点但JavaScript中仍持有引用

```javascript
// 问题代码
function attachToDOM() {
    let element = document.getElementById('myElement');
    let button = document.createElement('button');
    button.textContent = 'Click me';
    
    // 事件处理函数可能保持对element的引用
    button.addEventListener('click', function() {
        console.log(element); // 保持对element的引用
    });
    
    element.appendChild(button);
    
    // 即使element从DOM中移除，button仍保持对element的引用
    return button;
}
```

### 如何检测内存泄漏

1. **使用浏览器开发者工具**
   - Memory标签页的Heap Snapshot功能
   - Timeline/Performance面板观察内存使用趋势

2. **代码审查**
   - 检查未清理的事件监听器
   - 检查未清理的定时器
   - 检查不必要的全局变量

3. **使用专门的工具**
   - Chrome DevTools
   - Firefox Memory Tool
   - 第三方性能监控工具

### 预防内存泄漏的最佳实践

1. **及时清理事件监听器**
```javascript
class Component {
    constructor(element) {
        this.element = element;
        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);
    }
    
    handleClick() {
        // 处理点击事件
    }
    
    destroy() {
        // 清理事件监听器
        this.element.removeEventListener('click', this.handleClick);
        this.element = null;
    }
}
```

2. **正确使用闭包**
```javascript
function createCache() {
    const cache = new Map();
    
    return {
        get(key) {
            return cache.get(key);
        },
        set(key, value) {
            cache.set(key, value);
        },
        clear() {
            cache.clear(); // 提供清理方法
        }
    };
}
```

3. **合理使用定时器**
```javascript
class TimerManager {
    constructor() {
        this.timers = new Set();
    }
    
    setInterval(callback, delay) {
        const timerId = setInterval(callback, delay);
        this.timers.add(timerId);
        return timerId;
    }
    
    clearInterval(timerId) {
        clearInterval(timerId);
        this.timers.delete(timerId);
    }
    
    clearAll() {
        this.timers.forEach(timerId => clearInterval(timerId));
        this.timers.clear();
    }
}
```

内存泄漏虽然在现代JavaScript引擎的垃圾回收机制下不那么明显，但在长期运行的应用中仍然是一个重要的性能问题，特别是在移动设备上，需要开发者有意识地避免这些常见的内存泄漏场景。
