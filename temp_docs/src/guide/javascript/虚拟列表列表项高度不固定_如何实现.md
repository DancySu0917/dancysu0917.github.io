# 虚拟列表列表项高度不固定，如何实现？（了解）

**题目**: 虚拟列表列表项高度不固定，如何实现？（了解）

**答案**:

实现高度不固定的虚拟列表是前端性能优化中的一个复杂问题。传统虚拟列表基于固定高度，而可变高度的虚拟列表需要动态计算和缓存每个项目的高度。以下是几种实现方案：

## 1. 预估高度 + 动态调整方案

### 核心思想
- 首次渲染时使用预估高度
- 渲染后测量实际高度并更新缓存
- 根据实际高度调整后续项目的渲染位置

### 实现代码
```javascript
class VariableHeightVirtualList {
    constructor(container, itemHeightEstimate = 50) {
        this.container = container;
        this.itemHeightEstimate = itemHeightEstimate;
        this.heightCache = new Map(); // 缓存已知高度
        this.positionCache = new Map(); // 缓存位置信息
        this.scrollTop = 0;
        this.containerHeight = container.clientHeight;
        
        this.init();
    }
    
    init() {
        // 监听滚动事件
        this.container.addEventListener('scroll', this.handleScroll.bind(this));
    }
    
    // 计算可见区域的起始和结束索引
    calculateVisibleRange() {
        // 根据滚动位置计算需要渲染的项目范围
        const startOffset = this.scrollTop;
        const endOffset = this.scrollTop + this.containerHeight;
        
        // 使用缓存计算起始索引
        let startIndex = 0;
        let currentOffset = 0;
        
        for (let i = 0; i < this.data.length; i++) {
            const height = this.getHeight(i);
            if (currentOffset + height >= startOffset) {
                startIndex = i;
                break;
            }
            currentOffset += height;
        }
        
        // 计算结束索引
        let endIndex = startIndex;
        let tempOffset = currentOffset;
        
        while (tempOffset < endOffset && endIndex < this.data.length) {
            tempOffset += this.getHeight(endIndex);
            endIndex++;
        }
        
        // 增加缓冲区以提高用户体验
        const buffer = 5;
        startIndex = Math.max(0, startIndex - buffer);
        endIndex = Math.min(this.data.length, endIndex + buffer);
        
        return { startIndex, endIndex };
    }
    
    // 获取项目高度（使用缓存或预估值）
    getHeight(index) {
        return this.heightCache.get(index) || this.itemHeightEstimate;
    }
    
    // 更新项目高度并重新计算位置
    updateHeight(index, height) {
        const oldHeight = this.getHeight(index);
        if (oldHeight === height) return;
        
        this.heightCache.set(index, height);
        
        // 清除后续项目的位置缓存
        for (let i = index + 1; i < this.data.length; i++) {
            this.positionCache.delete(i);
        }
    }
    
    // 计算指定索引项目的位置
    getPosition(index) {
        if (this.positionCache.has(index)) {
            return this.positionCache.get(index);
        }
        
        let position = 0;
        for (let i = 0; i < index; i++) {
            position += this.getHeight(i);
        }
        
        this.positionCache.set(index, position);
        return position;
    }
    
    // 获取总高度
    getTotalHeight() {
        let totalHeight = 0;
        for (let i = 0; i < this.data.length; i++) {
            totalHeight += this.getHeight(i);
        }
        return totalHeight;
    }
    
    // 滚动处理
    handleScroll() {
        this.scrollTop = this.container.scrollTop;
        this.render();
    }
    
    // 渲染可见项目
    render() {
        const { startIndex, endIndex } = this.calculateVisibleRange();
        const visibleItems = this.data.slice(startIndex, endIndex);
        
        // 创建或更新容器
        if (!this.contentContainer) {
            this.contentContainer = document.createElement('div');
            this.container.appendChild(this.contentContainer);
        }
        
        // 设置容器总高度以保持滚动条比例
        this.contentContainer.style.height = this.getTotalHeight() + 'px';
        
        // 清空现有内容（或复用DOM节点）
        this.contentContainer.innerHTML = '';
        
        // 渲染可见项目
        let currentTop = this.getPosition(startIndex);
        for (let i = 0; i < visibleItems.length; i++) {
            const index = startIndex + i;
            const item = this.createItem(visibleItems[i], index);
            
            // 设置项目位置
            item.style.position = 'absolute';
            item.style.top = currentTop + 'px';
            item.style.left = '0';
            item.style.right = '0';
            
            this.contentContainer.appendChild(item);
            
            // 在下一个渲染周期测量高度
            setTimeout(() => {
                const actualHeight = item.offsetHeight;
                if (actualHeight !== this.getHeight(index)) {
                    this.updateHeight(index, actualHeight);
                    // 重新渲染以调整布局
                    this.render();
                }
            }, 0);
            
            currentTop += this.getHeight(index);
        }
    }
    
    // 创建单个项目元素
    createItem(itemData, index) {
        const item = document.createElement('div');
        item.className = 'virtual-list-item';
        item.innerHTML = `
            <div class="item-content">
                <h3>${itemData.title}</h3>
                <p>${itemData.content}</p>
            </div>
        `;
        return item;
    }
    
    // 设置数据
    setData(data) {
        this.data = data;
        this.render();
    }
}
```

## 2. ResizeObserver 方案

### 核心思想
使用 ResizeObserver API 监听元素尺寸变化，自动更新高度缓存。

```javascript
class ResizeObserverVirtualList {
    constructor(container) {
        this.container = container;
        this.heightCache = new Map();
        this.resizeObserver = new ResizeObserver(this.handleResize.bind(this));
        this.visibleItems = new Map();
    }
    
    handleResize(entries) {
        for (const entry of entries) {
            const index = parseInt(entry.target.dataset.index);
            const height = entry.contentRect.height;
            
            if (this.heightCache.get(index) !== height) {
                this.heightCache.set(index, height);
                // 触发重新计算和渲染
                this.recalculateLayout();
            }
        }
    }
    
    createItem(itemData, index) {
        const item = document.createElement('div');
        item.className = 'virtual-list-item';
        item.dataset.index = index;
        
        // 将项目添加到观察器
        this.resizeObserver.observe(item);
        
        item.innerHTML = `
            <div class="item-content">
                ${this.renderContent(itemData)}
            </div>
        `;
        
        return item;
    }
    
    renderContent(itemData) {
        // 根据数据渲染内容，可能包含动态内容
        return `
            <h3>${itemData.title}</h3>
            <div class="content">${itemData.content}</div>
            ${itemData.images ? `<img src="${itemData.images}" />` : ''}
        `;
    }
    
    recalculateLayout() {
        // 重新计算布局
        // 这里需要重新计算所有受影响项目的偏移量
        this.render();
    }
}
```

## 3. 基于 React 的实现

### 使用 React 实现可变高度虚拟列表

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';

const VariableHeightVirtualList = ({ data, itemHeightEstimate = 50, itemRenderer }) => {
    const containerRef = useRef(null);
    const [scrollTop, setScrollTop] = useState(0);
    const [containerHeight, setContainerHeight] = useState(400);
    
    // 高度缓存
    const heightCache = useRef(new Map());
    const positionCache = useRef(new Map());
    
    // 计算可见范围
    const calculateVisibleRange = useCallback(() => {
        const startOffset = scrollTop;
        const endOffset = scrollTop + containerHeight;
        
        let startIndex = 0;
        let currentOffset = 0;
        
        for (let i = 0; i < data.length; i++) {
            const height = heightCache.current.get(i) || itemHeightEstimate;
            if (currentOffset + height >= startOffset) {
                startIndex = i;
                break;
            }
            currentOffset += height;
        }
        
        let endIndex = startIndex;
        let tempOffset = currentOffset;
        
        while (tempOffset < endOffset && endIndex < data.length) {
            tempOffset += heightCache.current.get(endIndex) || itemHeightEstimate;
            endIndex++;
        }
        
        const buffer = 5;
        return {
            startIndex: Math.max(0, startIndex - buffer),
            endIndex: Math.min(data.length, endIndex + buffer)
        };
    }, [scrollTop, containerHeight, data, itemHeightEstimate]);
    
    // 获取总高度
    const getTotalHeight = useCallback(() => {
        let total = 0;
        for (let i = 0; i < data.length; i++) {
            total += heightCache.current.get(i) || itemHeightEstimate;
        }
        return total;
    }, [data, itemHeightEstimate]);
    
    // 处理滚动
    const handleScroll = useCallback(() => {
        if (containerRef.current) {
            setScrollTop(containerRef.current.scrollTop);
        }
    }, []);
    
    // 测量子组件高度
    const measureHeight = useCallback((index, element) => {
        if (element && !heightCache.current.has(index)) {
            const height = element.offsetHeight;
            heightCache.current.set(index, height);
        }
    }, []);
    
    const { startIndex, endIndex } = calculateVisibleRange();
    const visibleData = data.slice(startIndex, endIndex);
    
    // 计算起始偏移
    let startOffset = 0;
    for (let i = 0; i < startIndex; i++) {
        startOffset += heightCache.current.get(i) || itemHeightEstimate;
    }
    
    return (
        <div 
            ref={containerRef}
            style={{ 
                height: containerHeight, 
                overflow: 'auto',
                position: 'relative'
            }}
            onScroll={handleScroll}
        >
            <div style={{ 
                height: getTotalHeight(), 
                position: 'relative' 
            }}>
                <div style={{ 
                    position: 'absolute', 
                    top: startOffset,
                    width: '100%'
                }}>
                    {visibleData.map((item, index) => {
                        const globalIndex = startIndex + index;
                        const itemHeight = heightCache.current.get(globalIndex) || itemHeightEstimate;
                        
                        return (
                            <div
                                key={globalIndex}
                                ref={el => measureHeight(globalIndex, el)}
                                style={{ 
                                    height: itemHeight,
                                    minHeight: itemHeight,
                                    width: '100%',
                                    boxSizing: 'border-box'
                                }}
                            >
                                {itemRenderer(item, globalIndex)}
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

// 使用示例
const App = () => {
    const data = Array.from({ length: 1000 }, (_, i) => ({
        id: i,
        title: `Item ${i}`,
        content: `This is content for item ${i}. `.repeat(Math.floor(Math.random() * 5) + 1)
    }));
    
    return (
        <VariableHeightVirtualList
            data={data}
            itemRenderer={(item, index) => (
                <div style={{ padding: '10px', border: '1px solid #ccc', margin: '5px 0' }}>
                    <h3>{item.title}</h3>
                    <p>{item.content}</p>
                </div>
            )}
        />
    );
};
```

## 4. 第三方库方案

### 使用 react-window 库

```jsx
import { VariableSizeList } from 'react-window';

const VariableHeightList = ({ data }) => {
    // 返回指定索引项目的高度
    const getItemSize = (index) => {
        // 可以根据数据返回不同高度，或使用缓存
        return data[index].height || 50;
    };
    
    const Row = ({ index, style }) => (
        <div style={style}>
            <div style={{ padding: '10px' }}>
                {data[index].content}
            </div>
        </div>
    );
    
    return (
        <VariableSizeList
            height={400}
            itemCount={data.length}
            itemSize={getItemSize}
            width="100%"
        >
            {Row}
        </VariableSizeList>
    );
};
```

## 5. 性能优化建议

### 高度缓存策略
```javascript
// 实现 LRU 缓存来管理高度缓存
class HeightCache {
    constructor(maxSize = 1000) {
        this.cache = new Map();
        this.maxSize = maxSize;
    }
    
    get(index) {
        return this.cache.get(index);
    }
    
    set(index, height) {
        if (this.cache.size >= this.maxSize) {
            // 删除最久未使用的项
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(index, height);
    }
    
    clear() {
        this.cache.clear();
    }
}
```

### 预加载策略
```javascript
// 预加载可视区域外的项目
const calculateVisibleRange = (scrollTop, containerHeight, totalItems) => {
    const buffer = 10; // 缓冲区
    const estimatedItemHeight = 50;
    
    const startIndex = Math.floor(scrollTop / estimatedItemHeight) - buffer;
    const endIndex = Math.ceil((scrollTop + containerHeight) / estimatedItemHeight) + buffer;
    
    return {
        startIndex: Math.max(0, startIndex),
        endIndex: Math.min(totalItems, endIndex)
    };
};
```

## 总结

实现高度不固定的虚拟列表的关键点：

1. **高度缓存**：缓存已知项目的高度，避免重复计算
2. **预估机制**：对未测量的项目使用预估高度
3. **动态调整**：测量实际高度后动态调整布局
4. **性能优化**：使用 ResizeObserver、合理的缓冲区等技术
5. **第三方库**：考虑使用成熟的库如 react-window、react-virtualized

这种实现方式可以有效处理大量可变高度数据的展示，提供流畅的滚动体验。
