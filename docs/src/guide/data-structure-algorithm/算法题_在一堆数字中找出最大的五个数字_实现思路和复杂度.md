# 算法题：在一堆数字中找出最大的五个数字，实现思路和复杂度？（了解）

**题目**: 算法题：在一堆数字中找出最大的五个数字，实现思路和复杂度？（了解）

**答案**:

在一堆数字中找出最大的五个数字有多种解法，以下是几种常见的实现思路：

## 方法一：排序法

### 思路：
1. 对整个数组进行排序
2. 取排序后数组的最后5个元素

### 实现：
```javascript
function findTopFiveBySort(arr) {
    if (arr.length < 5) {
        return arr.sort((a, b) => b - a);
    }
    
    const sorted = [...arr].sort((a, b) => b - a);
    return sorted.slice(0, 5);
}

// 测试
console.log(findTopFiveBySort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])); // [9, 6, 5, 5, 5]
```

### 复杂度分析：
- **时间复杂度**: O(n log n)，主要是排序的时间复杂度
- **空间复杂度**: O(n)，需要额外空间存储排序后的数组

## 方法二：维护最小堆（优先队列）

### 思路：
1. 使用大小为5的最小堆
2. 遍历数组，对于每个元素：
   - 如果堆未满，直接加入
   - 如果堆已满且当前元素大于堆顶，则替换堆顶
3. 最后堆中的元素即为最大的5个数字

### 实现：
```javascript
class MinHeap {
    constructor(size) {
        this.heap = [];
        this.size = size;
    }
    
    push(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
        
        if (this.heap.length > this.size) {
            this.pop();
        }
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        
        const top = this.heap[0];
        const last = this.heap.pop();
        
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.bubbleDown(0);
        }
        
        return top;
    }
    
    peek() {
        return this.heap[0] || null;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[parentIndex] <= this.heap[index]) break;
            
            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        const lastIndex = this.heap.length - 1;
        
        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let smallestIndex = index;
            
            if (leftChildIndex <= lastIndex && this.heap[leftChildIndex] < this.heap[smallestIndex]) {
                smallestIndex = leftChildIndex;
            }
            
            if (rightChildIndex <= lastIndex && this.heap[rightChildIndex] < this.heap[smallestIndex]) {
                smallestIndex = rightChildIndex;
            }
            
            if (smallestIndex === index) break;
            
            [this.heap[index], this.heap[smallestIndex]] = [this.heap[smallestIndex], this.heap[index]];
            index = smallestIndex;
        }
    }
}

function findTopFiveByHeap(arr) {
    if (arr.length <= 5) return [...arr].sort((a, b) => b - a);
    
    const minHeap = new MinHeap(5);
    
    for (const num of arr) {
        if (minHeap.heap.length < 5) {
            minHeap.push(num);
        } else if (num > minHeap.peek()) {
            minHeap.pop();
            minHeap.push(num);
        }
    }
    
    // 从堆中取出元素并排序
    const result = [];
    while (minHeap.heap.length > 0) {
        result.push(minHeap.pop());
    }
    
    return result.reverse(); // 从大到小排序
}
```

### 复杂度分析：
- **时间复杂度**: O(n log k)，其中k=5，所以是O(n)
- **空间复杂度**: O(k) = O(1)，因为k是常数

## 方法三：部分排序（快速选择算法变种）

### 思路：
1. 使用快速选择算法找到第5大的元素
2. 找出所有大于等于该元素的数字

### 实现：
```javascript
function findTopFiveByQuickSelect(arr) {
    if (arr.length <= 5) return [...arr].sort((a, b) => b - a);
    
    const nums = [...arr];
    const k = 5;
    
    // 使用快速选择找到第k大的元素
    const kthLargest = quickSelect(nums, 0, nums.length - 1, k);
    
    // 找出所有大于第k大元素的数字
    const result = [];
    const equalElements = [];
    
    for (const num of arr) {
        if (num > kthLargest) {
            result.push(num);
        } else if (num === kthLargest) {
            equalElements.push(num);
        }
    }
    
    // 如果result不足5个，从相等元素中补充
    const remaining = 5 - result.length;
    result.push(...equalElements.slice(0, remaining));
    
    return result.sort((a, b) => b - a);
}

function quickSelect(nums, left, right, k) {
    if (left === right) return nums[left];
    
    const pivotIndex = partition(nums, left, right);
    
    if (k - 1 === pivotIndex) {
        return nums[pivotIndex];
    } else if (k - 1 < pivotIndex) {
        return quickSelect(nums, left, pivotIndex - 1, k);
    } else {
        return quickSelect(nums, pivotIndex + 1, right, k);
    }
}

function partition(nums, left, right) {
    const pivot = nums[right];
    let i = left;
    
    for (let j = left; j < right; j++) {
        if (nums[j] >= pivot) { // 降序排列
            [nums[i], nums[j]] = [nums[j], nums[i]];
            i++;
        }
    }
    
    [nums[i], nums[right]] = [nums[right], nums[i]];
    return i;
}
```

### 复杂度分析：
- **时间复杂度**: 平均 O(n)，最坏 O(n²)
- **空间复杂度**: O(log n)，递归调用栈

## 方法四：简单遍历法（维护5个最大值）

### 思路：
1. 维护一个长度为5的数组，存储当前最大的5个数字
2. 遍历原数组，对于每个元素更新这5个最大值

### 实现：
```javascript
function findTopFiveBySimple(arr) {
    if (arr.length <= 5) return [...arr].sort((a, b) => b - a);
    
    // 初始化前5个元素
    let topFive = [...arr.slice(0, 5)].sort((a, b) => b - a);
    
    // 遍历剩余元素
    for (let i = 5; i < arr.length; i++) {
        const current = arr[i];
        
        // 如果当前元素比最小的还小，跳过
        if (current <= topFive[4]) continue;
        
        // 找到插入位置
        let insertPos = 4;
        while (insertPos > 0 && topFive[insertPos - 1] < current) {
            insertPos--;
        }
        
        // 插入并保持有序
        topFive.splice(insertPos, 0, current);
        topFive.pop(); // 移除最小的元素
    }
    
    return topFive;
}
```

### 复杂度分析：
- **时间复杂度**: O(n)，每次插入最多检查5个元素
- **空间复杂度**: O(1)，只需要固定大小的额外空间

## 总结对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 排序法 | O(n log n) | O(n) | 数据量小，或需要完整排序 |
| 最小堆 | O(n) | O(1) | 数据量大，k较小 |
| 快速选择 | O(n) 平均 | O(log n) | 需要最优平均性能 |
| 简单遍历 | O(n) | O(1) | k非常小且固定 |

对于找最大的5个数字这种场景，**最小堆方法**通常是最佳选择，因为时间复杂度最优，且空间复杂度为常数级。
