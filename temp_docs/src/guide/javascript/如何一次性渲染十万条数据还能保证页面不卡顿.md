# 如何一次性渲染十万条数据还能保证页面不卡顿？（了解）

**题目**: 如何一次性渲染十万条数据还能保证页面不卡顿？（了解）

**答案**:

处理十万条数据的渲染而不卡顿页面，需要采用多种优化策略：

## 1. 虚拟滚动（Virtual Scrolling）

只渲染可视区域内的数据，而不是全部数据：

```javascript
import React, { useState, useEffect, useCallback } from 'react';

const VirtualList = ({ items, itemHeight = 50, containerHeight = 400 }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const [visibleStart, setVisibleStart] = useState(0);
  const [visibleEnd, setVisibleEnd] = useState(0);

  // 计算可视区域的起始和结束索引
  useEffect(() => {
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(start + visibleCount + 5, items.length); // 多渲染几项防止空白
    
    setVisibleStart(start);
    setVisibleEnd(end);
  }, [scrollTop, containerHeight, itemHeight, items.length]);

  const visibleItems = items.slice(visibleStart, visibleEnd);
  
  return (
    <div 
      style={{ 
        height: containerHeight, 
        overflowY: 'auto', 
        position: 'relative' 
      }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ 
        height: items.length * itemHeight, 
        position: 'relative' 
      }}>
        <div style={{ 
          transform: `translateY(${visibleStart * itemHeight}px)`,
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%'
        }}>
          {visibleItems.map((item, index) => (
            <div 
              key={visibleStart + index}
              style={{ 
                height: itemHeight, 
                lineHeight: `${itemHeight}px`,
                borderBottom: '1px solid #eee'
              }}
            >
              {item}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

## 2. 时间切片（Time Slicing）

使用 requestIdleCallback 或 requestAnimationFrame 分批渲染：

```javascript
class BatchRenderer {
  constructor(items, renderCallback, batchSize = 100) {
    this.items = items;
    this.renderCallback = renderCallback;
    this.batchSize = batchSize;
    this.currentIndex = 0;
  }

  render() {
    const startTime = performance.now();
    
    while (this.currentIndex < this.items.length && 
           performance.now() - startTime < 16) { // 每帧最多占用16ms
      
      const batch = this.items.slice(
        this.currentIndex, 
        this.currentIndex + this.batchSize
      );
      
      this.renderCallback(batch, this.currentIndex);
      this.currentIndex += batch.length;
      
      if (this.currentIndex < this.items.length) {
        // 让出控制权给主线程
        setTimeout(() => this.render(), 0);
        break;
      }
    }
    
    if (this.currentIndex >= this.items.length) {
      console.log('所有数据渲染完成');
    }
  }
}

// 使用示例
const renderer = new BatchRenderer(
  largeDataArray,
  (batch, startIndex) => {
    // 批量渲染逻辑
    batch.forEach((item, index) => {
      const element = document.createElement('div');
      element.textContent = item;
      document.getElementById('container').appendChild(element);
    });
  }
);

renderer.render();
```

## 3. 使用 Web Workers

将数据处理逻辑放到 Web Worker 中，避免阻塞主线程：

```javascript
// main.js
const worker = new Worker('data-processor.js');

worker.postMessage({
  type: 'PROCESS_DATA',
  data: largeDataArray
});

worker.onmessage = (e) => {
  const { processedData } = e.data;
  // 在主线程中渲染处理后的数据
  renderData(processedData);
};

// data-processor.js
self.onmessage = (e) => {
  if (e.data.type === 'PROCESS_DATA') {
    const processedData = e.data.data.map(item => {
      // 复杂的数据处理逻辑
      return processItem(item);
    });
    
    self.postMessage({ processedData });
  }
};
```

## 4. 分页渲染

将大数据集分成小批次渲染：

```javascript
const usePaginatedRender = (data, itemsPerPage = 1000) => {
  const [currentPage, setCurrentPage] = useState(0);
  const [renderedData, setRenderedData] = useState([]);

  const totalPages = Math.ceil(data.length / itemsPerPage);

  useEffect(() => {
    const start = currentPage * itemsPerPage;
    const end = Math.min(start + itemsPerPage, data.length);
    const newData = data.slice(start, end);
    
    setRenderedData(prev => [...prev, ...newData]);
  }, [currentPage]);

  const loadNextPage = () => {
    if (currentPage < totalPages - 1) {
      setCurrentPage(prev => prev + 1);
    }
  };

  return { renderedData, loadNextPage, hasMore: currentPage < totalPages - 1 };
};
```

## 5. 数据结构优化

使用更高效的数据结构：

```javascript
// 使用 DocumentFragment 减少 DOM 操作
function renderBatchEfficiently(items) {
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const element = document.createElement('div');
    element.textContent = item;
    fragment.appendChild(element);
  });
  
  document.getElementById('container').appendChild(fragment);
}

// 使用 CSS transform 而不是改变布局属性
function updatePosition(element, x, y) {
  element.style.transform = `translate(${x}px, ${y}px)`; // 不会触发重排
}
```

## 6. React 中的优化

使用 React.memo、useMemo 和虚拟滚动库：

```jsx
import { FixedSizeList as List } from 'react-window';

const OptimizedList = React.memo(({ items }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index]}
    </div>
  );

  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  );
});
```

## 核心原则

1. **避免一次性渲染大量 DOM 元素**
2. **利用浏览器空闲时间处理数据**
3. **将重计算任务移出主线程**
4. **只渲染可视区域的内容**
5. **使用高效的 DOM 操作方法**

这些策略可以单独使用，也可以组合使用，根据具体场景选择最合适的方案。
