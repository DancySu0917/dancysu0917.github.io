# 如何统计长任务时间、长任务执行次数？（了解）

**题目**: 如何统计长任务时间、长任务执行次数？（了解）

**答案**:

长任务（Long Tasks）是指执行时间超过50毫秒的任务，它们会阻塞主线程，影响用户体验。以下是统计长任务时间与执行次数的方法：

## 1. 使用 Long Tasks API

Long Tasks API 是专门用于检测长任务的浏览器 API：

```javascript
// 检测长任务
if ('PerformanceObserver' in window) {
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      console.log('长任务检测到：', {
        name: entry.name,
        entryType: entry.entryType,
        startTime: entry.startTime,
        duration: entry.duration,
        containerType: entry.containerType,
        containerSrc: entry.containerSrc,
        containerId: entry.containerId,
        containerName: entry.containerName
      });

      // 统计长任务
      trackLongTask(entry);
    });
  });

  observer.observe({ entryTypes: ['longtask'] });
}

// 长任务统计函数
let longTaskCount = 0;
let totalLongTaskDuration = 0;

function trackLongTask(entry) {
  longTaskCount++;
  totalLongTaskDuration += entry.duration;
  
  console.log(`长任务 #${longTaskCount}: ${entry.duration}ms`);
  console.log(`平均长任务时长: ${(totalLongTaskDuration / longTaskCount).toFixed(2)}ms`);
}
```

## 2. 自定义长任务检测

使用 Performance API 手动检测长任务：

```javascript
class LongTaskTracker {
  constructor() {
    this.longTaskCount = 0;
    this.longTaskDurations = [];
    this.threshold = 50; // 50ms 阈值
    this.isTracking = false;
  }

  startTracking() {
    if (this.isTracking) return;
    
    this.isTracking = true;
    this.lastTime = performance.now();
    
    // 使用 requestAnimationFrame 检测长任务
    const checkFrame = () => {
      const currentTime = performance.now();
      const frameTime = currentTime - this.lastTime;
      
      if (frameTime > this.threshold) {
        this.handleLongTask(frameTime);
      }
      
      this.lastTime = currentTime;
      
      if (this.isTracking) {
        requestAnimationFrame(checkFrame);
      }
    };
    
    requestAnimationFrame(checkFrame);
  }

  handleLongTask(duration) {
    this.longTaskCount++;
    this.longTaskDurations.push(duration);
    
    console.log(`检测到长任务: ${duration.toFixed(2)}ms`);
    
    // 触发自定义事件
    const event = new CustomEvent('longtask', {
      detail: {
        duration: duration,
        count: this.longTaskCount,
        timestamp: performance.now()
      }
    });
    
    window.dispatchEvent(event);
  }

  getStats() {
    if (this.longTaskDurations.length === 0) {
      return {
        count: 0,
        average: 0,
        max: 0,
        min: 0
      };
    }

    const sum = this.longTaskDurations.reduce((a, b) => a + b, 0);
    const avg = sum / this.longTaskDurations.length;
    const max = Math.max(...this.longTaskDurations);
    const min = Math.min(...this.longTaskDurations);

    return {
      count: this.longTaskCount,
      average: avg,
      max: max,
      min: min
    };
  }

  stopTracking() {
    this.isTracking = false;
  }
}

// 使用示例
const tracker = new LongTaskTracker();
tracker.startTracking();

// 监听长任务事件
window.addEventListener('longtask', (event) => {
  console.log('长任务详情:', event.detail);
});

// 获取统计信息
setTimeout(() => {
  console.log('长任务统计:', tracker.getStats());
}, 10000);
```

## 3. 使用 PerformanceObserver 监控多种性能指标

```javascript
class ComprehensiveTaskTracker {
  constructor() {
    this.stats = {
      longTasks: [],
      totalLongTaskTime: 0,
      blockingTime: 0,
      taskCount: 0
    };
  }

  init() {
    // 监控长任务
    if ('PerformanceObserver' in window) {
      // 长任务观察器
      const longTaskObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.stats.longTasks.push({
            duration: entry.duration,
            startTime: entry.startTime,
            name: entry.name,
            container: entry.containerType
          });
          
          this.stats.totalLongTaskTime += entry.duration;
          this.stats.taskCount++;
        });
      });
      
      // 监控其他性能指标
      const allObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.duration > 50) { // 超过50ms的任务
            this.stats.blockingTime += entry.duration - 16; // 减去一帧时间(16ms)
          }
        });
      });

      longTaskObserver.observe({ entryTypes: ['longtask'] });
      allObserver.observe({ entryTypes: ['measure', 'navigation', 'resource'] });
    }
  }

  getReport() {
    const avgDuration = this.stats.totalLongTaskTime / (this.stats.taskCount || 1);
    
    return {
      longTaskCount: this.stats.taskCount,
      totalLongTaskTime: this.stats.totalLongTaskTime,
      averageLongTaskDuration: avgDuration,
      blockingTime: this.stats.blockingTime,
      longTasks: this.stats.longTasks
    };
  }

  // 发送统计到服务器
  sendReport() {
    const report = this.getReport();
    
    // 使用 sendBeacon 确保数据发送
    if (navigator.sendBeacon) {
      navigator.sendBeacon(
        '/api/performance-metrics',
        JSON.stringify({
          type: 'long-tasks',
          data: report,
          timestamp: Date.now(),
          url: window.location.href
        })
      );
    } else {
      // 降级处理
      fetch('/api/performance-metrics', {
        method: 'POST',
        body: JSON.stringify({
          type: 'long-tasks',
          data: report,
          timestamp: Date.now()
        }),
        headers: { 'Content-Type': 'application/json' }
      }).catch(() => {
        // 忽略错误
      });
    }
  }
}

// 初始化并使用
const perfTracker = new ComprehensiveTaskTracker();
perfTracker.init();

// 页面卸载时发送报告
window.addEventListener('beforeunload', () => {
  perfTracker.sendReport();
});
```

## 4. 实时监控和告警

```javascript
class LongTaskMonitor {
  constructor(options = {}) {
    this.threshold = options.threshold || 50;
    this.sampleInterval = options.sampleInterval || 1000; // 1秒采样一次
    this.alertThreshold = options.alertThreshold || 5; // 每秒超过5个长任务时告警
    this.isMonitoring = false;
    
    this.currentPeriodTasks = 0;
    this.currentPeriodStart = 0;
    this.taskHistory = [];
  }

  start() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.currentPeriodStart = performance.now();
    
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration >= this.threshold) {
          this.handleLongTask(entry);
        }
      });
    });
    
    observer.observe({ entryTypes: ['longtask'] });
    
    // 定期检查长任务频率
    this.checkInterval = setInterval(() => {
      this.checkTaskFrequency();
    }, this.sampleInterval);
  }

  handleLongTask(entry) {
    this.currentPeriodTasks++;
    
    // 记录任务历史
    this.taskHistory.push({
      timestamp: performance.now(),
      duration: entry.duration,
      container: entry.containerType
    });
    
    // 保持历史记录在合理范围内
    const now = performance.now();
    this.taskHistory = this.taskHistory.filter(task => 
      now - task.timestamp < 60000 // 只保留最近1分钟的记录
    );
  }

  checkTaskFrequency() {
    const currentTime = performance.now();
    const tasksInLastPeriod = this.taskHistory.filter(task => 
      currentTime - task.timestamp <= this.sampleInterval
    ).length;
    
    if (tasksInLastPeriod > this.alertThreshold) {
      console.warn(`警告：在最近${this.sampleInterval/1000}秒内检测到${tasksInLastPeriod}个长任务`);
      
      // 触发告警事件
      const alertEvent = new CustomEvent('longtask-alert', {
        detail: {
          count: tasksInLastPeriod,
          period: this.sampleInterval,
          threshold: this.alertThreshold
        }
      });
      
      window.dispatchEvent(alertEvent);
    }
    
    this.currentPeriodTasks = 0;
    this.currentPeriodStart = currentTime;
  }

  stop() {
    this.isMonitoring = false;
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }

  getStats() {
    return {
      totalLongTasks: this.taskHistory.length,
      tasksInLastMinute: this.taskHistory.filter(task => 
        performance.now() - task.timestamp <= 60000
      ).length,
      averageDuration: this.taskHistory.length > 0 
        ? this.taskHistory.reduce((sum, task) => sum + task.duration, 0) / this.taskHistory.length
        : 0,
      maxDuration: this.taskHistory.length > 0
        ? Math.max(...this.taskHistory.map(task => task.duration))
        : 0
    };
  }
}

// 使用示例
const monitor = new LongTaskMonitor({
  threshold: 50,
  sampleInterval: 1000,
  alertThreshold: 3
});

monitor.start();

// 监听告警事件
window.addEventListener('longtask-alert', (event) => {
  console.log('长任务告警:', event.detail);
});

// 定期获取统计信息
setInterval(() => {
  console.log('长任务统计:', monitor.getStats());
}, 5000);
```

## 5. 工具和库推荐

- **web-vitals**: Google 提供的性能监控库
- **Lighthouse**: 提供长任务分析
- **PageSpeed Insights**: 包含长任务信息
- **Chrome DevTools**: Performance 面板可以可视化长任务

## 关键要点

1. **阈值设定**：长任务通常定义为超过50ms的任务
2. **实时监控**：使用 PerformanceObserver 实现实时检测
3. **数据收集**：记录长任务的次数、时长、发生时间等信息
4. **性能优化**：根据长任务数据优化代码，如使用 Web Workers、代码分割等
5. **用户体验**：长任务会影响页面响应性，需要及时处理

通过这些方法，可以有效地监控和统计长任务，帮助优化应用性能。
