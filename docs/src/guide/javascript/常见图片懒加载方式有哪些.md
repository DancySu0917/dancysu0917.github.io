# 常见图片懒加载方式有哪些？（了解）

**题目**: 常见图片懒加载方式有哪些？（了解）

**答案**:

图片懒加载是一种优化网页性能的技术，只在图片即将进入视口时才加载图片，从而减少初始页面加载时间、节省带宽和提升用户体验。以下是常见的图片懒加载方式：

## 1. 基于滚动事件的懒加载

### 原理
监听滚动事件，计算图片位置与视口的关系，当图片进入视口时加载图片。

### 实现示例
```javascript
function lazyLoadImages() {
    const images = document.querySelectorAll('img[data-src]');
    
    images.forEach(img => {
        // 判断图片是否在视口内
        if (isInViewport(img)) {
            loadImage(img);
        }
    });
}

function isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= window.innerHeight &&
        rect.right <= window.innerWidth
    );
}

function loadImage(img) {
    // 将 data-src 的值赋给 src 属性
    img.src = img.dataset.src;
    img.removeAttribute('data-src');
    
    // 添加加载完成的回调
    img.onload = () => {
        img.classList.add('loaded');
    };
}

// 监听滚动事件（建议使用防抖优化）
window.addEventListener('scroll', throttle(lazyLoadImages, 200));

// 页面加载完成后立即检查
document.addEventListener('DOMContentLoaded', lazyLoadImages);
```

## 2. Intersection Observer API

### 优势
- 性能更好，浏览器原生支持
- 不需要手动计算位置
- 自动处理元素可见性变化

### 实现示例
```javascript
const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            // 加载图片
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            
            // 图片加载完成后停止观察
            img.onload = () => {
                img.classList.add('loaded');
                observer.unobserve(img);
            };
        }
    });
});

// 观察所有需要懒加载的图片
document.querySelectorAll('img[data-src]').forEach(img => {
    imageObserver.observe(img);
});
```

## 3. 基于 CSS 的懒加载

### 使用 CSS 渐进显示
```css
/* 占位符样式 */
img.lazy {
    background-color: #f0f0f0;
    opacity: 0.8;
    transition: opacity 0.3s;
}

img.lazy.loaded {
    opacity: 1;
}

/* 使用 CSS 实现淡入效果 */
img.lazy.fade-in {
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
}

img.lazy.fade-in.loaded {
    opacity: 1;
}
```

## 4. 使用 loading="lazy" 属性

### HTML 原生懒加载
```html
<!-- 原生懒加载，浏览器支持度越来越好 -->
<img src="image.jpg" loading="lazy" alt="描述文字">
```

### 属性值说明
- `auto`: 默认值，由浏览器决定是否懒加载
- `lazy`: 延迟加载，直到元素接近视口时才加载
- `eager`: 立即加载，不延迟

## 5. 预加载与懒加载结合

### 预加载关键图片
```javascript
// 预加载即将进入视口的图片
function preloadImage(src) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = reject;
        img.src = src;
    });
}

// 在用户滚动时预加载即将显示的图片
const preloadObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            const preloadSrc = img.dataset.preloadSrc;
            
            if (preloadSrc) {
                preloadImage(preloadSrc).then(() => {
                    // 预加载完成后，再实际加载图片
                    img.src = preloadSrc;
                });
            }
        }
    });
}, {
    rootMargin: '100px' // 提前100px开始预加载
});
```

## 6. 渐进式图片加载

### 低质量图片占位符 (LQIP)
```html
<div class="image-container">
    <!-- 低质量图片作为占位符 -->
    <img class="low-quality" src="thumbnail.jpg" alt="">
    <!-- 高质量图片懒加载 -->
    <img class="high-quality" data-src="high-quality.jpg" alt="">
</div>
```

```css
.image-container {
    position: relative;
    overflow: hidden;
}

.low-quality {
    filter: blur(5px);
    width: 100%;
    height: auto;
}

.high-quality {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 0;
    transition: opacity 0.3s;
}

.high-quality.loaded {
    opacity: 1;
}
```

## 7. 第三方库实现

### 使用 lozad.js
```javascript
import { lozad } from 'lozad';

// 使用 Intersection Observer
const observer = lozad(); // 初始化
observer.observe(); // 观察并处理元素
```

### 使用 vanilla-lazyload
```javascript
import LazyLoad from "vanilla-lazyload";

const lazyLoad = new LazyLoad({
    elements_selector: ".lazy",
    threshold: 0,
    callback_error: (el) => {
        el.src = 'placeholder.jpg';
    }
});
```

## 8. React 中的懒加载实现

### 使用 React.lazy 和 Suspense
```jsx
import { lazy, Suspense } from 'react';

const LazyImage = lazy(() => import('./LazyImage'));

function ImageContainer() {
    return (
        <Suspense fallback={<div>Loading image...</div>}>
            <LazyImage src="image.jpg" alt="Lazy loaded" />
        </Suspense>
    );
}
```

### 自定义 Hook 实现
```jsx
import { useState, useEffect } from 'react';

function useImageOnLoad(src) {
    const [loaded, setLoaded] = useState(false);
    
    useEffect(() => {
        const img = new Image();
        img.onload = () => setLoaded(true);
        img.src = src;
    }, [src]);
    
    return loaded;
}

function LazyImage({ src, alt, placeholder }) {
    const loaded = useImageOnLoad(src);
    
    return (
        <div className="lazy-image">
            {!loaded && <img src={placeholder} alt={alt} className="placeholder" />}
            {loaded && <img src={src} alt={alt} className="loaded" />}
        </div>
    );
}
```

## 懒加载的最佳实践

### 1. 提前加载策略
- 设置合适的 `rootMargin` 来提前加载即将进入视口的图片
- 考虑用户滚动速度调整预加载距离

### 2. 错误处理
- 为懒加载失败的图片提供 fallback
- 实现重试机制

### 3. 性能优化
- 使用防抖或节流避免频繁计算
- 对于大量图片，考虑使用虚拟滚动

### 4. 用户体验
- 提供加载指示器
- 实现平滑的过渡效果

选择合适的懒加载方式取决于项目需求、浏览器兼容性要求和性能目标。Intersection Observer API 是现代浏览器推荐的方式，而原生 `loading="lazy"` 属性是未来的发展趋势。
