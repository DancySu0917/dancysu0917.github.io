# 算法题：从起端点开始计数，下一步是最大步长内第一个数值为正的节点，全是负数的话就是最大负数节点，一直计数？（了解）

**题目**: 算法题：从起端点开始计数，下一步是最大步长内第一个数值为正的节点，全是负数的话就是最大负数节点，一直计数？（了解）

**答案**:

这个问题描述的是一个路径选择算法，从起始点开始，每次在最大步长范围内选择下一个节点。如果范围内有正值节点，则选择第一个正值节点；如果没有正值节点，则选择最大的负值节点。

## 算法思路

1. 从起始位置开始
2. 在最大步长范围内查找下一个节点
3. 如果存在正值节点，选择第一个正值节点
4. 如果全是负值节点，选择其中最大的负值节点
5. 重复以上过程直到无法继续

## 实现代码

```javascript
function findPath(nums, maxStep, startPos = 0) {
    if (!nums || nums.length === 0) return [];
    
    const result = [startPos];
    let currentPos = startPos;
    
    while (currentPos < nums.length - 1) {
        // 确定下一步的范围
        const nextStart = currentPos + 1;
        const nextEnd = Math.min(currentPos + maxStep, nums.length - 1);
        
        if (nextStart > nums.length - 1) break;
        
        // 在范围内查找第一个正值节点
        let nextPos = -1;
        
        // 首先尝试找正值节点
        for (let i = nextStart; i <= nextEnd; i++) {
            if (nums[i] > 0) {
                nextPos = i;
                break;
            }
        }
        
        // 如果没有找到正值节点，则找最大的负值节点
        if (nextPos === -1) {
            let maxNegativeValue = -Infinity;
            for (let i = nextStart; i <= nextEnd; i++) {
                if (nums[i] > maxNegativeValue) {
                    maxNegativeValue = nums[i];
                    nextPos = i;
                }
            }
        }
        
        // 如果没有找到合适的节点，结束循环
        if (nextPos === -1) break;
        
        result.push(nextPos);
        currentPos = nextPos;
    }
    
    return result;
}

// 示例使用
const nums1 = [1, -2, 3, -4, 5, -6, 7];
const maxStep1 = 2;
console.log(findPath(nums1, maxStep1)); // [0, 2, 4, 6] - 从索引0开始，每次选择最大步长内第一个正值

const nums2 = [-1, -2, -3, -4, -5];
const maxStep2 = 2;
console.log(findPath(nums2, maxStep2)); // [0, 2, 4] - 全是负值，选择最大的负值节点
```

## 优化版本（使用贪心算法）

如果我们希望找到一个更优化的路径（例如能最快到达终点），可以使用以下方法：

```javascript
function findOptimalPath(nums, maxStep, startPos = 0) {
    if (!nums || nums.length === 0) return [];
    
    const n = nums.length;
    const dp = new Array(n).fill(Infinity);
    const parent = new Array(n).fill(-1);
    
    dp[startPos] = 0;
    
    for (let i = startPos; i < n; i++) {
        if (dp[i] === Infinity) continue;
        
        // 在最大步长范围内尝试所有可能的下一步
        for (let j = i + 1; j <= Math.min(i + maxStep, n - 1); j++) {
            // 计算从i到j的代价
            let cost = 1; // 基本步数代价
            
            if (nums[j] > 0) {
                // 如果目标节点是正值，给予奖励
                cost -= 0.5;
            }
            
            if (dp[i] + cost < dp[j]) {
                dp[j] = dp[i] + cost;
                parent[j] = i;
            }
        }
    }
    
    // 重构路径
    const path = [];
    let current = n - 1;
    
    while (current !== -1) {
        path.unshift(current);
        current = parent[current];
    }
    
    return path;
}

// 另一种按题目要求的精确实现
function findPathExact(nums, maxStep, startPos = 0) {
    if (!nums || nums.length === 0) return [];
    
    const path = [startPos];
    let current = startPos;
    
    while (current < nums.length - 1) {
        const startRange = current + 1;
        const endRange = Math.min(current + maxStep, nums.length - 1);
        
        if (startRange > nums.length - 1) break;
        
        let nextIndex = -1;
        let hasPositive = false;
        
        // 先查找第一个正值
        for (let i = startRange; i <= endRange; i++) {
            if (nums[i] > 0) {
                nextIndex = i;
                hasPositive = true;
                break;
            }
        }
        
        // 如果没有正值，找最大负值
        if (!hasPositive) {
            let maxValue = -Infinity;
            for (let i = startRange; i <= endRange; i++) {
                if (nums[i] > maxValue) {
                    maxValue = nums[i];
                    nextIndex = i;
                }
            }
        }
        
        if (nextIndex === -1) break;
        
        path.push(nextIndex);
        current = nextIndex;
    }
    
    return path;
}

// 测试用例
const testNums = [1, -3, 2, -1, 4, -2, 5];
const testMaxStep = 3;
console.log("数组:", testNums);
console.log("最大步长:", testMaxStep);
console.log("路径:", findPathExact(testNums, testMaxStep));

// 复杂度分析
// 时间复杂度: O(n * maxStep)，其中n是数组长度
// 空间复杂度: O(1)，只使用了常数额外空间
```

## 算法复杂度

- 时间复杂度：O(n × maxStep)，其中n是数组长度，最坏情况下需要检查每个位置的最大步长范围
- 空间复杂度：O(1)，除了输出数组外只使用了常数空间

## 应用场景

这种算法可以应用于：
1. 游戏中的路径规划
2. 资源分配策略
3. 投资决策模型
4. 优化问题的贪心策略
