# 一般是怎么做代码重构的？（了解）

**题目**: 一般是怎么做代码重构的？（了解）

## 答案

代码重构是改善现有代码结构、提高可读性、可维护性和性能的过程，而不改变其外部行为。以下是进行代码重构的系统性方法：

### 1. 重构前的准备工作

```javascript
// 重构前的状态评估
class CodeAssessment {
  static evaluateCodeQuality(codeBase) {
    return {
      complexity: this.calculateComplexity(codeBase),
      testCoverage: this.getTestCoverage(codeBase),
      codeSmells: this.identifyCodeSmells(codeBase),
      performanceIssues: this.findPerformanceIssues(codeBase)
    };
  }
  
  static calculateComplexity(code) {
    // 计算圈复杂度、嵌套深度等指标
    return {
      cyclomaticComplexity: this.getCyclomaticComplexity(code),
      nestingDepth: this.getMaxNestingDepth(code)
    };
  }
}
```

### 2. 制定重构计划

**优先级排序**：
- 高风险区域（频繁出错的代码）
- 核心业务逻辑
- 难以理解的代码块
- 性能瓶颈

### 3. 确保测试覆盖

```javascript
// 重构前确保有足够的测试
describe('重构前的测试用例', () => {
  test('功能A的正常流程', () => {
    // 确保现有功能正常工作
    expect(originalFunction(input)).toBe(expectedOutput);
  });
  
  test('功能A的边界情况', () => {
    // 测试边界情况
    expect(originalFunction(edgeCase)).toBe(expectedOutput);
  });
});
```

### 4. 常见重构技术

#### 提取函数/方法

```javascript
// 重构前：大函数
function processOrder(order) {
  // 验证订单
  if (!order.id || order.amount <= 0) {
    throw new Error('Invalid order');
  }
  
  // 计算折扣
  let discount = 0;
  if (order.customer.type === 'VIP') {
    discount = order.amount * 0.1;
  }
  
  // 计算税费
  const tax = (order.amount - discount) * 0.08;
  
  // 保存订单
  return {
    ...order,
    discount,
    tax,
    total: order.amount - discount + tax
  };
}

// 重构后：提取函数
function processOrder(order) {
  validateOrder(order);
  const discount = calculateDiscount(order);
  const tax = calculateTax(order, discount);
  
  return {
    ...order,
    discount,
    tax,
    total: order.amount - discount + tax
  };
}

function validateOrder(order) {
  if (!order.id || order.amount <= 0) {
    throw new Error('Invalid order');
  }
}

function calculateDiscount(order) {
  if (order.customer.type === 'VIP') {
    return order.amount * 0.1;
  }
  return 0;
}

function calculateTax(order, discount) {
  return (order.amount - discount) * 0.08;
}
```

#### 提取类/模块

```javascript
// 重构前：职责不清晰的类
class OrderManager {
  // 处理订单逻辑
  calculateTotal(order) { /* ... */ }
  
  // 处理支付逻辑
  processPayment(order) { /* ... */ }
  
  // 处理通知逻辑
  sendNotification(order) { /* ... */ }
  
  // 处理数据存储
  saveOrder(order) { /* ... */ }
}

// 重构后：职责单一的类
class OrderCalculator {
  calculateTotal(order) { /* ... */ }
}

class PaymentProcessor {
  processPayment(order) { /* ... */ }
}

class NotificationService {
  sendNotification(order) { /* ... */ }
}

class OrderRepository {
  saveOrder(order) { /* ... */ }
}
```

#### 消除重复代码

```javascript
// 重构前：重复代码
class UserService {
  getUserProfile(userId) {
    const user = this.findUser(userId);
    if (!user) {
      throw new Error('User not found');
    }
    // 相同的验证逻辑重复出现
    if (!user.isActive) {
      throw new Error('User is inactive');
    }
    return user.profile;
  }
  
  getUserSettings(userId) {
    const user = this.findUser(userId);
    if (!user) {
      throw new Error('User not found');
    }
    // 相同的验证逻辑重复出现
    if (!user.isActive) {
      throw new Error('User is inactive');
    }
    return user.settings;
  }
}

// 重构后：提取公共逻辑
class UserService {
  validateActiveUser(userId) {
    const user = this.findUser(userId);
    if (!user) {
      throw new Error('User not found');
    }
    if (!user.isActive) {
      throw new Error('User is inactive');
    }
    return user;
  }
  
  getUserProfile(userId) {
    const user = this.validateActiveUser(userId);
    return user.profile;
  }
  
  getUserSettings(userId) {
    const user = this.validateActiveUser(userId);
    return user.settings;
  }
}
```

### 5. 重构模式

#### 策略模式替换条件判断

```javascript
// 重构前：复杂的条件判断
class ShippingCalculator {
  calculateShipping(country, weight) {
    if (country === 'US') {
      return weight * 0.5;
    } else if (country === 'EU') {
      return weight * 0.7;
    } else if (country === 'ASIA') {
      return weight * 0.6;
    } else {
      return weight * 1.0;
    }
  }
}

// 重构后：策略模式
class ShippingCalculator {
  constructor() {
    this.strategies = {
      US: (weight) => weight * 0.5,
      EU: (weight) => weight * 0.7,
      ASIA: (weight) => weight * 0.6
    };
  }
  
  calculateShipping(country, weight) {
    const strategy = this.strategies[country] || this.defaultStrategy;
    return strategy(weight);
  }
  
  defaultStrategy(weight) {
    return weight * 1.0;
  }
}
```

#### 命令模式处理复杂操作

```javascript
// 重构前：复杂的操作链
class OrderProcessor {
  processOrder(order) {
    // 一系列复杂的操作
    this.validateOrder(order);
    this.reserveInventory(order);
    this.processPayment(order);
    this.updateInventory(order);
    this.sendConfirmation(order);
    this.logOrder(order);
  }
}

// 重构后：命令模式
class Command {
  execute() {}
  undo() {}
}

class ValidateOrderCommand extends Command {
  constructor(order) {
    super();
    this.order = order;
  }
  
  execute() {
    // 验证订单逻辑
  }
}

class OrderProcessor {
  processOrder(order) {
    const commands = [
      new ValidateOrderCommand(order),
      new ReserveInventoryCommand(order),
      new ProcessPaymentCommand(order),
      new UpdateInventoryCommand(order),
      new SendConfirmationCommand(order),
      new LogOrderCommand(order)
    ];
    
    commands.forEach(cmd => cmd.execute());
  }
}
```

### 6. 重构工具和技巧

#### 使用IDE重构工具

现代IDE提供安全的重构功能：
- 重命名变量/函数
- 提取方法
- 内联变量
- 移动类
- 提取接口

#### 代码分析工具

```javascript
// 使用ESLint规则检测代码异味
module.exports = {
  rules: {
    'complexity': ['error', 10], // 圈复杂度限制
    'max-depth': ['error', 4], // 嵌套深度限制
    'max-lines-per-function': ['error', 50], // 函数最大行数
    'max-params': ['error', 4] // 参数数量限制
  }
};
```

### 7. 重构的最佳实践

```javascript
// 重构检查清单
const refactorChecklist = {
  // 1. 测试保障
  hasSufficientTests: true,
  
  // 2. 小步重构
  smallIncrementalChanges: true,
  
  // 3. 频繁测试
  runTestsFrequently: true,
  
  // 4. 版本控制
  commitFrequently: true,
  
  // 5. 文档更新
  updateDocumentation: true,
  
  // 6. 性能监控
  monitorPerformance: true
};

// 重构过程示例
function refactorCode() {
  // 步骤1: 运行现有测试，确保功能正常
  runTests();
  
  // 步骤2: 进行小的重构更改
  performSmallRefactor();
  
  // 步骤3: 再次运行测试
  runTests();
  
  // 步骤4: 提交更改
  commitChanges('Refactor: 提取公共验证逻辑');
  
  // 步骤5: 重复直到完成
}
```

### 8. 重构的风险控制

- **渐进式重构**：小步快跑，每次只做小的改变
- **测试驱动**：确保重构前后功能一致
- **性能监控**：避免重构引入性能问题
- **团队协作**：与团队沟通重构计划
- **文档记录**：记录重构的原因和过程

### 9. 重构时机

- 修复bug时
- 添加新功能时
- 代码审查时发现的坏味道
- 代码难以理解或维护时
- 性能问题需要优化时

通过系统性的重构方法，可以持续改善代码质量，提高开发效率和软件的可维护性。