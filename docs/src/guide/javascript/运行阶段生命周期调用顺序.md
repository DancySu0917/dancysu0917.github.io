# 运行阶段生命周期调用顺序？（必会）

**题目**: 运行阶段生命周期调用顺序？（必会）

## 标准答案

React组件在运行阶段（更新阶段）的生命周期方法调用顺序是：
1. `static getDerivedStateFromProps()`
2. `shouldComponentUpdate()`
3. `render()`
4. `getSnapshotBeforeUpdate()`
5. `componentDidUpdate()`

这个顺序确保了组件状态的正确更新和DOM的同步。

## 深入理解

### 更新阶段生命周期详解

更新阶段发生在组件的props或state发生变化时，组件会重新渲染。以下是各生命周期方法的详细说明：

#### 1. static getDerivedStateFromProps(props, state)
- 静态方法，在render之前调用
- 用于根据新的props更新state
- 无论props是否改变都会被调用
- 必须返回null或要更新的状态对象

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, prevProps: props.value };
  }

  static getDerivedStateFromProps(props, state) {
    // 如果props.value改变，更新内部state
    if (props.value !== state.prevProps) {
      return {
        count: props.value * 2,
        prevProps: props.value
      };
    }
    return null; // 不更新state
  }

  render() {
    return <div>Count: {this.state.count}</div>;
  }
}
```

#### 2. shouldComponentUpdate(nextProps, nextState)
- 决定组件是否需要重新渲染
- 返回true则继续更新流程，返回false则跳过后续步骤
- 性能优化的关键点

```jsx
class OptimizedComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // 只有当value改变时才重新渲染
    return this.props.value !== nextProps.value;
  }

  render() {
    console.log('组件重新渲染');
    return <div>{this.props.value}</div>;
  }
}
```

#### 3. render()
- 核心方法，返回组件的JSX
- 纯函数，不能执行副作用
- 在这里调用setState会引发无限循环

#### 4. getSnapshotBeforeUpdate(prevProps, prevState)
- 在DOM更新前调用
- 返回值将作为componentDidUpdate的第三个参数
- 用于保存更新前的DOM状态信息

```jsx
class ScrollableList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 如果列表项增加了，保存滚动位置
    if (prevProps.list.length < this.props.list.length) {
      return this.listRef.current.scrollHeight - this.listRef.current.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果有快照值，调整滚动位置
    if (snapshot !== null) {
      this.listRef.current.scrollTop = this.listRef.current.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      <div ref={this.listRef}>
        {this.props.list.map(item => <div key={item.id}>{item.text}</div>)}
      </div>
    );
  }
}
```

#### 5. componentDidUpdate(prevProps, prevState, snapshot)
- DOM更新后立即调用
- 可以执行DOM操作和网络请求
- 接收前一个props、state和getSnapshotBeforeUpdate返回的快照

### 完整的更新流程示例

```jsx
class UpdateFlowExample extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    console.log('1. getDerivedStateFromProps');
    return null;
  }

  shouldComponentUpdate(nextProps, nextState) {
    console.log('2. shouldComponentUpdate');
    return true; // 允许更新
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('4. getSnapshotBeforeUpdate');
    return 'snapshot value';
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('5. componentDidUpdate');
    console.log('Previous props:', prevProps);
    console.log('Previous state:', prevState);
    console.log('Snapshot:', snapshot);
  }

  render() {
    console.log('3. render');
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          增加
        </button>
      </div>
    );
  }
}
```

### 函数组件中的生命周期替代方案

在函数组件中，使用Hooks来模拟生命周期行为：

```jsx
import React, { useState, useEffect, useRef } from 'react';

function FunctionalUpdateExample({ value }) {
  const [count, setCount] = useState(0);
  const prevValueRef = useRef();

  // 相当于 getDerivedStateFromProps + componentDidUpdate
  useEffect(() => {
    console.log('组件更新后执行');
    prevValueRef.current = value; // 类似getSnapshotBeforeUpdate
  });

  // 相当于 shouldComponentUpdate 的优化
  const memoizedValue = React.useMemo(() => {
    return value * 2;
  }, [value]); // 只有value改变时才重新计算

  // 相当于 componentDidUpdate
  useEffect(() => {
    console.log('value更新后执行:', value);
  }, [value]);

  return (
    <div>
      <p>Memoized value: {memoizedValue}</p>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}
```

### 注意事项

1. **避免在getSnapshotBeforeUpdate中执行副作用**：此方法应为纯函数
2. **谨慎使用shouldComponentUpdate**：不当使用可能导致UI不一致
3. **不要在render中执行副作用**：render应该是纯函数
4. **componentDidUpdate中调用setState要小心**：需要条件判断，避免无限循环

### 实际应用场景

- **getDerivedStateFromProps**：根据props计算衍生state
- **shouldComponentUpdate**：性能优化，避免不必要的渲染
- **getSnapshotBeforeUpdate**：保存滚动位置、表单数据等
- **componentDidUpdate**：网络请求、DOM操作、第三方库初始化

理解这些生命周期方法的调用顺序和作用，对于开发高性能React应用至关重要。
